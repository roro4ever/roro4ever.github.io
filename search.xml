<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网原 7.1 域名系统</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-7-1-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/%E7%BD%91%E5%8E%9F-7-1-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>应用层包括了各种应用协议。</p>
<p>人和应用程序，通过应用协议来使用网络。</p>
<h2 id="ip地址和域名">7.1.1 IP地址和域名</h2>
<h3 id="ip地址">1.IP地址</h3>
<p>Internet上的每台主机，都必须有一个唯一的标识——IP地址。</p>
<p>题外话：网络上的路由器也必须有IP地址。</p>
<p>TCP/IP模型中网际层的IP协议，就利用IP地址来传递信息。</p>
<p>IPv4的地址由32位(4个字节)构成，通常采用点分十进制写法。</p>
<p>点分十进制(Dotted decimal notation)：IP地址以10进制(0~255)按4个字节写做4段，以 <code>.</code> 分隔。</p>
<p>IPv4的点分十进制是和IPv6的冒分十进制相区别的。比如：<code>3FFE:FFFF:7654:FEDA:1245:BA98:3210:4562</code></p>
<p>IP地址的语义由2部分构成：</p>
<ul>
<li>网络标识：</li>
<li>主机标识：</li>
</ul>
<p>IP地址按地域(国家、地区）分配和管理，管理机构是 Inter NIC(Internet Network Information Center)。</p>
<p>IP地址分为了5类：<br>
<img src="/2019/12/01/网原-7-1-域名系统/网原-7-1-域名系统/20191105163812582_9610.jpg"></p>
<p>ABC类是分配给主机/路由器的普通IP地址，D类是组播(或称多播)IP地址。E类是实验性地址。</p>
<p>因为ABCDE类的开头比特位绝不相同，因此：理论上不存在相同IP不同主机的情况。</p>
<p>由IP地址的结构可以计算出各类地址的范围：</p>
<table>
<thead>
<tr class="header">
<th>地址分类</th>
<th>范围下限</th>
<th>范围上限</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A类</td>
<td>0.0.0.0</td>
<td>127.255.255.255</td>
</tr>
<tr class="even">
<td>B类</td>
<td>128.0.0.0</td>
<td>191.255.255.255</td>
</tr>
<tr class="odd">
<td>C类</td>
<td>192.0.0.0</td>
<td>223.255.255.255</td>
</tr>
</tbody>
</table>
<p>注意：<br>
理论上，A类地址的范围是 0.0.0.0 ~ 127.255.255.255，网络标识的范围 0 ~ 127。</p>
<p>但实际上， A类地址的网络标识范围只有 1~126，因为：</p>
<ul>
<li>网络标识 127(0111 1111)+任意主机号=127.x.x.x ：是环回地址。</li>
<li>网络标识段为全0(0000 0000)的也是主机地址，但比较特殊。
<ul>
<li>主机号也为全0(0.0.0.0) : 可以做源端但不可以做目的端，代表的是网络上的主机。</li>
<li>主机号不全为0：可以做源端但不可以做目的端，只是它代表的是网络上特定的主机。</li>
</ul></li>
</ul>
<p>因此，A类地址中，网络标识 1(0000 0001) ~ 126(0111 1110) 是非特殊的网络标识范围。</p>
<p>另外，对于任意的网络号，主机号全1的地址是广播地址。<br>
广播地址不可以做源端，只能做目的端。<br>
根据网络号的不同，广播地址分为：</p>
<ul>
<li>网络号全1，主机号全1：受限的广播，广播信号不会被路由器转发</li>
<li>网络号非全1全0，主机号全1：向网络号所在的网络广播</li>
<li>网络号非全1/全0，主机号全1，存在子网划分：向子网广播</li>
</ul>
<p><em>广播这一块还太粗糙，需要后续整理归纳，todo。</em></p>
<h6 id="子网掩码">子网掩码</h6>
<p>即使是C类地址，可分配的主机IP地址仍然非常大，而IP资源是有限的，为了节约IP资源，可以在主机标识部分用子网掩码再划分出子网(subnet)。</p>
<p>子网掩码和IP地址一样，也是32位，但它的主机标识部分为全0，仅ABC地址网络标识段+子网段有值。</p>
<p><code>IP地址 AND(逻辑与) 子网掩码 = 带子网的网络标识段</code></p>
<p>可以把子网掩码的二进制位数写在IP地址后面 <code>IP/n</code>。</p>
<ul>
<li>A类的默认子网掩码: 255.0.0.0（255=1111 1111，缩写成“/8”，表示网络标识占了8位）;</li>
<li>B类的默认子网掩码: 255.255.0.0（/16）;</li>
<li>C类的默认子网掩码: 255.255.255.0(/24)</li>
</ul>
<p>/30 = /(24 +6): C类地址的基础上，再占用6位来划分子网，255.255.255.252，<br>
/32 = /(24+8): C类地址基础上，再占用8位划分子网，255.255.255.255</p>
<p>问题：<a href="https://www.zhihu.com/question/285680797" target="_blank" rel="noopener">子网掩码必须从高位开始，连续的1吗？</a></p>
<p>回答：必须这样！这样才能够从父级子网中划分。</p>
<p>问题： <a href="https://www.zhihu.com/question/30470752" target="_blank" rel="noopener">IP相同，子网掩码不同可能吗？</a></p>
<p>回答：<br>
<img src="/2019/12/01/网原-7-1-域名系统/网原-7-1-域名系统/20191107153146131_20817.png"></p>
<p>不可能。<br>
定义了 0xxxxxxx这个子网，其他子网就不能使用0开头，不能再定义00xxxxxx和01xxxxxx，但允许继续定义10xxxxxx或者11xxxxxx。<br>
如果把 0xxxxxxx 和 1xxxxxxx 都定义了，就不能再定义其他子网了。</p>
<img src="/2019/12/01/网原-7-1-域名系统/网原-7-1-域名系统/20191107153952963_4372.jpg">
<h3 id="域名">2.域名</h3>
<p>TCP/IP网络中的主机和网络设备使用IP地址进行通信，但IP地址不方便人类记忆和使用，因此引入了域名系统，在IP地址和域名之间建立了映射关系。</p>
<p>域名只是一个逻辑概念，和具体的IP地址无关，只要管理机构允许，任意IP和任意域名都可以建立对应关系。<br>
域名和物理网络、主机的物理位置都无关。</p>
<p>域名采用了层次结构的、基于“域”的命名方案。</p>
<p>扩展： 什么是域？windows domain vs network domain 回答：<br>
<a href="https://en.wikipedia.org/wiki/Network_domain" target="_blank" rel="noopener">Network domain</a></p>
<p><a href="https://en.wikipedia.org/wiki/Windows_domain" target="_blank" rel="noopener">Windows domain</a></p>
<p>简单的说，Windows 域只是域的一种形式而已。</p>
<h2 id="域名系统的概念">7.1.2 域名系统的概念</h2>
<p>域名系统(DNS，Domain Name System)管理了Internet上的域名。</p>
<p>注意：<br>
独立于Internet的局域网，也可以通过架设 DNS服务器，建立主机和域名之间的映射，方便局域网内的用户记忆和访问主机，此情况下，可以使用 Internet上已经存在的域名，或者使用从未存在过的域名，因为这个域名仅仅在局域网内使用，并不会和 Internet 上的域名有何关系，所以没有影响。</p>
<p>DNS是一个分布式数据库系统(DBS,DataBase System)，包括：</p>
<ul>
<li>域名空间：是指域名+网站空间（虚拟主机），而非字面意义：域名的空间</li>
<li>域名服务器：</li>
<li>地址转换请求程序</li>
</ul>
<p>域名是一个树状结构，根节点是顶级域名，下面是二级域名，最下面的是主机名称。</p>
<p>域名的书写方法：<code>主机名. ... N级域名. ... 二级域名.顶级域名</code></p>
<p>说明：<br>
顶级域名就是1级域名，N级域名就是 N-1级域名的前缀。</p>
<p>在域名树中，：</p>
<ul>
<li>主机域名：叶节点，是某个域中某台主机的名称。比如：www.ecust.edu.cn(注意：www只是是主机名称而未标明所在域，完整的写法才叫主机域名)</li>
<li>网络域名：非叶节点，是某个网络域的名称。比如：ecust.edu.cn</li>
</ul>
<p>同一域中的主机，有着相同的网络域名，仅主机名不同。<br>
不同域中的主机，可以采用相同的主机名。<br>
因此，Internet中的两台主机，其域名必定唯一。</p>
<p>顶级域名（1级域名）有3类：</p>
<ul>
<li>国家地区顶级域名：cn, us, hk...</li>
<li>国际顶级域名：int (国际性组织)</li>
<li>分类顶级域名：com, net , org, edu</li>
</ul>
<p>二级域名由各国家自行制订。比如我国就由：</p>
<ul>
<li>类别域名：6个, ac, com, edu , gov, net, org</li>
<li>行政区域域名：34个, bj, sh, cd</li>
</ul>
<p>强调：</p>
<ol type="1">
<li>域名和物理网络没有关系，而是与DNS系统如何管理网络中的主机有关，比如同一物理网络中，某些主机可以分配域名，某些则没有域名。</li>
<li>域名和IP地址中的子网叶没有关系，理由同上。</li>
<li>一台主机可以拥有多个域名。可能是一个IP映射多个域名，也可能该主机有多个IP(多个网卡)，每个IP对应一个域名。</li>
</ol>
<h2 id="域名解析原理">7.1.3 域名解析原理</h2>
<p>运行了域名服务器程序的主机，称为域名服务器。</p>
<p>域名服务器通常是网络中专设的主机。</p>
<p>域名解析过程：</p>
<p>应用程序要将一个域名解析为IP地址时，就会调用域名解析函数(Resolve)。<br>
域名解析函数把要解析的域名放在DNS请求中，以UDP报文的形式发送给本地域名服务器。</p>
<p>如果本地域名服务器查找到该域名对应的IP地址，就返回UDP应答报文，应用程序获得IP地址后就进行通信。 如果本地域名服务器不能找到对应的 IP，就会向更上级域名服务器发送DNS请求。</p>
<p>如果上级域名服务器也不能解析，DNS请求会发送到根域名服务器</p>
<p>根域名服务器管辖了顶级域名，但它通常不负责域名解析，不过它记录了待解析域名中下级域名的IP地址，并将DNS请求转发到该下级域名服务器，下级域名服务器同样将DNS请求转发到再下级域名服务器，最终抵达授权域名服务器，由授权域名服务器返回IP地址。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第七章 应用层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 6.3 用户数据报传输协议</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-6-3-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/%E7%BD%91%E5%8E%9F-6-3-%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>用户数据报传输协议，User Datagram Protocol。</p>
<p>用户：应用程序进程。</p>
<p>UDP协议的PDU(Protocol Data Unit) = UDP段</p>
<h2 id="udp的特点">6.3.1 UDP的特点</h2>
<ol type="1">
<li>TCP/IP模型中，网际层只有无连接服务(IP协议)，传输层有面向连接(TCP)和无连接服务(UDP)。<br>
——题外话，即使是数据报子网，也能够提供面向连接服务，源端和源网络节点，目的端和目的网络节点，都建立了虚电路服务，通信子网内部采用数据报操作方式。</li>
<li>传输层的UDP协议，建立在网际层的无连接服务基础上。</li>
<li>传输层的UDP协议(UDP 段），和网际层的IP协议(数据报 Datagram)有区别，两者并不等同。</li>
</ol>
<p>UDP的特点：</p>
<ul>
<li>无需事先建立连接，进程直接发送数据。UDP属于无连接的数据传输方式。</li>
<li>不对UDP段进行检查</li>
<li>不需要对方应答</li>
<li>实时性好、效率高</li>
</ul>
<p>缺点：</p>
<ul>
<li>UDP段可能乱序到达，可能丢失、重复</li>
<li>由应用进程负责传输可靠性</li>
</ul>
<h2 id="udp数据传输机制">6.3.2 UDP数据传输机制</h2>
<h3 id="udp段的结构">1. UDP段的结构</h3>
<img src="/2019/12/01/网原-6-3-用户数据报传输协议/网原-6-3-用户数据报传输协议/20191104180836331_32297.png">
<ul>
<li>源端口：16bits，发出数据的应用程序占用的传输层端口。因为UDP段通常不需要确认/应答，所以是可选的。如果不使用，应置为0。如果要使用它，可以将其设置为应答段应送往的端口。</li>
<li>目的端口: 16bits，接收数据的应用程序占用的端口。</li>
<li>长度：包括UDP头在内的，整个UDP段的长度。</li>
<li>检验和：</li>
</ul>
<p>说明：<br>
如果发出UDP段的源主机是客户端（比如要送回应答段时），源端口可以是一个临时端口号。<br>
如果发出UDP段的源主机是服务器，源端口就必须是一个固定端口号。</p>
<h3 id="udp协议的端口号">UDP协议的端口号</h3>
<table>
<thead>
<tr class="header">
<th>协议名称</th>
<th>协议内容</th>
<th>端口号</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DNS</td>
<td>域名解析协议</td>
<td>53</td>
</tr>
<tr class="even">
<td>SNMP</td>
<td>简单网络管理协议</td>
<td>161</td>
</tr>
<tr class="odd">
<td>OICQ</td>
<td>聊天软件</td>
<td>8000</td>
</tr>
<tr class="even">
<td>TFTP</td>
<td>小型文件传输协议</td>
<td>69</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第六章 传输层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 6.2 传输控制协议</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-6-2-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/%E7%BD%91%E5%8E%9F-6-2-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>传输控制协议 TCP，把网际层不可靠的数据报传输服务（IP协议），转化为了可靠的面向连接的传输服务。</p>
<h2 id="tcp服务模型">6.2.1 TCP服务模型</h2>
<p>TCP 服务的特点：</p>
<ul>
<li>面向连接的传输：传输前先建立连接，传输完毕后释放连接。</li>
<li>端到端通信(port - port)：TCP不支持广播和组播，只能是1对1的。</li>
<li>高可靠性：TCP段顺序到达，即使出现丢失也必然重传（逻辑上视为不会丢失）</li>
<li>全双工传输：发方和收方建立连接后，建立了对称的两条路径，可以实现双向传输。</li>
<li>采用字节流方式：以字节为单位，传输字节序列。</li>
</ul>
<p>字节流方式：</p>
<p>todo</p>
<h2 id="tcp数据传输机制">6.2.2 TCP数据传输机制</h2>
<h3 id="tcp的段结构">1.TCP的段结构</h3>
<p>TCP用于大数据量传输，应用层把很长的报文交给传输层后，传输层将其分段，称为<strong>TCP报文段</strong>。</p>
<p>TCP报文段的结构如下图：</p>
<img src="/2019/12/01/网原-6-2-传输控制协议/网原-6-2-传输控制协议/20191101091627585_31909.png">
<h6 id="最大报文段长度-mss">最大报文段长度, MSS</h6>
<p>MSS(maximum segment size): TCP段的众多选项之一。</p>
<p>MSS 是：在某个TCP连接中，端系统(主机/网关)能够接收的TCP段的<strong>数据部分</strong>的最大长度。单位字节。</p>
<p>TCP在三次握手中，每一方都会建议对方：发来的TCP段采用建议的MSS值。如果对方不同意该期望值，则对方会采用默认值。(IPv4, 576-20-20 = 536 bytes, IPv6 = 1220)</p>
<p>同一连接中，不同方向的TCP段可以有不同的MSS值。</p>
<p>MSS 长度并不包括TCP段的头部长度，和，IP 分组的头部长度。</p>
<p>IP层具有一个与MSS相似的概念---MTU（Maximum Transfer Unit）。</p>
<p>下图反映了 MSS与MTU 的关系： <img src="/2019/12/01/网原-6-2-传输控制协议/网原-6-2-传输控制协议/20191102190131211_17370.jpg"></p>
<p>MSS值太小或太大都不合适。<br>
太小，例如MSS值只有1byte，那么为了传输这1byte数据，至少要消耗20字节IP头部+20字节TCP头部=40byte，这还不包括其二层头部所需要的开销，显然这种数据传输效率是很低的。<br>
过大，导致分组封装很大，那么在IP传输中分片的可能性就会增大，接受方在处理分片包所消耗的资源和处理时间都会增大。如果分片在传输中还发生了重传，网络开销还会进一步增大。<br>
因此合理的MSS是至关重要的。MSS的合理值应为保证分组不分片的最大值。对于以太网MSS可以达到1460byte.</p>
<h6 id="rtt往返时延">RTT，往返时延</h6>
<p>往返时延 RTT(Round-Trip Time) 或 RTD(Round-trip Delay Time) : 一个信号从源端到目的端的时间 + 该信号的应答信号从目的端返回源端的时间。</p>
<p>传输轮次：发出一个TCP段，收到一个TCP确认段。</p>
<h2 id="tcp拥塞控制">6.2.6 TCP拥塞控制</h2>
<p>从整体上来讲，TCP拥塞控制窗口变化的原则是AIMD（the Additive-Increase/Multiplicative-Decrease)，即加法增大倍数减小。</p>
<p>AIMD原则可以较好地保证流之间的公平性，一旦某个连接出现丢包，那么立即将其 ssthresh 减半 将 cwnd退避到1 mss，给其他新建的流留有足够的空间，从而保证整个传输的公平性。</p>
<h3 id="拥塞窗口-cwnd">拥塞窗口 cwnd</h3>
<p>拥塞窗口，cwnd, congestion window。</p>
<p>每个TCP连接中的发送方都有一个拥塞窗口，用于限制“待发而未确认的段”的数量。</p>
<p>拥塞窗口不等于TCP段中的win窗口——滑动窗口(rwnd)！<br>
滑动窗口是由接收方维护的接收窗口，用于在ACK确认段中告知发送方：你还可以发送多少个报文段。<br>
而拥塞窗口是发送方维护的发送窗口，它与接收方的滑动窗口和整个网络当前的拥塞状态都有关系。比如：有可能接收方的滑动窗口很大，但当前网络发生了拥塞，导致发送方的拥塞窗口（发送窗口）只能取很小的一个值。</p>
<p>发送方确定根据拥塞窗口和接收方的接收窗口，来确定发送窗口： <span class="math inline">\(发送方的发送窗口 = min(拥塞窗口 cwnd，接收方窗口 win)\)</span>。</p>
<p>拥塞窗口会随着接收窗口、网络的拥塞状态而变化。<br>
假设接收窗口足够大，发送方就会根据网络拥塞状况来调整拥塞窗口的大小：</p>
<ul>
<li>只要网络没有出现拥塞，就把拥塞窗口增大一些，以便把更多的TCP段发送出去。<br>
</li>
<li>如果出现拥塞，就减小拥塞窗口，减少注入到网络中的TCP段。</li>
</ul>
<p>尽管拥塞窗口的单位是字节，为了减少复杂度，理解算法的核心内容，讨论中的拥塞窗口数就用 MSS（Sender Max） 作为单位。</p>
<h3 id="慢启动slow-startcwnd-指数增大">慢启动(Slow Start)，cwnd 指数增大</h3>
<p>慢启动：TCP连接的几种拥塞控制策略之一。</p>
<p>发送方刚开始发送数据时，并不清楚网络当前的拥塞情况，如果立即注入大量TCP段到网络中就可能引起拥塞，较好的方法是由小到大逐渐增大发送窗口(即拥塞窗口)。</p>
<p>在开始时，设置 cwnd = MSS * 很小的倍数，假设为 1 MSS<br>
在每收到一个确认段后，把拥塞窗口扩大一倍。（这里有很多细节，简单理解为翻倍即可）。</p>
<p>在发生下列事件前，拥塞窗口会迅速的增大，数据传输率也相应的增大。<br>
但发生下列事件时，拥塞窗口就会减小：</p>
<ul>
<li>TCP段丢失(被中间节点丢弃，说明发生了拥塞）：此时就需要减少注入网络的负载。</li>
<li>接收方通知：接收窗口不允许继续发送了：调整拥塞窗口，甚至停发等待接收窗口变大。</li>
<li>cwnd = ssthresh ，拥塞窗口达到慢启动门限了：停止慢启动过程（指数增大），进入拥塞避免阶段（线性增大）。</li>
</ul>
<h6 id="慢启动门限-ssthresh">慢启动门限 ssthresh</h6>
<p>慢启动的 cwnd 可以很快的增长，从而尽快最大程度的利用网络带宽，但 cwnd 不能一直无限增大，否则会发生拥塞。</p>
<p>TCP设置了一个变量：慢启动门限，ssthresh(slow start threshhold) 。</p>
<p>大多数TCP实现中，ssthresh = 65536 byte。</p>
<h6 id="根据是否发生重传来判断拥塞">根据是否发生重传，来判断拥塞</h6>
<p>TCP如何判断网络是否发生了拥塞呢？通过是否发生了重传来判断。</p>
<p>我们直到，重传可能发生在2种情况下：</p>
<ul>
<li>段丢失：因为拥塞，中间节点资源不足，只能丢弃段。每一个发出的TCP段都有一个重传定时器(RTO,Retransmission Time Out)，若直到RTO超时都尚未收到ACK确认段，那么发方就应对该报文段进行重传。<br>
</li>
<li>段错误：因为位错误，无法通过校验，节点将其丢弃，不发ACK确认段，time out后导致重传。</li>
</ul>
<p>在某些情况下，比如无线网络中，传输错误确实可能发生，但相对来说，现在的网络，尤其是有线网，错误率非常低，因此一旦发生重传，则可以理解为就是发生了拥塞。</p>
<p>事实上，除了超时，后面会讲到的3 ACK，也会导致重传，它同样属于拥塞。因此把 重传 视作拥塞。</p>
<h3 id="cwndssthresh进入拥塞避免congestion-avoidancecwnd-加法增大">cwnd&gt;=ssthresh，进入拥塞避免(congestion avoidance)，cwnd 加法增大</h3>
<p>一旦 cwnd &gt;= ssthresh ，就结束慢启动阶段，进入拥塞避免阶段。</p>
<p>拥塞避免算法：<br>
每次收到ACK确认段后，cwnd 只增加 1 个报文段的长度。<br>
cwnd = cwnd + 1 MSS</p>
<p>( 具体实现有差异，有的版本是 cwnd = cwnd + 1mss / cwnd, 但都是线性递增的)</p>
<p>注意：<br>
TCP连接中，发送方并不是从应用层每收到一个段就立即发送出去，而是可以积累到一定量后再发。<br>
接收方也并不是每收到一个段，就立即发回ACK确认信息，同意可以对多个段只确认一次，只要ACK没有超时，这多个段就算接收成功了。</p>
<p>cwnd的值随着传输轮次线性增加，逐步调整发送窗口，在“最大化利用带宽”和“发生拥塞”之间寻找平衡点，避免了cwnd 增长过快导致网络拥塞很快发生的情况。</p>
<p>在拥塞避免阶段，随着 cwnd 的增大，最终也会发生拥塞，表现为确认段的超时，此时：</p>
<ol type="1">
<li>ssthresh = cwnd / 2</li>
<li>cwnd =1 MSS</li>
<li>开始慢启动阶段</li>
</ol>
<h6 id="快速重传-fast-retransmit">快速重传, fast retransmit</h6>
<p>通常情况下，TCP发送方使用一个计时器来识别段丢失：如果超过RTT时间没有收到该段的确认段，则认为该段已经丢失，应重传该段。</p>
<p>而快速重传则使得发送方无需等待RTT时间，即刻判断段丢失，从而更快的重传丢失段。</p>
<p>快速重传机制利用了TCP段的发方序列号和收方确认号的关系：<br>
发方TCP段带有序列号 SEQ(sequence number)，收方确认段带有确认号ACK(acknowledgement number)。</p>
<p>确认号的意义：收方告知发方，“序列号 &lt; 确认号”的所有段都已正确接收，期待发送“序列号=确认号”的段。</p>
<p>假设，收方收到SEQ=1的段，随即返回 ACK = SEQ + 1 = 2的确认段，通知发方：SEQ=1的段已经接收，请发送SEQ=ACK=2的段！<br>
再假设，发方发出了SEQ=2,3,4的3个TCP段，却都因为拥塞在网络中丢失了，而随后SEQ=5,6的段却抵达了收方。</p>
<p>收方对SEQ=5的段发送确认段时，按照ACK的含义，只能令ACK=2(即SEQ=1已正确接收，期待发送SEQ=2的段)。同理，SEQ=6的段的确认段也只能令 ACK=2。</p>
<p>这样一来，发方就会收到2个“ACK=2的确认段”，即“重复的确认段”。<br>
一旦出现这种情况，发方就可以判断出：SEQ=2的段丢失了！此时无需继续等待 SEQ=2的段的确认段超时，可以立即重发 SEQ=2的段，SEQ =3,4 的段同理。这就是快速重传！</p>
<p>在某些实现中，发方收到3个相同ACK的确认段，即可立即重传SEQ=ACK的段。</p>
<h3 id="如果在任意阶段发生了段丢失">如果在任意阶段发生了段丢失，</h3>
<p>注意：段丢失发生在慢开始阶段，或拥塞避免阶段，都会触发 TCP Tahoe/ Reno #### TCP Tahoe</p>
<ol type="1">
<li>快速重传丢失的段</li>
<li>ssthresh = cwnd / 2</li>
<li>cwnd = 1 MSS</li>
<li>开始慢启动</li>
</ol>
<h4 id="tcp-reno快速恢复">TCP Reno，快速恢复</h4>
<ol type="1">
<li>ssthresh = cwnd / 2</li>
<li>cwnd = cwnd / 2 + 3 = ssthresh + 3</li>
<li>快速重传丢失的段</li>
<li>cwnd = ssthresh<br>
</li>
<li>开始拥塞避免(线性递增 cwnd)</li>
</ol>
<h4 id="快速恢复的数据报守恒原则">快速恢复的“数据报守恒”原则</h4>
<p>快速恢复的思想是“数据包守恒”原则：<br>
同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP的ACK机制就表明有一个数据包离开了网络，于是cwnd加1。</p>
<p>如果能够严格按照此原则，那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。</p>
<p>具体来说快速恢复的主要步骤是：</p>
<ol type="1">
<li>当收到3个重复ACK时，把ssthresh设置为cwnd的一半(ssthresh = cwnd /2)，把cwnd设置为ssthresh的值加3 ( cwnd = cwnd /2 + 3 )，然后重传丢失的报文段。<br>
加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。</li>
<li>如果再收到重复的ACK，拥塞窗口增加1(如果丢失的段后有多于3个段抵达收方，或者快速重传的段被确认了，就还会收到重复的ACK）。</li>
<li>当收到新的ACK确认段时，把cwnd设置为第一步中的ssthresh的值(cwnd = ssthresh)。如果确认了新的段，说明快速重传的段已确认，进入拥塞避免状态。</li>
</ol>
<h6 id="实例讲解">实例讲解</h6>
<p>下图中：</p>
<ul>
<li>建立连接时，ssthresh = 16，cwnd = 1</li>
<li>点1之前是慢开始阶段，cwnd 增长很快，每经过一个轮次就翻倍，</li>
<li>当到达点1 时，进入拥塞避免，cwnd 每经过一个轮次加一，线性增长</li>
<li>到达点2时，网络发生拥塞，出现确认段 time out，此时将 ssthresh = cwnd /2 ，cwnd =1, 开始慢启动阶段，即点2-点3的阶段</li>
<li>点2-点3的慢启动阶段，cwnd 倍增，直到 cwnd &gt;= ssthresh，</li>
<li>点3开始进入拥塞避免</li>
<li>点4，出现段丢失（可能是拥塞，也可能是网络错误，但都视为拥塞），此时采用快速恢复手段，ssthresh = cwnd /2, cwnd = cwnd +3, 快速重传丢失段，cwnd = ssthresh, 开始拥塞避免</li>
<li>点5，快速恢复后的拥塞避免阶段。</li>
</ul>
<p>到达点2的时候，网络发生拥塞了，网络出现了超时。就将 ssthresh 设置为 cwnd 的一半，并将 cwnd 重新设置为1 ，重新开始慢开始算法。到点3 时，达到了阈值，继续采用了拥塞避免算法。</p>
<img src="/2019/12/01/网原-6-2-传输控制协议/网原-6-2-传输控制协议/20191103014501256_13104.png">
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第六章 传输层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 6.1 传输层基本概念</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-6-1-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E7%BD%91%E5%8E%9F-6-1-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="传输层在osi中的地位和作用">6.1.3 传输层在OSI中的地位和作用</h2>
<p>前面讲的是TCP/IP中的传输层，这一小节讲的是OSI/RM中的传输层。</p>
<p>OSI/RM和TCP/IP两种参考模型的区别，见2.4 OSIRM与TCPIP参考模型的比较。<br>
简单的说，OSI的传输层只有面向连接的服务，TCPIP的传输层可以提供面向连接服务和无连接服务。</p>
<ul>
<li>负责网络通信的低三层（物理层、数据链路层、网络层）：为主机提供点对点的通信服务。</li>
<li>负责数据通信的最高层（传输层）：负责端到端（发方端口-收方端口）的总体数据传输和控制的一层。</li>
<li>负责信息处理的高三层（会话层、表示层、应用层）：</li>
</ul>
<p>传输层的目的：</p>
<ol type="1">
<li>提供可靠的端到端（端口-端口）的通信；</li>
<li>向会话层提供独立于网络的传输服务。</li>
</ol>
<p>要实现上面的2个目的，传输层需要具备以下的功能：</p>
<ol type="1">
<li>为一个连接提供可靠的传输服务</li>
<li>端到端的序号和流量控制</li>
<li>端到端的差错控制</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第六章 传输层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 5.6 Internet 的互连层协议</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-5-6-Internet-%E7%9A%84%E4%BA%92%E8%BF%9E%E5%B1%82%E5%8D%8F%E8%AE%AE/%E7%BD%91%E5%8E%9F-5-6-internet-%E7%9A%84%E4%BA%92%E8%BF%9E%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<ul>
<li>互联网指：Internet。</li>
<li>互连网指：通过 IP 协议连接到一起的网络。</li>
</ul>
<p>TCP/IP 模型的互连层(Internet Layer)对应了 OSI/RM 的网络层，后文中两者可以替换。</p>
<p>从互连层（或OSI/RM 的网络层）的角度看，Internet 就是通过互连层协议，将多个自治系统AS或子网互连在一起构成的。</p>
<p>互连层有4个重要的协议：</p>
<ul>
<li>互连网协议：Internet Protocol, IP，提供了一种不可靠的，无连接的IP报文服务。是TCP/IP协议簇的核心。</li>
<li>互连网控制报文协议：Internet Control Message Protocol, ICMP</li>
<li>地址转换协议：Address Resolution Protocol, ARP</li>
<li>反向地址转换协议：Reverse Address Resolution Protocol, RARP</li>
</ul>
<h2 id="ip协议">5.6.1 IP协议</h2>
<p>IP协议（Internet Protocol,互连网协议）是互连层最重要的协议，具有多个功能：</p>
<ul>
<li>将多个网络连成一个互连网</li>
<li>将上层（传输层）发来的报文分割、封装成IP数据报</li>
<li>把IP数据报交给下层（主机-网络层），封装成帧后，通过局域网传输：</li>
<li>IP寻址、IP路由选择
<ul>
<li>如果目的主机在同一LAN中：目的主机的IP协议可以接收这些数据报（局域网互连设备没有互连层——转发器、网桥都没有互连层，只能依靠主机）；</li>
<li>如果目的主机不在同一LAN中：由LAN之间的IP路由器传送数据报（尽管局域网设备没有互连层，但IP路由器有互连层）</li>
</ul></li>
<li>将IP数据报组装成报文，提交给传输层</li>
<li>消除网络差异：Internet 连接了多个网络，每个网络的帧格式、地址格式都可能存在巨大差异（数据链路层、物理层遵循了不同的协议标准），而互连层就可以消除网络差异，向传输层提供统一的描述形式：IP数据报 和 IP地址。</li>
</ul>
<p>说明：<br>
&gt;也即一个 IP 数据报是通过互连网络，从一个 IP 模块传到另一个 IP模块，直到终点为止。</p>
<p>这里的IP 模块指“主机和网关”。</p>
<p>IP数据报分为2个部分：</p>
<ul>
<li>报头区：20个字节的固定部分+可选的任意长度部分（选项）</li>
<li>数据区</li>
</ul>
<h3 id="ip数据报的报头">1. IP数据报的报头</h3>
<img src="/2019/12/01/网原-5-6-Internet-的互连层协议/网原-5-6-internet-的互连层协议/20191010112251954_16583.png">
<p>因为位流是串行发送的，因此上图中的比特位会按照从上到下、从左到右的顺序依次发送。</p>
<ul>
<li>版本(4bits)：该IP数据报使用的IP协议版本。IPv4 IPv6</li>
<li>IP报头长度(IHL,Internet Header Length,4bits): 整个头部的长度（包括选项）。以32 bits为单位，普通IP数据报（没有选项），字段值是5。接收端通过此域可以计算出报头的结束位置和数据部分的开始位置。</li>
<li>服务类型 (TOS,Type of Service, 8bits)：主机可以在此字段中要求通信子网提供哪种类型的服务，或者说，规定了本数据报的处理方式。</li>
<li>总长度 (16bits)：报头+数据的总长度，以字节为单位。利用头部长度 IHL 和总长度字段，可以计算出 IP 数据报中数据部分的起始位置和长度。</li>
<li>标识(16bits)：主机给每个IP数据报赋予的唯一的身份标识。</li>
<li>分片标志(3bits)：包括了DF和MF2个标志，分别表示了：是否允许路由器对IP数据报进行分片，以及是否是分片的最后一片。</li>
<li>分段偏移(13bits)：分片的数据区在原数据区的偏移位置。</li>
<li>生存时间(TTL,Time to Live,8bits): IP数据报的生命周期，每经过一个路由器就会递减，在路由器中排队时可以倍数递减。</li>
<li>上层协议标识(8bits):IP协议可以承载各种上层协议，目标端根据协议标识就可以把收到的IP数据报送到TCP或UDP等处理此报文的上层协议了。</li>
</ul>
<img src="/2019/12/01/网原-5-6-Internet-的互连层协议/网原-5-6-internet-的互连层协议/20191010161431134_13939.png">
<ul>
<li>头校验和(16bits)：仅用于校验头部</li>
<li>源地址(32bits)：源主机的IP地址。</li>
<li>目的地址(32bits)：目的主机的IP地址。</li>
<li>选项(变长)：可以由多个选项组成，每一个选项用一个字节标明其内容，有些还可以跟一个字节的长度字段+ 多个字节的数据字段。</li>
</ul>
<p>目前已经定义的选项有5个：</p>
<ol type="1">
<li>安全性：IP数据报的安全程度。</li>
<li>严格的源路由选择：以IP地址序列的方式，给出了源到目的完整路径。IP数据报必须走这条路径。此选项的主要作用是：路由器故障、网关发送紧急分组、路径时间测量等。</li>
<li>宽松的源路由选择：要求IP数据报经过所列的路由，但中间可以穿过其他路由器。</li>
<li>记录路由：记录了此 IP数据报流经路由器的IP地址，Debug用。</li>
<li>时间标记：除了记录流经路由器的IP地址外，再记录流经时间。Debug用。</li>
</ol>
<h3 id="ip数据报的分片和重组">2. IP数据报的分片和重组</h3>
<h6 id="最大传输单元-mtu">最大传输单元 MTU</h6>
<p>网络中物理帧的最大长度 MTU：<br>
IP数据报在互联网上是封装成物理帧来传输的，可能要经过多个物理网络才能从源端传输到目的端。<br>
不同的网络由于数据链路层和介质的物理特性不同，对物理帧的最大长度有一个限制，这个限制值即最大传输单元MTU（Maximum Transmission Unit）。</p>
<p>路径MTU：<br>
当通信要经过多个MTU值不同的网络时，其中最小的MTU值称为路径MTU。<br>
路径MTU是整条路径的瓶颈。<br>
由于路由选择不一定是对称的（从A到B的路由，与从B到A的路由，可能不同），因此，<strong>路径MTU在两个方向上可能不同</strong>。</p>
<p>下表是几种常用网络的MTU值：<br>
<img src="/2019/12/01/网原-5-6-Internet-的互连层协议/网原-5-6-internet-的互连层协议/20191010120420237_6450.png"></p>
<h6 id="分片">分片</h6>
<p>当通信发生在同一个网络内时，MTU是确定的，主机在发出IP数据报时就会根据MTU对IP数据报的长度进行处理，不存在分片问题。</p>
<p>分片：<br>
当通信发生在互联网中时，IP数据报需要穿过多个具有不同MTU值的网络，仅靠主机无法控制IP数据报的大小，就需要路由器根据相连网络的MTU把一个数据报分成多个数据报，这个过程称为分片。</p>
<p>分片后的各个IP数据报可能经过不同的路径到达目标主机。</p>
<p>由于路由器工作在互连层/网络层，容易对IP数据报进行操作，因此分片工作通常由路由器负责。</p>
<p>分片后的IP数据报，和原来的IP数据报具有相同的结构：</p>
<img src="/2019/12/01/网原-5-6-Internet-的互连层协议/网原-5-6-internet-的互连层协议/20191010120707197_22229.png">
<p>分片后的IP数据报，数据区是原数据区的一部分。<br>
头部则复制了原IP数据报的头部，但与原来未分片的IP数据报头部有两点主要不同：</p>
<img src="/2019/12/01/网原-5-6-Internet-的互连层协议/网原-5-6-internet-的互连层协议/20191010120733943_13339.png">
<p>(1)标志：在IP数据报头部有一个叫“标志”的字段，用3位二进制数表示：</p>
<ul>
<li>不分片DF（Do not Fragment）标志：如果被置1，则数据报在传输过程中路由器不能将其分片。如网络连通性测试命令ping就可以用-F参数设置为传输时不分片，但这样可能无法不能通过MTU较小的网络时，会产生数据不可达的错误。</li>
</ul>
<p>片未完MF（More Fragment）标志：如果被置1，说明该数据报不是分片后的最后一个数据报，最后一个数据报的该位被置0。</p>
<p>(2)片偏移：IP数据报被分片后，各片数据区在原来IP数据区中的位置。用13位片偏移来表示。</p>
<p>上图中分片1的偏移为0；分片2的偏移为600；分片3的偏移为1200。<br>
实际应用中,偏移是以8个字节为单位，因而在IP数据报中分片1的偏移是0；分片2的偏移是75；分片3的偏移是150。</p>
<h6 id="重组">重组</h6>
<p>重组：<br>
目标主机需要把分片后的IP数据报组装成原IP数据报，这个过程叫做“IP数据报的重组”。</p>
<p>IP数据报头部的标识字段，是每一个原始数据报的唯一标识。</p>
<p>目标端主机重组数据报的原理是：</p>
<p>(1)根据“标识”字段可以确定分片属于哪个原始 IP 数据报；</p>
<p>(2)根据“标志”字段的“片未完MF”子字段可以确定分片是不是最后一个分片；</p>
<p>(3)根据“偏移量”字段可以确定分片在原数据报中的位置。</p>
<h3 id="ip协议如何处理输入数据报">3. IP协议如何处理输入数据报</h3>
<ul>
<li>主机的IP协议对输入数据报的处理：
<ul>
<li>就是目的地：接收后传给高层协议软件。</li>
<li>不是目的地：抛弃该IP数据报。</li>
</ul></li>
<li>网关的IP协议对输入数据报的处理：（这里的网关可能是指 网关+路由器+网关）
<ul>
<li>就是目的地：接收后传给高层协议软件。</li>
<li>不是目的地：对IP数据报进行寻径，随后转发出去。</li>
</ul></li>
</ul>
<h3 id="ip对输出数据报的处理">4. IP对输出数据报的处理</h3>
<p>IP协议对输出数据报的处理也分为主机和网关两种，实际上是类似的。</p>
<p>网关的IP协议收到IP数据报后，经过寻址和路由，找到下一个网关的IP地址，然后将IP数据报和下个网关的IP地址交给网络接口软件。</p>
<p>网络接口软件收到 IP数据报和下一个网关的IP地址后，调用 ARP 协议将下个网关的IP地址翻译成物理地址，然后将 IP数据报封装成帧，最后交给下层（网络-主机层）完成物理传输。</p>
<h6 id="ip地址">IP地址</h6>
<p>IP地址：符合IP协议的地址。</p>
<p>常用的IPv4 地址，采用32bits，通常写作圆点分隔的4个十进制数字，192.168.0.1</p>
<p>以下为扩展资料。 ###### 网络接口是什么 <a href="https://en.wikipedia.org/wiki/Network_interface" target="_blank" rel="noopener">Network interface</a></p>
<p>Network Interface，网络接口，或叫网络介面。</p>
<p>在计算机领域，网络接口是指一个软件或硬件，它位于两个设备之间，或计算机网络的两个协议层之间。</p>
<p>网络接口通常具有某种形式的网络地址，包括节点标识符+端口号，或者一个唯一的节点ID。</p>
<p>网络接口具有的标准功能包括：传输信息，连接/断开连接，等等。</p>
<p><a href="https://docs.oracle.com/javase/tutorial/networking/nifs/definition.html" target="_blank" rel="noopener">What Is a Network Interface?</a></p>
<p>网络接口是一台计算机和一个网路之间的连接点。</p>
<p>网络接口可以与物理网卡绑定，但并非必须，比如环回地址就没有绑定，详见后文。</p>
<p>网络接口对于 multi-homed 系统很有用。<br>
通过 java 的 NetworkInterface 类，你可以将特定的网络活动指派给特定的NIC。</p>
<blockquote>
<p>NetworkInterface is useful for a multi-homed system, which is a system with multiple NICs. Using NetworkInterface, you can specify which NIC to use for a particular network activity.</p>
</blockquote>
<h6 id="multi-homed-system">multi-homed system</h6>
<p>Multihomed System 就是具有多个NIC的系统，或者说具有多个网络接口的主机，通常连接多个网络，做路由器使用。</p>
<p>Multihomed describes a computer host that has multiple IP addresses to connected networks. A multihomed host is physically connected to multiple data links that can be on the same or different networks. For example, a computer with a Windows NT 4.0 Server and multiple IP addresses can be referred to as "multihomed" and may serve as an IP router.</p>
<p>Using the Stream Control Transmission Protocol (SCTP), multihoming allows a single SCTP endpoint to support multiple IP addresses, which means that a session is more likely to survive a network failure. In a single-homed session, a network failure can isolate the end system or make transport temporarily unavailable. Multihoming means that redundant local area networks (LANs) can be used to support local access. Various approaches, such as using addresses with different prefixes to force routing through different carriers, or even using redundant core networks, can be taken to reduce the effects of failures.</p>
<p>Multihoming is commonly used in Web management for load balancing, redundancy, and disaster recovery.</p>
<h6 id="网络接口软件">网络接口软件</h6>
<p>网络接口软件的解释，详见：<br>
<a href="https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/network/tcpip_interfaces.html" target="_blank" rel="noopener">TCP/IP network interfaces</a></p>
<p>网络接口软件是“与特定网络相关的软件”，它在 互连层和“特定网络的设备驱动程序”之间通信，使网络设备（主机/路由器）中可能存在的一个或多个网卡在 IP层 呈现为一致的接口。<br>
换句话说，IP层通过网络接口软件，可以就与设备内的多个网卡通信。</p>
<p>需要说明的是，网络接口并非一定要和网卡相关联，比如环回地址就没有关联到任何网卡。</p>
<p>一台设备连接的每一个网络都必须具有一张网卡。<br>
但多张网卡可以只使用一个网络接口软件。比如：某主机连接到了两个令牌环网络，它必须具有2张网卡，然后，只需要一份令牌环网络接口软件，和一份令牌环设备驱动程序。</p>
<h2 id="arp协议与-rarp协议">5.6.2 ARP协议与 RARP协议</h2>
<h3 id="地址转换协议-arp">1. 地址转换协议 ARP</h3>
<p>TCP/IP网络中，每个主机分配的IP地址是互连层的逻辑地址，而报文的物理传输必须依赖主机-网络层和物理地址，因此必须根据目标主机的IP地址获取到其物理地址。</p>
<h6 id="lan中的arp">LAN中的ARP</h6>
<p>互连层的ARP协议：使主机可以在同一物理网络中，根据目的 IP地址得到其物理地址。</p>
<p>在进行报文传输时，如果源端不知道目的端的物理地址，就广播 ARP请求，同一物理网络的目的站收到广播后做出回答，源收到回答后就把目的站的物理地址保存到自己的高速缓存中，以后就可以使用。</p>
<p>ARP协议使物理网络的物理编址对互连层（网络层）透明。</p>
<h6 id="internet中的arp">Internet中的ARP</h6>
<p>为了将报文送到另一个网络的目标主机，应先把 IP数据报送到本网络的IP路由器。<br>
因此应通过ARP广播请求，获取IP路由器的物理地址，然后送到路由器。</p>
<p>路由器在下一个AS中仍然调用ARP协议，根据IP地址获取下一跳（或目标主机）的物理地址，再传输物理帧。</p>
<p>有时还可以在路由器上设置代理ARP：由路由器代替目标主机回答ARP请求，向发送方返回物理地址。</p>
<h3 id="反向地址转换协议-rarp">2. 反向地址转换协议 RARP</h3>
<p>RARP适用于一种特殊情况：<br>
站点初始化后，只有自己的物理地址，没有IP地址。</p>
<p>RARP协议可以发出 广播请求，询问自己的IP地址，RARP服务器收到后会做出回答。</p>
<p>通过RARP协议，无IP地址的站点就可以获得IP。</p>
<h2 id="icmp协议">5.6.3 ICMP协议</h2>
<p>因为IP数据报是一种不可靠的无连接服务，当发生传输错误、网络拥塞时，就需要一种报文来通知发送方，这些报文称为控制信息。</p>
<p>控制信息：网络通不通、目标主机是否可达、某条路由是否可用等信息。</p>
<p>控制信息通常由发现故障的站点发出，比如目的主机、路由器。</p>
<p>互联网控制报文协议(ICMP,Internet Control Message Protocol)：IP数据报的目的方或路由器，向发送方发出控制信息，报告网络传输差错、网络拥塞等情况的协议。</p>
<h2 id="igmp协议">5.6.4 IGMP协议</h2>
<p>Internet "组管理"协议(IGMP,Internet Group Management Protocol)。</p>
<p>单播(unicast)：最常见的传输形式，发送方和接收方1对1的关系。</p>
<p>广播(broadcast):发送方只有一个，局域网中所有节点都是接收方。</p>
<p>多播/组播(Multicast)：一个发送方对应多个接收方，接收方可能不是所有主机，也可能跨多个网段。</p>
<h6 id="多播的组地址">多播的组地址</h6>
<p>IP协议采用D类地址来支持组播，每个D类地址有28位，代表了一组主机。</p>
<p>Internet 支持两类组地址</p>
<ul>
<li>永久组地址：不需要创建，总是存在。比如224.0.0.1表示局域网中所有的主机；224.0.0.2 表示局域网中所有的路由器；224.0.0.5表示局域网中所有的OSPF路由器。</li>
<li>临时组地址：需要先创建才能使用。一个进程可以要求其宿主加入或退出某个特定的组。当主机上所有进程都退出某个组后，整个主机也就退出了该组。每个主机都要记录进程所属的组。</li>
</ul>
<p>当某个D类地址作为目标 IP地址时，就表示要同时向该组中的每个主机发送该IP数据报，但网络也仅仅是尽最大努力将报文传送给每个主机，并不能保证全部送达，组内有些主机可能收不到这个报文。</p>
<h6 id="多播路由器">多播路由器</h6>
<p>多播功能需要多播路由器支持，它也有普通路由器的功能。</p>
<p>多播路由器会周期性的发出一个目的地址为224.0.0.1的多播报文，要求局域网内所有主机报告其进程所属组。各主机会反馈其所有进程所属组的D类地址（临时组地址），多播路由器将情况记录下来，并向其他多播路由器通告。</p>
<p>如果某个组内已经没有本地网络中的主机，多播路由器就认为本地网络中已经没有主机属于该组了（有可能组仍然存在，但属于其他网络），以后也不再向其他的多播路由器通告该组成员的情况。</p>
<p>多播路由器和主机之间采用 IGMP协议 进行询问和响应。</p>
<p>IGMP只有两种报文：询问和响应。</p>
<p>IGMP报文的传输：把IGMP报文加上IP报头作为IP数据报进行传输。</p>
<h6 id="虚拟的多播主干网">虚拟的多播主干网</h6>
<p>多播主干网，MBONE, Multicast Backbone On the Internet。</p>
<p>MBONE可以把报文传输给一个组的主机，即使这些主机分散在不同的网络中。</p>
<p>MBONE中的多播路由器称为 MRouter, Multicast Router，它既可以是专业的多播路由器，也可以是运行多播软件的普通路由器。</p>
<h6 id="多播路由器的路由协议">多播路由器的路由协议</h6>
<p>距离向量多播路由协议(DVMRP, Distance Vector Multicast Route Protocol)。</p>
<h6 id="在不支持多播的网络中采用隧道技术">在不支持多播的网络中，采用隧道技术</h6>
<p>多播报文可能穿过多个网络，如果某些网络不支持多播(比如没有多播路由器)，可以用“隧道”来解决——通过隧道技术，将多播报文封装为普通报文进行单播传输，当多播报文进入一个支持多播的网络后解除封装还原成多播报文继续传输。</p>
<p>网络隧道技术：利用一种网络协议来传输另一种网络协议，是构建VPN的关键技术。 目前主要利用网络隧道协议(Tunneling Protocol)来实现这种功能。</p>
<p>隧道协议（Tunneling Protocol）是一类网络协议，它是一种数据报封装技术，它将原始IP报封装在另一个数据包（称为封装IP数据报）的数据净荷字段进行传输。</p>
<h2 id="ipv6">5.6.5 IPv6</h2>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第五章 网络层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 5.5 网络互连</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-5-5-%E7%BD%91%E7%BB%9C%E4%BA%92%E8%BF%9E/%E7%BD%91%E5%8E%9F-5-5-%E7%BD%91%E7%BB%9C%E4%BA%92%E8%BF%9E/</url>
    <content><![CDATA[<h2 id="网络互连原理">5.5.1 网络互连原理</h2>
<p>网络互连的目的：</p>
<ul>
<li>使一个网络的用户能访问另一个网络的资源（用户与资源交互，实现资源共享）</li>
<li>使不同网络上的用户能够互相通信、交换信息（用户与用户交互）</li>
</ul>
<p>实现网络互连的前提：</p>
<ul>
<li>互连的网络间，至少有一条链路，并具有对这条链路的控制规程</li>
<li>在不同网络的进程之间，必须有路由器实现进程间的数据交换</li>
<li>有一个统一的计费服务，记录不同网络的使用情况和状态信息：这里的计费不是指价格，而是指“距离”、“通路费用”</li>
<li>互连时尽量不修改网络的体系结构</li>
</ul>
<p>注意：<br>
第一条前提，不是确指物理链路、数据链路，而是在各层都需要遵循这个基本原则。<br>
在物理层，就需要有物理线路或Repeater，且要有物理链路的控制规程；在数据链路层，就需要有Bridge，有BSC/HDLC/SLIP/PPP等数据链路的控制规程。</p>
<p>网际互连的障碍：想要互连的网络可能在多个方面存在差异，要互连就必须消除差异。</p>
<p>互连网络的差异包括下列方面：</p>
<ol type="1">
<li>体系结构：例如 OSI 、TCP/IP 等</li>
<li>层次协议：分层不同，各层内含的协议不同</li>
<li>网络服务：低层向高层提供的服务、网络向用户提供的服务</li>
<li>寻址方式</li>
<li>路由选择：静态、动态，其中又有细分</li>
<li>最大分组长度</li>
<li>网络接入机制</li>
<li>用户接入机制</li>
<li>超时控制</li>
<li>差错恢复方法：ARQ，FEC，停等协议，顺序管道协议，选择重传协议</li>
<li>状态报告方法</li>
<li>服务类型：面向连接、无连接</li>
<li>管理方式：</li>
</ol>
<p>其中差异 4~13 主要体现在各种局域网中。</p>
<p>需要说明：<br>
如果把需要互连的网络等价为 OSI 7层模型，网络差异不仅表现在网络层，而是表现在每一层，因此网络互连需要消除的差异是相当大的，经常会出现 OSI 网络和 非OSI 网络互连的需求。</p>
<h5 id="网络互连设备">网络互连设备</h5>
<p>网间连接器：把不同网络互连起来的设备。在互连网络的对应层级间完成协议和功能的转换。</p>
<p>协议和功能的转换：不同的网络在相似的层可能采用不同的协议，网络互连设备要能够在该层理解并翻译不同协议的控制信令和数据。</p>
<p><a href="https://www.geeksforgeeks.org/network-devices-hub-repeater-bridge-switch-router-gateways/" target="_blank" rel="noopener">Network Devices (Hub, Repeater, Bridge, Switch, Router, Gateways and Brouter)</a></p>
<h5 id="基础知识">基础知识</h5>
<h6 id="网段">网段</h6>
<p>一个网段就是一个物理网络。</p>
<p>根据 IEEE 802.3 以太网标准，<br>
网段：网络中，通过“工作在物理层的设备”（传输介质、转发器、集线器等）相连的那一部分。</p>
<p>具体分为几种情况：</p>
<ol type="1">
<li>用某种传输介质直接连接两个网络（或两组主机），构成一个网段。如交叉双绞线直接连接的两台主机。<br>
</li>
<li>如果两个网络（或两组主机）不以传输介质直接相连，而是通过“工作在物理层的信号扩展设备”（如中继器、集线器）相连，也属于同一网段。</li>
</ol>
<p>相反，工作在数据链路层或更高层的设备（如网桥、交换机、路由器、网关等），由它们连接起来的两个物理网络分别处于各自独立的物理层，属于两个网段。</p>
<p>要判断互连的两个网络是否属于同一个网段，就看互连设备是否工作在物理层。</p>
<p>术语“网段”还有一个误用，常常被用于代指“子网subnet”（以太网上的一个广播域）——子网是数据链路层上一个独立的内部相互作用区域。这是一种不规范的用法，应该避免。</p>
<h6 id="冲突域">冲突域</h6>
<p>冲突域： 同一网段内（通过共享介质或Repeater、hub连接），当多个站点同时发出信号（位流）准备通信时会发生冲突，只能竞争传输线路。冲突发生并传播的区域，就是冲突域。</p>
<p>冲突域是一个共享段：当一个站点向另一个站点发出信号（位流）时，冲突域内的所有站点都能收到该信号。</p>
<p>冲突域属于OSI的物理层。<br>
物理层设备（Repeater, Hub) 无法划分冲突域。<br>
数据链路层设备（bridge,switch）、网络层设备（router）、传输层及以上层的设备(gateway)可以划分冲突域。</p>
<h6 id="广播域">广播域</h6>
<p>某站点发出一个广播帧，能收到这个广播帧的范围，就是广播域。</p>
<p>广播域属于OSI的数据链路层。<br>
物理层设备 Repeater、Hub，数据链路层设备 Bridge、Switch 无法划分广播域。<br>
网络层设备（router、第三层交换机）、传输层及以上层的设备（Gateway) 可以划分广播域。</p>
<p>总结：<br>
运行在高层的设备可以划分低层对应的域，高层设备还具有低层设备的互连功能。</p>
<h6 id="转发器中继器repeater">1. 转发器（中继器），Repeater</h6>
<img src="/2019/12/01/网原-5-5-网络互连/网原-5-5-网络互连/2aOP7E.png">
<p>转发器（Repeater)：工作在物理层。</p>
<p>作用：</p>
<ul>
<li>对衰减或延迟畸变的信号进行再生，延长信号的传输距离，<br>
</li>
<li>将两个物理网络连接成一个物理网络。</li>
</ul>
<p>注意：<br>
1. 转发器并不会放大信号，当信号减弱时，转发器逐位拷贝原始信号，“再生”出一个新的、强度足够的信号继续传播。 2. 转发器是一个2口设备。 3.因为同一个网段就是同一个物理网络，所以转发器互连的网络在逻辑上属于同一个网络。</p>
<h6 id="集线器hub">集线器，hub</h6>
<p>集线器：多口转发器。</p>
<img src="/2019/12/01/网原-5-5-网络互连/网原-5-5-网络互连/20191002153628059_18352.png">
<h6 id="网桥bridge">2. 网桥，bridge</h6>
<p>网桥：工作在数据链路层，提供数据链路层的协议转换（比如后图5-13，在Wireless Lan的802.11协议和Ethernet的802.3协议之间转换）</p>
<p>网桥有几个作用：</p>
<ol type="1">
<li>连接网段。注意：连接后仍属于不同的网段。</li>
<li>分割网段，划分冲突域：将1个网段划分成2个，各网段相互独立，从而防止用户的跨网段非法访问，各网段内的故障也被隔离。</li>
<li>过滤功能：如果帧不跨网段则不转发该帧，利用过滤功能可对帧进行隔离。</li>
<li>利用寻址和路由能力，存储转发帧：根据路由表来决定是否转发，以及转发到哪一个输出端口（端口对应网段）</li>
<li>扩展网络容量：扩大了网络范围，容量自然增大。</li>
</ol>
<p>网络容量：Network capacity is the amount of traffic that a network can handle at any given time. This includes the number of simultaneous voice calls and maximum data speeds. Capacity varies by area.</p>
<p>需要注意的是，网桥的过滤功能针对的是非广播帧，而广播帧的目标地址就是整个广播域，网桥会把它转发到连接的每一个网段中。</p>
<h6 id="交换机switch">交换机，switch</h6>
<p>交换机：多口的网桥。</p>
<p>当设备接入交换机后，交换机会建立“MAC地址：端口”的MAC映射表。<br>
以后，发往该MAC地址的帧，会直接发往对应的端口，而不是所有端口。</p>
<p>交换机可以划分出冲突域，但不能划分出广播域。</p>
<h6 id="路由器router">路由器，Router</h6>
<p>工作在网络层。</p>
<p>提供网络层的协议转换：从一条输入线路上接收分组，再向另一条输出线路转发，这两条线路可能属于不同的网络，采用的协议也可能不同。</p>
<p>路由器在不同的网络之间存储转发分组。</p>
<h6 id="网关-gateway又称为协议转换器">网关, Gateway，又称为协议转换器</h6>
<p>提供高层（传输层、会话层、表示层、应用层）的协议转换，因此又称为协议转换器。</p>
<p>注意：<br>
因为术语的不统一，在某些文章中，“网桥+路由器+网关”统称为网关。<br>
此时“网关”指的是：在数据链路层及以上各层之间，进行协议转换的网间连接器。比如IGP,EGP中的Gateway。</p>
<h2 id="网桥技术">5.5.2 网桥技术</h2>
<p>网桥工作在数据链路层，负责<em>相似局域网</em>间<strong>帧的转发</strong>。</p>
<p>局域网的差异，主要表现在： MAC子层和物理层 遵循不同协议标准的局域网。</p>
<blockquote>
<p>介质访问控制子层，MAC layer(Medium Access Control)：属于数据链路层，定义了数据帧怎样在介质上传输，为局域网各主机分配共享信道的使用权，定义了物理寻址、逻辑拓扑，实现了线路控制、出错通知、帧的传递顺序和可选的流量控制。</p>
</blockquote>
<p>IEEE 802.1 定义了网桥的协议结构（准确的说，应该是 802.1b)。</p>
<img src="/2019/12/01/网原-5-5-网络互连/网原-5-5-网络互连/20191002005744179_22071.png">
<p>主机A 的工作流程：</p>
<ol type="1">
<li>分组 Pkt 由网络层 Network 交给 数据链路层的子层：逻辑链路控制子层 LLC<br>
</li>
<li>LLC 给 Pkt 添加 LLC控制信息，然后交给了 数据链路层的子层：媒体访问控制子层 MAC子层</li>
<li>MAC 子层又添加了帧头，形成 MAC 帧，经过物理层、物理介质，传输到网桥的W端口。</li>
</ol>
<p>网桥 Wireless LAN端口（简称W端口）的工作流程：</p>
<ol start="5" type="1">
<li>W端口具有802.11的物理层和MAC子层，因此可以逐层剥离头部，最终在LLC层得到 Pkt。</li>
<li>在左侧端口的LLC层，利用 Pkt 的目标MAC地址查询路由表，发现应该送到右侧端口，</li>
</ol>
<p>ethernet端口（简称E端口）、主机B的的过程和左侧相逆，略。</p>
<p>说明：<br>
802.11是无线局域网的标准（MAC协议：DCF/PCF)，802.3是有线以太网的标准（MAC协议：CSMA/CD)，桥连接了两个MAC协议不同的网络。</p>
<p>网桥除了可以转发跨网段的数据帧以外，还可以接收控制帧（HDLC/BSC/PPP），以及“以桥为目的的帧”等所有帧。</p>
<p>以桥为目标的帧——网桥的每一个端口都有自己的MAC地址。</p>
<h6 id="桥如何避免和应对拥塞">桥如何避免和应对拥塞</h6>
<p>网桥应该有足够的缓冲区，以避免大量发送到桥的MAC帧造成拥塞。</p>
<p>同时，桥应该有应对拥塞的控制机制，比如：对于已经被多个桥转发的帧，桥收到后应优先转发，这样才不会浪费已经花费在转发该帧上的带宽。</p>
<h6 id="网桥有过滤功能">网桥有过滤功能</h6>
<p>一个网桥的某个端口连接了局域网后，该端口就和该LAN具有一样的MAC子层和物理层。</p>
<p>过滤功能体现在：<br>
假设某网桥连接了2个LAN，当它收到一个非广播帧时（冲突域内，所有节点都可以收到非广播帧），网桥就检查帧内的源MAC地址和目标MAC地址：</p>
<ul>
<li>如果源和目标在同一个网段（寻址的体现），则将其过滤，不转发给另一个网段，实现冲突域隔离。</li>
<li>如果源和目标不在一个网段，网桥就查询路由表，将其转发到正确的端口。</li>
</ul>
<h6 id="网桥有mac路由功能">网桥有MAC路由功能</h6>
<p>网桥的路由功能，表现为：</p>
<ul>
<li>多个网段通过一个多口网桥（即交换机）互连：网桥在相邻网段间，进行MAC寻址、查询路由表、存储转发到另一个网段</li>
<li>多个网段、多个网桥互连：此时的网桥会实现跨多网段的路由。比如透明网桥，通过类似链路状态路由算法的方法，以某个网桥为根建立生成树。</li>
</ul>
<p>注意：<br>
网桥的路由功能并不会把帧送到主机，而仅仅送到端口即可，因为冲突域内每个站点都可以接收帧，最终由目的主机的MAC子层来判断是否应该接收该帧。</p>
<h3 id="透明网桥-transparent-bridge">1. 透明网桥, Transparent Bridge</h3>
<h6 id="混杂模式和非混杂模式">混杂模式和非混杂模式</h6>
<p>混杂模式（promiscuous mode）：设备能够接收所有流经它的数据流，而不论目的地址是否是它。</p>
<p>非混杂模式：只接受目的地址指向自己的数据。</p>
<h6 id="透明的含义">透明的含义</h6>
<p>透明网桥可以支持不同种类的LAN互连（LAN的差异主要表现在MAC子层和物理层）。 LAN和透明网桥相连后，整个网络立即可以运行，不需要配置硬软件，不需人工配置路由表，LAN不需要做任何修改。<br>
对于LAN内主机来说，透明网桥是不存在的、其运行是不可见的，则就是透明的含义。</p>
<h6 id="路由表过滤数据库的工作方式">路由表（过滤数据库）的工作方式</h6>
<p>透明网桥内有一个基于MAC地址的路由表（过滤数据库），它记录了：</p>
<ul>
<li>当前LAN内所有主机的MAC地址：</li>
<li>MAC地址对应的端口号：即输出线路，对应了一个LAN</li>
<li>每条记录的计时器</li>
</ul>
<img src="/2019/12/01/网原-5-5-网络互连/网原-5-5-网络互连/20191003001841365_13074.png">
<p>上图中，左侧的表格就是路由表，ABCDE在真实的路由表中应该替换为MAC地址，计时器字段没有列出。可以看到，Bridge2 将 ABC都与自身的端口1相对应。</p>
<p>透明网桥的工作步骤：<br>
收到一个帧后，根据帧的目标MAC地址，查询过滤数据库：</p>
<ul>
<li>如果查到该MAC地址对应的输出端口，且输出端口不等于来路端口，且输出端口没有阻塞，则转发到该输出端口，如果有阻塞则丢弃该帧（需要发方重传）</li>
<li>如果查不到目标MAC对应的输出端口（没有记录），则将该帧广播到除来路端口外的所有端口，目标主机收到该帧后会返回一个响应帧，透明网桥根据响应帧建立路由记录。</li>
</ul>
<h6 id="逆向学习法建立路由表">逆向学习法，建立路由表</h6>
<p>透明网桥初始化时，路由表为空，通过逆向学习法(Backward Learning)，逐渐的建立起路由表。</p>
<p>逆向学习法：<br>
当一个帧（数据帧、广播后返回的响应帧）到达透明网桥的某个端口时，网桥就根据源MAC地址、来路端口号，建立、更新一条路由记录。<br>
LAN的拓扑结构、网内主机可能会不断变化，每条记录还设置了一个计时器，当计时器超时后，该记录就过时了，随后删除。</p>
<h6 id="网桥循环">网桥循环</h6>
<p>通过增加备用线路和备用网桥，可以实现更大的冗余度和更强的容错能力，但会导致一个问题：<br>
两个网段间，同时存在多条线路和网桥时，会构成循环。</p>
<img src="/2019/12/01/网原-5-5-网络互连/网原-5-5-网络互连/20191003005951107_14975.png">
<p>从A发出的广播帧，会被B1、B2网桥无休止的转发，直到耗尽所有带宽，并阻塞两个网段中其他帧的传输。</p>
<h6 id="生成树算法spanning-tree-algorithm-sta">生成树算法，Spanning Tree Algorithm, STA</h6>
<p>生成树算法可以解决循环路径问题，其思路是：<br>
把新增的冗余网桥和线路设置为“备用”模式，当主链路失效时，启用备用网桥和线路。</p>
<p>STA是动态的：当网络拓扑结构发生变化时（新增、删除网桥或线路），所有的网桥能注意到变化，立即运行STA。</p>
<p>STA基于图论中一种“提取连通图生成树”的算法：<br>
在互连网络中，每一个LAN对应于连通图的一个顶点，每一个网桥对应连通图的一个边。删去连通图的一个边等价于移去一个网桥。将构成回路的网桥逐个移去，最后得到的生成树不含回路，但又不改变图的连通性。</p>
<p>STA算法需要先建立如下概念：</p>
<ul>
<li>用每个端口的MAC地址作为端口标识符。<br>
</li>
<li>用“指定的一个2字节的优先级编号 + 网桥某一端口的MAC地址”作为网桥标识符，</li>
<li>指定通路费用：给网桥的每个端口指定一个通路费用，该费用表示通过该端口向“与其连接的LAN”传送一个帧的代价。两个主机之间的通路可能要经过多个网桥，这些网桥的有关端口的费用相加就构成了两站之间的通路的费用。例如，假定沿路每个网桥端口的费用为1，则两个站之间通路的费用就是经过的网桥数。另外也可以把网桥端口的通路费用与有关LAN的通信速率联系起来（一般为反比关系）。</li>
</ul>
<img src="/2019/12/01/网原-5-5-网络互连/网原-5-5-网络互连/20191004151645116_8607.png">
<p>以上图为例，网段E的某主机传送一个帧到网段B的某主机，经B4的R端口的通路费用=10，经B3的R端口的通路费用为20。</p>
<ul>
<li>根桥：作为生成树树根的网桥，例如可选择MAC地址值最小的网桥作为根桥。<br>
</li>
<li>根通路：每一个网桥通向根桥的费用最小的通路。<br>
</li>
<li>根端口：每一个网桥与根通路相连接的端口。<br>
</li>
<li>指定桥：一个LAN可以有多个网桥，每个网桥都有一个根通路，其中根通路费用最小的网桥就是指定桥。如果一个LAN的多个网桥的根通路费用相同，则选择优先级最高的网桥作为指定桥。</li>
<li>指定端口：指定桥连接该LAN的端口为指定端口（指定端口和根端口是相对的），如果指定桥有多个端口连接LAN，则选取MAC值最小的端口作为指定端口。直接连接根桥的LAN，根桥就是指定桥，连接根桥的端口即为指定端口。 指定端口是为了应对一个指定网桥有多个端口接入一个LAND的情况（LAN和指定网桥的多个端口形成循环）。</li>
</ul>
<p>STA算法的步骤：</p>
<ol type="1">
<li>确定一个根桥</li>
<li>确定其他网桥的根端口</li>
<li>对每一个LAN确定一个唯一的指定桥和指定端口</li>
</ol>
<p>按照以上3步算法，在直接连接两个LAN的多个网桥中，只能有一个作为指定桥，非指定桥或指定桥的非指定端口会处于阻塞状态。这就排除了两个LAN之间的任何环路。</p>
<p>但由此带来了透明网桥的缺点：带宽利用率较低，毕竟只使用了拓扑结构的子集——生成树。</p>
<p>网桥之间通过每隔几秒交换信息，来更新拓扑结构，若需要就重新计算生成树。</p>
<p>总结：STA算法类似于“链路状态分组”。</p>
<h3 id="源路由选择网桥source-routing-bridge">2. 源路由选择网桥，Source Routing Bridge</h3>
<p>支持总线网的人喜欢用透明网桥，支持令牌环网的人则喜欢用源路由选择网桥。</p>
<img src="/2019/12/01/网原-5-5-网络互连/网原-5-5-网络互连/20191004175841547_26674.gif">
<p>基本思想：<br>
每台源主机都知道从自身到目标主机的路由信息RI（Routing Information，网桥编号和LAN编号的序列）。如果目标主机是跨网段的，则把 RI 写入跨网段帧的头部，并将源地址的高位置为1（称为RII,routing information indicator，书上写错了，写成了目的地址的高位）。网桥只处理RII = 1（跨网段帧），网桥根据 RI 信息判断自己是否在转发路径中，并确定转发给哪个 LAN：</p>
<ul>
<li>如果 RI 中包含了自己的网桥编号，则将该帧转发给后续的 LAN</li>
<li>如果 RI 中不包含自己的网桥编号，则不转发（一个LAN接多个网桥时，可能会走其他网桥，换句话说，源主机设定的路径不是当前网桥）。</li>
</ul>
<blockquote>
<p>RI 路径的表示方法：源主机所在 LAN 编号 + 网桥1编号 + 下一个LAN的编号 + 网桥2编号 +下一个 LAN 编号 ......<br>
每个LAN有唯一编号，每个网桥在一个LAN中有唯一的编号。<br>
因此：</p>
</blockquote>
<blockquote>
<ul>
<li>具有多个网桥的LAN，每个网桥在其中的编号是不同的<br>
</li>
<li>连接多个LAN的网桥，在每一个LAN中的编号是不同</li>
<li>跨LAN的不同网桥，可能具有相同的编号</li>
</ul>
</blockquote>
<p>从基本思想可以看出，源路由选择的重点在于：源如何事先获取到达每个目标主机的最佳路径。具体步骤如下：</p>
<p>最开始，A 不知道 B 在同一令牌环网还是其他LAN中，于是发出一个测试帧，如果测试帧返回时没有携带B的应答，说明B位于其他网段中。<br>
A会发出一个探索帧( explorer frame，广播帧)。广播帧被每个网桥接收，接收到该广播帧的网桥如果在RI信息中，则不必进行回应；如果没有，则向RI信息中增加网桥编号和LAN编号，并继续转发到与其连接的、不在RI信息中的LAN，直到转发到目标节点B。<br>
目标节点B返回给源节点A一个应答帧，因为探索帧是广播，最终A会接收到多个应答帧。由A选出最佳路径，以后写入数据帧的RIF中。该算法可能会引发广播风暴。</p>
<h2 id="网络互连协议internet使用的协议">5.5.3 网络互连协议（Internet使用的协议）</h2>
<p>前面介绍的网桥，是在数据链路层互连LAN的设备，本节介绍的路由器用于 Internet，在网络层互连不同的网络 。</p>
<h3 id="路由信息协议riprouting-information-protocol距离向量路由选择算法">1. 路由信息协议(RIP,Routing Information Protocol,距离向量路由选择算法)</h3>
<p>说明： 5.2 路由选择中的“距离矢量路由算法”将的是算法。<br>
而本机讲述的是实现了该算法的、真实应用的协议。</p>
<p>RIP 是采用了距离向量路由算法的路由协议。</p>
<p>RIP协议可以在主机和路由器中实现，由此产生了两种操作方式的RIP：</p>
<ul>
<li>主机实现的RIP：工作在被动状态，它不会向其他路由器发送自身路由表中的路由信息，只是接收其他RIP路由器广播的路由信息，并根据收到的路由信息更新自己的路由表。</li>
<li>路由器中实现的RIP：工作在主动状态，它定期将自身的路由信息传递给其他的RIP路由器，并根据其他RIP路由器发送给它的路由信息更新自己的路由表。</li>
</ul>
<p>被动RIP很简单，本节讨论主动RIP。</p>
<p>RIP路由器的路由表的每条表项，记录了：</p>
<ul>
<li>这条路由最终目的地地址：用IP地址表示（Internet上，用IP地址作为身份证明）</li>
<li>这条路由到目的地的距离：RIP 的度量单位是跳数，即规定每一条链路的成本为1，而不考虑链路的实际带宽、时延等因素。如果距离为n，说明到达目的地需要经过n个路由器。</li>
<li>这条路由中，下一个路由器的地址：如果下一跳就是目的地，则此字段为空</li>
<li>路由改变标志：指示这条路由信息最近是否被改变过</li>
<li>和这条路由有关的计时器：</li>
</ul>
<h6 id="运行rip协议的机器如何交换信息">运行RIP协议的机器，如何交换信息？</h6>
<p>实现RIP的机器（主机/路由器）：</p>
<ul>
<li>每隔30秒向外广播自身的路由信息。</li>
<li>向其他路由器发送 Request 消息，询问它们保存的所有/部分路由信息：比如某主机开机后，可能要求相邻的RIP路由器向它传递路由表中的所有信息。</li>
</ul>
<h6 id="rip路由器如何更新自己的路由表">RIP路由器如何更新自己的路由表</h6>
<p>假设：<br>
路由器 R 想更新到达目的地 D 的路由信息（如果没有这条路由就新增，如果有就更新）。</p>
<p>路由器 R 从 相邻的路由器G 收到一个路由信息时（可能是R向G发出Request，也可能是 G 发出的广播），R会在收到的路由信息中检查每一条通往目的地D的路由，假设G到D的距离为 cost(G,D)，R到G的距离为 cost(R,G)=1，此时会出现几种情况：</p>
<p><strong>1.R的路由表中不存在到D的路由</strong></p>
<p>在R的路由表中增加一条路由，内容如下：</p>
<ul>
<li>R - D的路径的下一跳：G</li>
<li>R - D的距离：cost(R,G) + cost(G,D)</li>
</ul>
<p><strong>2.R的路由表中有一条到D的路由 cost(R,D)</strong></p>
<p>此时需要比较"老的路由和新获取的路由"哪个距离更短。假设新路由距离更短：<br>
cost(R,D) &gt; cost(R,G) + cost(G,D)</p>
<p>将原来通往D的老路由，更新为新路由：</p>
<ul>
<li>R - D路径的下一跳：G</li>
<li>R - D的距离：cost(R,G) + cost(G,D)</li>
</ul>
<p>注意：如果老路由和新路由在距离上一样，则不更新，以维持路由的稳定。</p>
<h6 id="路由器的超时机制">路由器的超时机制</h6>
<p>周期更新定时器：用来激发RIP路由器路由表的更新，每个RIP节点只有一个更新定时器，设为30s。每隔30s路由器会向其邻居广播自己的路由表信息。每个RIP路由器的定时器都独立于网络中其他路由器，因此它们同时广播的可能性很小。</p>
<p>超时定时器：用来判定某条路由是否可用。每条路由有一个超时定时器，设为180s。当一条路由激活或更新时，该定时器初始化，如果在180s之内没有收到关于那条路由的更新，则将该路由置为无效。</p>
<p>清除定时器：用来判定是否清除一条路由。每条路由有一个清除定时器，设为120s。当路由器认识到某条路由无效时，就初始化一个清除定时器，如果在120s内还没收到这条路由的更新，就从路由表中将该路由删除。</p>
<p>当一个RIP路由器（设为R）收到路由信息后，</p>
<ul>
<li>如果发现某条路由没有发生变化，则重置该条路由的超时计时器，重新开始计时。</li>
<li>如果某个相邻的路由器（假设为G）失效了，则 R 无法在30秒内收到以G为起点的路由信息。如果经过180秒后都未收到 G发来的路由信息，则说明路由 R - G 已经作废。</li>
</ul>
<p>但此时不会马上从 R 的路由表中删除 R-G 路由，因为还需要向其他的邻居路由器报告。<br>
在经过120秒的垃圾回收时间（Garbage Collection Timer)后，如果仍未收到 G 的路由信息，就把该条路由从 R的路由表中删去。</p>
<p>在作废某条路由时采取的机制，称为n中取k(k-out-of-n)，是一种可靠性设计，防止仅仅由于路由信息在传输中发生了丢失而导致的误作废。<br>
换句话说，如果在6次通知中收到一次邻路由的路由信息，就不需要作废(6 x 30 = 180)。</p>
<p>RIP的条数最多只能15跳，因此仅适用于小规模的网络。</p>
<h3 id="开放最短路径优先协议ospfopen-shortest-path-first链路状态路由选择算法">2. 开放最短路径优先协议(OSPF,Open Shortest Path First,链路状态路由选择算法)</h3>
<p>由于RIP是基于距离矢量算法的路由协议，存在着收敛慢、路由环路、可扩展性差等问题，而 OSPF作为基于链路状态的协议，能够解决RIP所面临的诸多问题。</p>
<p>OSPF 已成为最主要的内部网关协议（IGP)。</p>
<blockquote>
<p>Internet 由无数个自治系统（或称为域）组成。一个域（domain）由一组主机和使用相同路由选择协议的路由器组成，并由单一机构管理。</p>
</blockquote>
<p>OSPF还有以下优点：</p>
<ul>
<li>OSPF采用组播形式收发报文，这样可以减少对其它不运行OSPF路由器的影响。</li>
<li>OSPF支持无类型域间选路（CIDR）。</li>
<li>OSPF支持对等价路由进行负载分担：如果 OSPF 计算出某路由器到某个目的地存在多条最短路由，则可以将分组分散在这些路由上。</li>
<li>OSPF支持报文加密。</li>
<li>OSPF 的带宽占用小：链路状态分组很小，且很少需要传输。</li>
</ul>
<p>OSPF协议具有以下特点：</p>
<ul>
<li>OSPF把自治系统AS（Autonomous System）划分成逻辑意义上的一个或多个区域；</li>
<li>OSPF通过LSA（Link State Advertisement）的形式发布路由；</li>
<li>OSPF依靠在OSPF区域内各设备间交互OSPF报文来达到路由信息的统一；</li>
<li>OSPF报文封装在IP报文内，可以采用单播或组播的形式发送。</li>
</ul>
<p>注意：LSA不是报文，而是 OSPF 的通信机制。</p>
<h6 id="ospf-支持的拓扑类型">OSPF 支持的拓扑类型</h6>
<p>OSPF 支持3种类型的网络：</p>
<ul>
<li>点到点网络：即连接一对路由器的网络。</li>
<li>广播网络：有至少2个以上路由器、有广播功能的网络。</li>
<li>非广播方式的网络：有2个以上路由器，没有广播功能的网络。比如 X.25 分组交换网。 OSPF把非广播网络进一步分为了：
<ul>
<li>非广播多路访问网络(Non-Broadcast Multi-Access, NBMA)：这个网络上的路由器可以直接通信，它和广播方式的 OSPF 运作类似</li>
<li>一点到多点网络(Point-to-Multi-Point, PtMP)：看成多个点到点链路。</li>
</ul></li>
</ul>
<h6 id="邻接逻辑连接">邻接：逻辑连接</h6>
<p>通常情况下，每个路由器会定期扩散“ 链路状态更新报文”(LSU，Link State Update)。<br>
为了保证运行链路状态路由算法的所有路由器都能收到这个报文，路由器之间应该建立一个逻辑连接，LSU 就沿着逻辑连接传递出去。</p>
<p>路由器之间的逻辑链接被称为一个邻接（adjacency），被邻接的路由器互为“邻接路由器”。</p>
<p>大多数情况下，邻居路由器之间的连接属于邻接。<br>
但并不是所有的邻居路由器都是邻接路由器，因为那样会产生大量的重复报文。分析如下：</p>
<blockquote>
<p>假设一个ethernet有N个路由器，则总共可能有 N(N-1)/2条邻接——每个路由器可以向 N-1 个路由器发射出路径，共 N个路由，所以是 N(N-1)，去除双向发射，则 / 2，所以是 N(N-1)/2。<br>
当其中一个路由器收到一个链路状态消息时，它将这个消息的拷贝发送给其他 N-1 个路由器。每一个路由器收到信息后，又将发送给除来路的其他 N-2个路由器，则这个消息会被发送 N(N-2) 次，因此教材称为“大概有 N^2 个消息的拷贝在该网络上传递”。这样，每个节点都会收到大量的重复消息，然而并没有必要，事实上只需要 N 个消息的拷贝就足够了。</p>
</blockquote>
<p>为了防止出现大量的重复消息，对于广播网络和NBMA非广播网络，网络中的所有路由器会选举出一个代表，称为“选取路由器(DR,Designated Router)”：它被认为和所有的邻居路由器邻接。</p>
<p>而其他的邻居路由器之间没有邻接。</p>
<p>除了DR，还要选出一个“备用选举路由器（BDR,Backup Designated Router)”。</p>
<h5 id="ospf-的报文类型和运行步骤">OSPF 的报文类型和运行步骤</h5>
<table>
<colgroup>
<col style="width: 35%">
<col style="width: 64%">
</colgroup>
<thead>
<tr class="header">
<th>报文类型</th>
<th>报文作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Hello报文</td>
<td>周期性发送，用来发现和维持OSPF邻居关系。</td>
</tr>
<tr class="even">
<td>DD报文（Database Description packet）</td>
<td>描述本地LSDB（Link State Database）的摘要信息，用于两台设备进行数据库同步。</td>
</tr>
<tr class="odd">
<td>LSR报文（Link State Request packet）</td>
<td>用于向对方请求所需的LSA。设备只有在OSPF邻居双方成功交换DD报文后才会向对方发出LSR报文。</td>
</tr>
<tr class="even">
<td>LSU报文（Link State Update packet）</td>
<td>用于向对方发送其所需要的LSA。</td>
</tr>
<tr class="odd">
<td>LSAck报文（Link State Acknowledgment packet）</td>
<td>用来对收到的LSA进行确认。</td>
</tr>
</tbody>
</table>
<h6 id="hello-报文">Hello 报文</h6>
<p>Hello 报文用于发现邻居路由器、维护邻接关系。</p>
<ul>
<li>点对点网络：在链路上发送 Hello 消息即可</li>
<li>广播式网络：通过多点广播来交换消息</li>
<li>非广播网络：需要网络管理人员进行配置，从而发现邻居路由器</li>
</ul>
<h6 id="dd-packetdatabase-description">DD packet，Database Description</h6>
<p>DD报文是路由器”本地保存的链路状态信息（LSDB,Link State Database）“的一个摘要。</p>
<p>DD报文中有一个序列号，相当于数据的时间标记。</p>
<p>当一个路由器刚刚加入网络时（有可能是新增加的，也可能是因故障重启的），它的邻接路由器先向它发送DD报文，它收到后会先比较序列号，如果本地保存的序列号小于收到的，说明本地的链路状态已过时，它就应向邻接路由器发送 LSR 请求传递最新的路由信息。</p>
<h6 id="lsr-packet">LSR packet</h6>
<p>用于向对方请求所需的LSA。设备只有在OSPF邻居双方成功交换DD报文后才会向对方发出LSR报文。</p>
<h6 id="lsu-packet">LSU packet</h6>
<p>用于向对方发送其所需要的 LSA。 + 定期发送：每个路由器会定期，向自己的邻接路由器扩散 链路状态更新消息(LSU,Link State Update Message) ，消息中包括了链路状态、邻接关系、路径花费。<br>
+ 响应式发送：如果链路状态发生了变化，路由器也会立即向邻接路由器发送 LSU。</p>
<h6 id="lsack-packet">LSAck packet</h6>
<p>用于对收到的 LSA 进行确认。</p>
<h6 id="对ospf的总结这部分不需要理解超纲了">对OSPF的总结（这部分不需要理解，超纲了）</h6>
<p>综上所述，路由器通过扩散把自己的链路状态信息告诉它所在区域的其他路由器，每个路由器都建立一个它所在区域的有向图，并计算出最短路径。</p>
<p>主干区域中的路由器也执行相同的过程。</p>
<p>另外，主干区域还从区域边界路由器获取信息，计算出从主干每个非主干区域的最短路径，并将路径信息发给区域边界路由器，由该路由器在它的区域中广播该消息。通过这个消息，路由器在转发跨区域分组时，可以选择到主干区域的最佳出口（即最佳的区域边界路由器）。</p>
<p>关于OSPF ，建议寻找更系统、完整的文章来学习，教材上这个太零碎。</p>
<h2 id="网络互连设备-1">5.5.4 网络互连设备</h2>
<h3 id="网桥">1.网桥</h3>
<p>这一小节的内容和前面的网桥有些重复，故略去重复部分。</p>
<p>从网络互连的结构看，网桥属于 DCE 级的端到端的互连。<br>
这里的端到端，是源端-目的端。</p>
<p>局域网的逻辑结构分为：</p>
<ul>
<li>逻辑链路控制子层（LLC，属于数据链路层）</li>
<li>介质访问控制子层（MAC，属于数据链路层）</li>
<li>物理层</li>
</ul>
<p>异构局域网的差异主要体现在 MAC子层 和物理层上。</p>
<p>转发器 Repeater 工作在物理层，严格来所不算网络互连。<br>
网桥工作在数据链路层，也应算做一种网络互连的手段：因为局域网没有网络层（只有局域网中的主机才有网络层），网桥就是局域网互连的必要设备。</p>
<p>网桥接收到帧后，在数据链路层进行差错校验，然后送到物理层，再经传输介质送到另一个网段。</p>
<p>转发帧之前，网桥几乎不会修改帧的内容和格式。</p>
<h6 id="网桥的工作原理">网桥的工作原理</h6>
<img src="/2019/12/01/网原-5-5-网络互连/网原-5-5-网络互连/20191009002509900_20005.png">
<h3 id="路由器">2. 路由器</h3>
<h4 id="路由器和网桥的区别">路由器和网桥的区别</h4>
<ul>
<li>网桥工作在数据链路层：利用MAC地址转发数据帧。</li>
<li><p>路由器工作在网络层：根据IP地址转发分组。</p></li>
<li>用网桥连接2个局域网：物理层、数据链路层的协议可以不同，更高层必须采用相同的协议。</li>
<li><p>用路由器连接2个局域网：物理层、数据链路层、网络层的协议可以不同，但更高层必须采用相同的协议。</p></li>
</ul>
<p>注意：因为局域网自身没有网络层，这里的更高层应该是指局域网中的主机。</p>
<ul>
<li>网桥工作在数据链路层，传统局域网采用广播方式，容易产生”广播风暴“问题（网桥只能分割冲突域）。</li>
<li>路由器可以分割广播域，解决了广播风暴问题。</li>
</ul>
<h4 id="路由器的主要功能">路由器的主要功能</h4>
<ol type="1">
<li>建立并维护路由表：以OSPF 为例，路由器内部有 LSDB 和 路由表，根据LSDB 计算得到路由表。</li>
<li>在网络间存储转发分组：当路由器收到分组后，会检查分组的源IP和目标IP，再根据路由表，决定送往哪一个路由器或主机。</li>
</ol>
<h4 id="路由器的基本工作原理">路由器的基本工作原理</h4>
<img src="/2019/12/01/网原-5-5-网络互连/网原-5-5-网络互连/20191009005944995_14710.png">
<h6 id="互连网络的协议结构">互连网络的协议结构</h6>
<p>5-15(a)表示了：用2个路由器，将2个LAN，通过1个WAN互连的情况。</p>
<p>LAN1 是总线型以太网，LAN2 是令牌环网。WAN 是一个 X.25 分组交换网。</p>
<p>主机A 的传输层采用 TCP协议，网络层采用 IP协议。LLC 子层采用802.2协议，MAC子层和物理层采用802.3 的ethernet 协议。</p>
<p>主机B的传输层采用 TCP协议，网络层采用 IP协议。LLC子层采用802.2协议，MAC子层和物理层采用802.5的 Token Ring 协议。</p>
<p>路由器1的层次结构：</p>
<ul>
<li>与 LAN1 相连的端口1的LLC子层采用 802.2，MAC子层与物理层采用 802.3；</li>
<li>与 WAN 相连的端口2的网络层、数据链路层、物理层则采用与 X.25 分组交换网一致的协议。</li>
</ul>
<p>路由器2同理。</p>
<h6 id="路由器互连的网络中数据的传输过程">路由器互连的网络中，数据的传输过程</h6>
<p>以A向B发送数据为例来说明。</p>
<p>主机A的应用层数据（DATA）传送给传输层；<br>
传输层为其添加了TCP报头，将(TCP报头+DATA）发给网络层；<br>
网络层添加了IP报头，将（IP报头+TCP报头+DATA）发给数据链路层；<br>
最终形成的帧结构为：MAC 1 头部+LLC头部+IP头部+TCP头部+DATA</p>
<p>路由器1收到A的帧后，因为路由器1 的端口1 的LLC子层、MAC子层、物理层与主机A是一致的，帧A可以在端口1层层剥离，最终将（IP头+TCP头+DATA）送给路由器1 的网络层。</p>
<p>路由器1的网络层根据IP头部中的源IP和目的IP，通过路由表查询输出路径，发现应通过端口2发送到X.25网。</p>
<p>路由器1通过WAN端口2的X.25网的网络层，给（IP头+TCP头+DATA）添加上 X.25-3分组头，在X.25数据链路层添加 X.25-2帧头、X.25-2帧尾，最终组成（X.25-2帧头+X.25-3分组头+IP头+TCP头+DATA+X.25-2帧尾），通过X.25分组网，传输到路由器2。</p>
<p>路由器2的WAN端口收到该分组后，按照X.25分组网的数据链路层、网络层的顺序，逐级剥离帧头帧尾和分组头，将（IP头+TCP头+DATA）送到路由器2的网络层。</p>
<p>路由器2根据IP头，查询路由表后，送往端口2。在端口2，按照 LLC的802.2，MAC子层+物理层的802.5添加令牌环网的各种头部，最终将（令牌环 MAC2 头+令牌环LLC头+IP头+TCP头+DATA）送到主机B。</p>
<p>主机B收到该帧后，逐级去除MAC头、LLC头，得到（IP头+TCP头+DATA），在网络层，经过对比目的IP，发现自己应该接收该分组，遂去掉IP头，将（TCP头+DATA）递交给传输层。</p>
<h3 id="网关">3.网关</h3>
<p>网关：也叫协议转换器，为高层（传输层-会话层-表示层-应用层）提供协议转换功能。</p>
<p>传输层的协议转换包括：</p>
<ul>
<li>数据格式的重新装配</li>
<li>长数据的分段</li>
<li>地址格式的转换</li>
<li>操作规程的适配</li>
</ul>
<p>现实中具体协议在实现网关的协议转换功能时，可以不分层，从传输到应用层的协议转换可以一起进行。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第五章 网络层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 5.4 服务质量</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-5-4-%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/%E7%BD%91%E5%8E%9F-5-4-%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F/</url>
    <content><![CDATA[<p>Stream(Flow)：从信源到信宿的分组流。</p>
<p>如果子网采用虚电路操作方式，同一个流的分组会走同一条路径。<br>
如果子网采用数据报操作方式，同一个流的分组也会走不同的路由路径。</p>
<p>每个流对通信子网的传输性能是有要求的，称为服务质量。</p>
<p>服务质量: QOS，Quality of Service ，描述通信子网为流提供服务的性能指标。</p>
<p>QOS包括了4个方面：</p>
<ul>
<li>可靠性：误码率要求高，甚至不允许出错。</li>
<li>延迟</li>
<li>抖动</li>
<li>带宽</li>
</ul>
<p>不同的应用对于QOS的要求不同，具体要求如下：</p>
<table>
<thead>
<tr class="header">
<th>应用</th>
<th>可靠性</th>
<th>延迟</th>
<th>抖动</th>
<th>带宽</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>电子邮件</td>
<td>高</td>
<td>低</td>
<td>低</td>
<td>低</td>
</tr>
<tr class="even">
<td>文件传输</td>
<td>高</td>
<td>低</td>
<td>低</td>
<td>中</td>
</tr>
<tr class="odd">
<td>Web访问</td>
<td>高</td>
<td>中</td>
<td>低</td>
<td>中</td>
</tr>
<tr class="even">
<td>远程登录</td>
<td>高</td>
<td>中</td>
<td>中</td>
<td>低</td>
</tr>
<tr class="odd">
<td>音频点播</td>
<td>低</td>
<td>低</td>
<td>高</td>
<td>中</td>
</tr>
<tr class="even">
<td>视频点播</td>
<td>低</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr class="odd">
<td>电话</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>低</td>
</tr>
<tr class="even">
<td>视频会议</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
</tbody>
</table>
<p>在可靠性要求高的应用中，发送方会计算分组的校验和，校验和与分组一并送出，收方验证校验和，如果有差错，要求重发。注：这里的校验和可以是任何校验算法，不限于CRC。</p>
<p>其他几项要求就不详述。</p>
<p>目前，还没有一种技术能够以最优的办法提供高效的、可靠的QOS，只能综合运用多种技术手段来尽量满足应用的需求。</p>
<h2 id="qos体系结构集成服务和区分服务">5.4.1 QOS体系结构：集成服务和区分服务</h2>
<p>为了保证流式多媒体应用的服务质量，IETF先后设计了两种QOS体系结构：集成服务、区分服务。</p>
<h6 id="集成服务integrated-service">集成服务，Integrated Service</h6>
<p>集成服务：针对单播和多播应用，设计了一些“基于流的算法(Flow-Based Algrorithm)”（单播可以看作是多播的一个特例）</p>
<p>集成服务体系中，最重要的算法是资源预留协议(Resource reSerVation Protocal, RSVP)，提前预留资源，可以看作是提前建立流，类似于虚电路。</p>
<p>RSVP的主要任务是为流提前预留资源：</p>
<ul>
<li>多个发送方可以给多个接受组传送数据</li>
<li>接收方可以指定一个或多个数据源，</li>
<li>接收方可以指定数据源是固定的，还是以后可变的。</li>
<li>多个接收方使用同一个固定数据源的话，可以共享路径。</li>
</ul>
<p>路由器根据这些信息可以优化带宽的使用计划，甚至消除拥塞。</p>
<ul>
<li>优点：可以为少量的流提供非常好的服务质量。</li>
<li>缺点：提前建立流（提前资源预留）。如果需要建立几千几万个流，则扩展性太差。</li>
</ul>
<p>因此，集成服务目前没有具体实现，甚至RSVP算法的实现也很少。</p>
<h6 id="区分服务-differentiated-service">区分服务, Differentiated Service</h6>
<p>区分服务是比集成服务更加简单的QOS体系，而且已经被IETF标准化。</p>
<p>区分服务：不需要提前建立流，而是由每台路由器在局部范围内实现，不涉及整条路径。</p>
<p>区分服务，是按照整个子网的路由器按照应用类型来预留资源，比如：所有节点为网络中所有的 IP电话应用预留资源，为所有的文件传输应用预留资源，但任何一个IP电话/文件传输的流都不会在某条路径上单独预留资源，因此也称为“基于类别的(class-based)”服务质量。</p>
<h2 id="标签交换和-mpls">5.4.2 标签交换和 MPLS</h2>
<p>IETF推出集成服务和区分服务的同时，各厂商也推出了一种更好的路由转发思想：标签交换。</p>
<h6 id="标签交换label-switching-tag-switching">标签交换，Label Switching , Tag Switching</h6>
<p>标签交换：给每个分组附加一个标签，路由器收到分组后不再根据分组中的目标 IP 地址做路由选择，而是到内部表中查询标签对应的输出线路，完成路由。</p>
<p>标签交换和虚电路很相似：</p>
<ul>
<li>都需要给分组打上标签：比如 X.25、ATM、帧中继，以及所有包含虚电路子网的网络，都会给分组附上”虚电路标识符“。</li>
<li>都需要查询内部表：比如虚电路表。</li>
</ul>
<p>但标签交换这种Internet构造路由的处理方法，和虚电路这种面向连接的网络构造路由的方法，存在本质区别：</p>
<ul>
<li>标签交换发生在数据链路层，属于2层交换。虚电路交换发生在网络层，属于IP交换。</li>
</ul>
<p>另外，标签交换因为发生在2层，所以速度比虚电路快，也容易实现资源预留（这个不太理解为什么更容易）。</p>
<h6 id="mpls">MPLS</h6>
<p>IETF 对标签交换进行了标准化，称为 MPLS。</p>
<p>MPLS：Multi Protocol Label Swtiching，多协议标签交换。多协议是指支持 IPv4，IPv6，IPX等多种协议。</p>
<p>MPLS是流量工程(Traffic Engineering)和VPS的重要手段。</p>
<p>目前的通信网络中，存在两种交换节点：</p>
<ul>
<li>ATM（Asychronous Transfer Mode)异步传输模式交换机：面向连接的异步传输，信元长度固定53字节。</li>
<li>路由器：无连接传输，信源是长度可变的IP分组。</li>
</ul>
<p>ATM交换具有高效的特点，IP交换具有信令简单的优点，而MPLS交换技术就可以将两者相结合：<br>
把具有MPLS功能的IP路由器，和具有MPLS功能的ATM交换机结合起来，组建新的集成业务通信网，在新的网络中实现 IPOA（IP over ATM，即通过ATM网络来传输IP分组)。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第五章 网络层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 5.3 拥塞控制</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-5-3-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/%E7%BD%91%E5%8E%9F-5-3-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="拥塞控制congestion-control">5.3 拥塞控制，Congestion Control</h1>
<p>拥塞： 到达通信子网中某个局部的分组数量过多，路由器无法及时处理，导致该部分甚至整个网络性能下降的现象。严重时会导致通信子网出现局部或全部死锁，网络的吞吐量为0。</p>
<h6 id="吞吐量网络负荷">吞吐量、网络负荷</h6>
<p>吞吐量描述了某个设备处理数据的速度，属于性能指标。</p>
<p>网络吞吐量（throughput）：设备（链路或节点）单位时间内成功转发的比特数或分组数。 单位是 bps(bits per second)，或 pps( packets per second)。</p>
<p>系统吞吐量（或叫合计吞吐量）：整个通信子网单位时间内，合计成功转发的比特数或分组数。</p>
<p>吞吐量本质上等同于带宽消耗，可以用排队论对其做数学分析。<br>
单位时间内输入的数据量称为“到达率”，单位时间内成功输出的数据量称为“离开率”。</p>
<p>网络负荷：通信子网中正在传输的数据量（合计分组数）。</p>
<h6 id="吞吐量与负荷的关系">吞吐量与负荷的关系</h6>
<p>当负荷较小时，吞吐量随负荷的增加而线性增加。</p>
<p>当负荷到达一个临界值时，吞吐量反而会下降，此时，说明网络出现了拥塞。<br>
<img src="/2019/12/01/网原-5-3-拥塞控制/网原-5-3-拥塞控制/20190928192737672_21468.png"></p>
<h6 id="拥塞现象">拥塞现象</h6>
<p>拥塞：节点没有空闲的缓存空间，只能丢弃新到来的分组，发送方需要重传分组，通信子网的吞吐量下降的现象。</p>
<p>当分组到达节点时，因为节点的缓冲区已经用尽，分组无法暂存在节点中只能被丢弃，发送方（前节点、源节点、源主机）只能重传该分组，而且后续的多次重传仍可能没有暂存空间，此时通信子网中多个节点的CPU、缓冲区以及逻辑信道都用于这种重传，使通信子网的吞吐量大大下降。</p>
<h6 id="死锁">死锁</h6>
<p>死锁是拥塞的最后阶段。</p>
<p>死锁是网络中极容易发生的故障之一，即使在网络负荷不算重时也可能发生。</p>
<p>一组节点由于没有空闲缓冲区而无法接收和转发分组，并且它们互相等待对方节点释放缓冲区，并一直保持这一僵局，严重时导致整个网络的瘫痪。</p>
<p>Internet中的“拒绝攻击服务”，实际上就是制造大量没有完成三次握手的TCP连接，使网络拥塞直至瘫痪。</p>
<p>通常只能依靠人工重启网络，解除死锁，但重启后仍然可能再次发生死锁，不能从根本上解决问题。</p>
<h2 id="拥塞发生的原因">5.3.1 拥塞发生的原因</h2>
<p>1.线路结构：多条输入线路共用一条输出线路，当每条输入线路都有分组到达时，汇集处的路由器如果没有足够的内存来存放这些分组，有的分组就会丢失。</p>
<p>2.节点的处理能力底下：路由器的性能不足，以至于无法完成必要的处理工作（比如缓冲区排队、更新路由表等），即使内存空间足够，也来不及将分组排队放入内存中，导致分组丢失。</p>
<h6 id="拥塞控制和流控制的区别">拥塞控制和流控制的区别</h6>
<p>拥塞控制的任务：保证通信子网能够承载进入子网的流量。</p>
<p>拥塞控制是一系列系统的、全局的控制手段，涉及多个方面的行为：</p>
<ul>
<li>所有的主机</li>
<li>所有的路由器</li>
<li>路由器内部的存储-转发处理过程</li>
<li>所有可能降低子网承载能力的其他因素</li>
</ul>
<p>流控制：控制点到点的流量，确保一个发方不会持续的以超过收方消化能力的速率发送数据。</p>
<p>流控制的做法是：收方向发方提供反馈，让发方了解自身的状态。</p>
<h2 id="拥塞控制的通用原则">5.3.2 拥塞控制的通用原则</h2>
<p>拥塞控制原则的理论基础来自于控制论，拥塞控制的解决方法可以分为两类：开环和闭环。</p>
<h6 id="开环控制">开环控制</h6>
<p>设计网络时事先考虑到发生拥塞的所有因素，系统运行后就无法再中途改正。</p>
<p>开环手段包括：</p>
<ul>
<li>确定何时接收新的流量</li>
<li>确定何时丢弃分组</li>
<li>确定丢弃哪些分组</li>
<li>在网络的不同点上执行调度决策</li>
</ul>
<p>这些手段与网络的实际运行状态无关。</p>
<h6 id="闭环控制">闭环控制</h6>
<p>闭环方法依靠对网络实际状态的反馈，包括3个部分：</p>
<p>1)<strong>监视系统</strong><br>
监控何时、何地发生了拥塞。</p>
<p>可以用多种指标来判断是否发生拥塞：</p>
<ul>
<li>因没有缓冲区而被丢弃的分组，在所有分组的占比</li>
<li>所有节点的平均队列长度</li>
<li>超时、重传分组的数量</li>
<li>平均分组延迟</li>
<li>分组延迟的标准方差</li>
</ul>
<p>这些值越大，发生拥塞的可能性也越大。</p>
<p>2)<strong>将状态发送到能够采取行动的地方</strong></p>
<p>有几种方法：</p>
<ol type="1">
<li>检测到拥塞的路由器向源端（可能有多个源）发送一个分组，报告情况。</li>
<li>在分组中预留一个位或一个域，当拥塞度量超过某个阈值后，路由器填充该位/域，这个分组之后传输到邻居节点时，就可以警告邻居节点。</li>
<li>主机或某些路由器周期性的向外发送询问分组，显式的询问拥塞的情况。</li>
<li>源端利用发出分组和确认分组的来回时间，隐式的推断是否可能发生拥塞。</li>
</ol>
<ol start="3" type="1">
<li><strong>调整系统以纠正拥塞</strong></li>
</ol>
<p>出现拥塞后，两种解决办法：</p>
<ol type="1">
<li>增加资源（带宽）：有时候增加系统的资源或容量是不可能的。</li>
<li>降低负载：拒绝为某些用户服务、给某些用户降低服务等级、让用户以一种更有预见性的方式来安排他们的需求。</li>
</ol>
<h2 id="拥塞预防策略">5.3.3 拥塞预防策略</h2>
<p>以下策略只能预防拥塞。</p>
<h6 id="数据链路层">数据链路层</h6>
<ul>
<li>重传策略：涉及两个问题，1.超时时间设定为多久；2.超时后如何重传。对于第2个问题，可以用GBN和SR两种重传方法，显然，GBN带来的网络负载比SR多很多。</li>
<li>乱序分组缓存策略：如果接收方将乱序分组全部丢弃，则重传量会很大。（GBN，以及窗口很小的SR）</li>
<li>确认策略：有一种返回确认帧的方法是，不立即发回确认帧，而是先暂存在接收方，当发生反向流量时（收方-发方）捎带回去，但这样可能导致额外的超时和重传。</li>
<li>流控制方案：一个“紧凑”的流量控制方案，可以降低数据传输率，有助于缓解拥塞。紧凑是指减小窗口尺寸，比如：停止等待协议机制，滑动窗口机制。</li>
</ul>
<h6 id="网络层">网络层</h6>
<ul>
<li>虚电路还是数据报操作方式：许多拥塞控制算法只能与虚电路子网一起工作。</li>
<li>分组排队和服务策略：排队是指，是否为每条输入线路设置一个分组队列，是否为每条输出线路设置一个分组队列，或者为输入输出各设置一个队列（虚电路就是为输入输出各设置一个队列）。服务是指服务质量，虚电路在建立时就可以预留资源，这些虚电路所属的进程可以得到更好的服务。</li>
<li>分组丢弃策略：当节点的缓冲器耗尽时，应该丢弃哪些分组的规则。</li>
<li>路由算法：好的路由算法可以把流量分散到所有线路上，不好的路由算法则会将大量流量分配到已经拥塞的路线上。</li>
<li>分组生存管理：负责管理分组的生存时间，如果生存期太长，则会长时间的占用网络资源，但如果生存期太短，还未送达目的地就被丢弃了，会造成重传。</li>
</ul>
<h6 id="传输层">传输层</h6>
<p>传输层的策略和数据链路层很相似：</p>
<ul>
<li>重传策略</li>
<li>乱序缓存策略</li>
<li>确认策略</li>
<li>流控制策略</li>
<li>确定超时策略：传输层对确认超时的判断，比数据链路层更加困难，因为跨越整个通信子网的传输时间，比两台路由器之间的传输时间（数据链路层），更加难以预测。如果超时设定的太短，会导致更多的重传，增加拥塞的可能，如果设置得太长，重传会减少，但如果分组发生丢失，发现丢弃的响应时间会太长。</li>
</ul>
<h2 id="虚电路子网中的拥塞控制">5.3.4 虚电路子网中的拥塞控制</h2>
<p>有几种用于虚电路子网的动态拥塞控制方法：</p>
<h6 id="治疗措施准入控制一旦出现拥塞就不允许建立新的虚电路">1. 治疗措施：准入控制，一旦出现拥塞就不允许建立新的虚电路</h6>
<p>一旦出现拥塞，则不允许创建任何新的虚电路，直到拥塞排除为止。</p>
<h6 id="治疗措施允许建立新虚电路但要避开拥塞节点重构子网拓扑重做路由选择">2. 治疗措施：允许建立新虚电路，但要避开拥塞节点重构子网拓扑，重做路由选择</h6>
<p>即使出现拥塞，也允许建立新的虚电路，但要去掉发生拥塞的路由器，在信源和信宿间重建子网拓扑，基于新的子网拓扑进行路由选择，得到一条避开拥塞路由器的新路由。</p>
<img src="/2019/12/01/网原-5-3-拥塞控制/网原-5-3-拥塞控制/Ksugzp.png">
<h6 id="预防措施在发生拥塞之前建立虚电路时做好资源预留避免发生拥塞">3. 预防措施：在发生拥塞之前，建立虚电路时做好资源预留，避免发生拥塞</h6>
<p>在建立虚电路前，主机和通信子网之间做好约定，约定的内容包括：流量的形状（traffic shaping)、服务质量、其他参数。<br>
建立虚电路时，按照约定预留了资源（路由器的CPU、表空间、缓存空间、线路的带宽等），就不会发生拥塞。</p>
<h2 id="数据报子网中的拥塞控制">5.3.5 数据报子网中的拥塞控制</h2>
<p>数据报子网的拥塞控制方法，比虚电路子网的稍微复杂一点，但也很容易理解。</p>
<p>每台路由器都可以监视自己的“输出线路”和“其他资源”的使用情况。</p>
<p>对路由器的每一条输出线路，都可以用<strong>输出线路利用率</strong> <span class="math inline">\(u(0.0 \lt u \lt 1.0)\)</span> 描述“最近一个采样周期的线路利用率”。</p>
<p>路由器每隔<strong>采样周期 <code>a</code></strong> 就会采样<strong>线路的瞬时利用率</strong> <span class="math inline">\(f (f=0 or 1)\)</span>，根据下面的计算公式来更新<strong>输出线路利用率 <code>u</code></strong> ，使其尽可能的反映真实的情况。</p>
<p><span class="math display">\[u_{new} = a \times u_{old} + (1-a) \times f\]</span></p>
<p>采样周期 <code>a</code> 是一个常数，代表了：路由器需要多久来忘记历史线路利用率。</p>
<p>当 <code>u</code> 超过某个阈值时，说明该线路有发生拥塞的可能，路由器将该输出线路标记为“警告”状态。</p>
<p>当新的分组到达路由器时，路由器对其进行检查，如果分组流经“警告”线路，则采取以下措施：</p>
<h6 id="警告位warning-bit也称为-ecn">1.警告位,Warning Bit，也称为 ECN</h6>
<img src="/2019/12/01/网原-5-3-拥塞控制/网原-5-3-拥塞控制/VlSYTK.png">
<p>分组的头部中设置了一个特殊的二进制位：警告位。<br>
当路由器发现分组应该发送到警告线路时，在分组的警告位进行标注。</p>
<p>被标注的分组送达目标主机后，警告位被复制到确认分组中，确认分组被送回源主机。</p>
<p>源主机收到带有警告位的确认分组后，减少发往该目的主机的流量。</p>
<ul>
<li>只要输出线路的利用率高于阈值，就始终处于警告状态，被送往该线路的分组也始终被路由器设置警告位，返回源主机的确认分组也一直带有警告位。源主机根据带警告位的确认分组的比例，不断降低它的数据传输速率，<br>
</li>
<li>如果警告位确认分组占比低于某个临界值，源主机又会增加它的数据传输率。</li>
</ul>
<p>疑问：数据报子网为什么有确认分组？</p>
<h6 id="源主机响应抑制分组chock-packet楔子分组">2.源主机响应抑制分组，Chock Packet（楔子分组）</h6>
<img src="/2019/12/01/网原-5-3-拥塞控制/网原-5-3-拥塞控制/20190928234052937_28999.png">
<p>路由器检测到某条输出线路处于警告状态时，路由器会做2个动作：</p>
<ul>
<li>向源主机发送一个抑制分组：抑制分组中带有原数据分组的目标主机地址</li>
<li>在源分组头部某个二进制位进行标注：后续路由器收到这个分组时，就知道已经发回了抑制分组，不再产生更多的抑制分组</li>
</ul>
<p>源主机收到抑制分组后，会做2个动作：</p>
<ol type="1">
<li>按照设定，把发送给指定目标主机的流量减少某个百分比。</li>
<li>在收到第一个抑制分组之前，源主机可能又向该目标主机发送了若干分组，这些分组必然会生成更多的抑制分组，此时，源主机应该在一段时间内忽略掉所有同一目标的抑制分组。</li>
</ol>
<p>过了忽略时间段后，源主机再次可以接收该目标的抑制分组：</p>
<ul>
<li>如果仍然收到抑制分组，说明拥塞仍然存在，源主机再次按照某百分比减少送往该目标的数据传输率，</li>
<li>如果没有收到该目标的抑制分组，说明拥塞排除，源主机可以增加该目标的流量。</li>
</ul>
<p>Q.如何按百分比减少流量？<br>
A.源主机按百分比减小发送窗口的尺寸。</p>
<h6 id="逐跳响应抑制分组hop---by---hop">3.逐跳响应抑制分组，Hop - by - hop</h6>
<img src="/2019/12/01/网原-5-3-拥塞控制/网原-5-3-拥塞控制/20190928235357902_25718.png">
<p>源主机响应抑制分组在2种情况下效果很差：</p>
<ul>
<li>网络传输速度很高</li>
<li>源主机距离目的主机太远</li>
</ul>
<p>这2种情况下，当抑制分组到达源主机时，源主机已经发送了大量的分组到子网中，拥塞控制的响应速度太慢。</p>
<p>逐跳响应抑制分组，是让抑制分组影响到送回源主机的沿途每一个路由器：<br>
当抑制分组到达第一个路由器F时，F就必须减缓F-D的分组流，具体实现是：F为流向D的分组分配更多的缓冲区。<br>
当抑制分组到达第二个路由器E时，E就会为流向F分组分配更多的缓冲区，从而减缓E-F的流量。<br>
抑制分组到达了源节点A，A会为A-E的分组申请更多的缓冲区，将A-E的流量减缓下来。<br>
最后，抑制分组到达与A相连的HOST，从而彻底降低HOST的分组发送速度，从源头上排除拥塞。</p>
<p>疑问：数据报子网中，源节点可以为每条输出线路单独划分缓冲区？</p>
<h2 id="负载丢弃load-shedding">5.3.6 负载丢弃，Load Shedding</h2>
<p>注意：负载丢弃适用于虚电路子网和数据报子网！</p>
<p>当前述的任何一种方法都不起作用时，就只能采取负载丢弃。</p>
<p>负载丢弃：当路由器来不及处理分组时，只要将这些分组丢弃即可。</p>
<h5 id="应该丢弃哪些分组">应该丢弃哪些分组？</h5>
<h6 id="根据应用类型">根据应用类型</h6>
<p>根据发送分组的应用程序的分类，有2种丢弃分组的策略：</p>
<ul>
<li>葡萄酒策略：老的比新的好，丢弃新的分组。比如：文件传输，假设一个文件总共有12个分组，接收方要求顺序接收分组（虚电路），丢掉分组6保留7<sub>12的话，可能会导致重传分组6</sub>12，而丢弃分组10，只会导致10~12的重传。（这个例子举得不太好，将就看）</li>
<li>牛奶策略：新的比老的好，丢弃老的分组。多媒体传输，比如实时语音/视频，丢弃老的分组可能更好。 ###### 根据分组优先级 发送方的应用程序给自己的分组标注优先级。<br>
路由器丢弃分组时，从优先级低的开始丢弃。</li>
</ul>
<h6 id="随机的早期预测算法redrandom-early-detection">随机的早期预测算法，RED(Random Early Detection)</h6>
<p>RED，有多种展开法：Random Early Detection, Random Early Discard, Random Early Drop。</p>
<p>预先发现拥塞，比真的发生拥塞再来解决要好得多，RED就是基于这个思路的算法。</p>
<p>随机早期预测算法：在路由器发现分组队列缓冲区即将耗尽之前，就随机的丢弃分组。</p>
<p>平均队列长度： Average Queue Length，指数加权移动平均。</p>
<p><span class="math inline">\(Q_{avg} = (1-w) \times Q_{avg} + w \times Q_{sample} ,(0 \le w \le 1)\)</span></p>
<p><span class="math inline">\(Q_{sample}\)</span>是采样获得的实际长度。<span class="math inline">\(w\)</span> 是采样周期。</p>
<p>路由器为每一条输入线路设置了独立的分组缓冲队列，并且监控了每个队列的平均队列长度。一旦某条输入线路的平均队列长度超过了阈值，则认定它发生了拥塞（实际上此时分组缓冲尚未耗尽）。 虽然定位了拥塞队列，但无法判断哪一个源主机是引起拥塞的元凶（实际上也可能是多个源共同作用的结果），因此，路由器随机的丢弃拥塞队列中的分组。</p>
<p>即使丢弃了分组，仍然需要通知造成拥塞的源主机才能从根本上消除拥塞。通知源主机的方法有：</p>
<ol type="1">
<li>显式通知，回送抑制分组：源主机响应的、逐跳响应的。缺点：在已经拥塞的网络中引入更多的负载。</li>
<li>隐式通知，不发送抑制分组：源主机发现没有确认分组返回时，不再重发分组，而是降低发送速率。需要：给源主机设定“不重发、仅降速”的策略。</li>
</ol>
<img src="/2019/12/01/网原-5-3-拥塞控制/网原-5-3-拥塞控制/20190929120022790_13041.png">
<h2 id="抖动控制jitter-control">5.3.7 抖动控制，jitter control</h2>
<p>抖动：“分组到达路由器或信宿的传输时间”的标准差。</p>
<p>标准差（标准偏差，均方差）：所有数减去平均值，每个差值的平方和除以数的个数（或个数减一)，再把所得值开根号。<br>
标准查表示了一组数值的离散程度。</p>
<p>传输音频流/视频流时，高抖动会导致声音/电影不稳定。</p>
<h6 id="如何降低抖动">如何降低抖动？</h6>
<p>事先通过计算，可以确定分组在每一跳的期望到达时间。</p>
<p>当一个分组到达路由器时，路由器会检查实际到达时间和期望到达时间，并将检查结果标注在分组中。<br>
如果早到了就多存储一会儿，如果晚到了就优先转发出去。并在转发时更新时间差。后续路由器重复此动作。</p>
<h6 id="如果多个分组竞争同一输出线路应该先转发哪一个">如果多个分组竞争同一输出线路，应该先转发哪一个？</h6>
<p>路由器采取的算法是：与期望到达时间偏差最大最晚的那个分组，最先发出。</p>
<h6 id="接收方缓存分组">接收方缓存分组</h6>
<p>除了路由器，目的主机也可以缓存分组，通过稍微延后的播放视频消除抖动，而非实时接收分组。</p>
<p>但对于实时交互的应用，比如网络电话、视频会议，接收方缓存就无法消除抖动了。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第五章 网络层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 5.2 路由选择</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-5-2-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9/%E7%BD%91%E5%8E%9F-5-2-%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>路由选择：源节点和目的节点之间有多条传输路径，为收到的分组确定传输路径的行为。</p>
<p>路由选择是网络层的基本功能。</p>
<ul>
<li>数据报子网：进入通信子网的每个分组，始终需要每个节点为其进行路由选择。</li>
<li>虚电路子网：建立虚电路时，每个节点要为呼叫请求分组做路由选择，建立后，不再需要。</li>
</ul>
<p>路由选择包含了2个基本操作：</p>
<ol type="1">
<li>最佳路径的判定：相对2更复杂</li>
<li>网间信息包的传送（这个还不理解）</li>
</ol>
<h6 id="路由选择算法routing-algorithm">路由选择算法，Routing Algorithm</h6>
<p>路由选择算法：路由选择的策略。</p>
<p>路由选择算法需要考虑很多技术要素：</p>
<ul>
<li>选择最短路由，还是最佳路由</li>
<li>通信子网采用虚电路操作方式还是数据报操作方式</li>
<li>采用分布式路由算法，还是集中式路由算法：分布式——每个节点都参与路由，集中式——中央节点或始发节点决定路由</li>
<li>考虑网络拓扑、流量、延迟等网络信息</li>
<li>采用静态路由选择，还是动态路由选择</li>
</ul>
<h2 id="最优化原则optimality-principle">5.2.1 最优化原则，Optimality Principle</h2>
<h6 id="最优化原则">最优化原则</h6>
<p>假设：节点 I 和节点 K 之间的若干条路由中，存在一条最佳路由“I - K”，"I - K"又经过了节点 J，那么其中的“ J - K”部分，也是节点 J 到节点 K 的若干条路由中的最佳路由。</p>
<h6 id="汇集树sink-tree">汇集树，Sink Tree</h6>
<p>根据最优化原则，可以推导出汇集树。</p>
<p>汇集树：目的节点作为根，网络中任一节点到该目的节点的最佳路由，组成的一棵树。</p>
<p>一个目的节点的汇集树并不唯一！</p>
<p>路由选择算法的目的：为所有节点找到汇集树。</p>
<h6 id="汇集树的理论优势以及实际应用">汇集树的理论优势，以及实际应用</h6>
<p>理论上讲：<br>
汇集树是一棵树，其拓扑结构没有循环，因此分组沿汇集树传输必定在有限站数内到达目的节点，而且还是最佳路由。</p>
<p>但实际运行情况特别复杂：</p>
<ul>
<li>链路经常被切断；</li>
<li>路由器（节点）经常停止工作后又恢复工作；</li>
</ul>
<p>不同节点对子网的拓扑结构的理解不同。</p>
<ul>
<li>不同的节点获取子网信息和汇集树信息的方法不同</li>
</ul>
<p>最终，不同的节点对整个子网生成的汇集树可能差异很大。</p>
<h2 id="静态路由选择算法">5.2.2 静态路由选择算法</h2>
<p>静态路由选择算法：不需要测量，不依靠网络的实时状态信息，由网管按照某种规则，手工建立映射表。</p>
<p>20世纪90年代以来，大多数优秀的路由选择算法都是动态的，但静态路由选择算法仍然有意义：<br>
它能够为一些无法选择路由的数据包指定目标路由器，将其转发过去，弥补了动态路由选择算法的某些不足。</p>
<h3 id="最短路由选择算法shortest-routing利用已知的静态距离">1. 最短路由选择算法，Shortest Routing（利用已知的静态”距离“）</h3>
<p>最短路由算法简单易懂、应用广泛。</p>
<p>最短路由选择算法的基本思想： 用子网图描述拓扑结构，每个节点代表路由器，弧线代表链路，弧线上的数字是链路的权重（这里可以理解为长度）。要为一对节点选择一条路由，只需找到它们之间权重和最小的路径即可(可以理解为最短路径)。</p>
<p>链路的权重，在现实世界可能有多种含义：</p>
<ul>
<li>站点数量</li>
<li>物理距离</li>
<li>信道带宽</li>
<li>平均通信量</li>
<li>通信开销</li>
<li>队列长度</li>
<li>传播时延</li>
</ul>
<h4 id="dijkstra算法迪杰斯特拉算法">Dijkstra算法，迪杰斯特拉算法</h4>
<p><strong>勘误</strong> 原文：<br>
&gt;检查与B相邻的所有节点。如果B的标注与从B到所<strong>有</strong>检查的节点距离之和小于此节点的标注，就重新标注这个节点。”</p>
<p>正确的应该是：<br>
&gt;检查与B相邻的所有节点。如果B的标注与从B到所检查的节点距离之和小于此节点的标注，就重新标注这个节点。”</p>
<p>断句如下：<br>
检查与B相邻的所有节点。如果（B的标注）+（从B到所检查节点的距离）&lt; 所检查节点的初始标注（原标注），就以到B的距离重新标注这个节点。 每个节点都有一个标注值，代表了”从源节点沿着最佳路径到该节点”的权值（通常是距离）。</p>
<h6 id="dijkstra算法的步骤">Dijkstra算法的步骤</h6>
<p>根据源节点到“被检查节点”之间的距离（即链路的权重值），对“所检查节点”进行标注。</p>
<p>标注分为暂时性的（空心圆点），和永久性的（实心圆点）——当发现该标注代表了：从源节点到该节点的最短路径时。被设定为永久性标注的节点会作为新的源节点。</p>
<p>最开始时，不存在任何一条最佳路径，将除源节点外的所有节点都标注为无穷大（暂时性的）。</p>
<p>随着“从源节点到其他节点”的最佳路径的不断发现，代表最短路径的节点标注也不断的从暂时性修改为永久性的。</p>
<p>以书上的图为例，源节点为A，目的节点为D，中间节点若干。</p>
<ol type="1">
<li>将源节点A设为工作节点，标注为永久性的——实心圆点</li>
<li>用权值（例中为距离）标注“与A相邻的每一个节点”，标注时除了写明节点的权值，还应该注明源节点，比如 B(2,A)</li>
<li>检查完A以后，在已经标注的A相邻节点中，寻找标注最小的点（示例中为B），将其修改为永久标注，并作为新的工作点。</li>
<li>检查与B相邻的所有节点（A不用检查了，A已经是永久节点了），如果：<span class="math inline">\(B的标注 + 从B到所检查点的距离 \lt 所检查点的标注\)</span>，那么：应该修改所检查点的标注=从B到所检查点的距离</li>
</ol>
<p>在示例中，B的标注=2，从B到E的距离=4 ，E的标注=无穷，因此应该将E的标注修改为（4,B）</p>
<ol start="5" type="1">
<li>寻找与B相邻的所有节点中，标注最小的，将其设为永久性，并作为新的工作点。</li>
</ol>
<h6 id="值得一说的是-图5-3-d-和-图5-3-e">值得一说的是： 图5-3 d 和 图5-3 e</h6>
<p>G点在第一次和A的检查中，被标注为G(6,A）——图b</p>
<p>图d中，以E(4,B)为新的工作点，标注出 F(6,E) G(5,E)。</p>
<p>因为 E(4 + G(5 &lt; G(6 ，因此应该重新标注G点，由此得到 G(5,E)!</p>
<h3 id="扩散法flooding不需要测量依靠固定规则">2. 扩散法，Flooding（不需要测量，依靠固定规则）</h3>
<p>扩散法，又叫“泛射路由选择法”、“洪泛法”，是最简单的静态路由选择算法。</p>
<p>源节点发出一个分组，子网中的某个节点收到该分组后，向“除来路外的所有链路”发送该分组（每经过一个节点，就会复制出新的分组，分组数量等于“节点相连的链路数-1”），最先到达目的节点的分组必定走过了最短的路径。而且，所有到达目的节点的分组所经路径的集合，就是所有可能的路径。</p>
<p>扩散法存在一个严重的问题：产生大量的重复分组，甚至无穷个分组。</p>
<h6 id="解决重复分组的办法">解决重复分组的办法</h6>
<p><strong>1. 让分组携带站计数器</strong> 节点在转发分组前，会将其站计数器 - 1，对做减法后“站计数器=0”的分组，节点将其丢弃不再转发。</p>
<p>Q.如何设置站计数器的初值呢？<br>
A.理想的情况：站计数器初值=源节点到目的节点的路径长度（站数量）。<br>
实际上很多时候不知道路径长度，可以把站计数器初值设置成“子网直径（即网络中最大链路段数）”。</p>
<p>子网直径：从任一源节点到任一目的节点的最大中间链路段数。</p>
<p><strong>2. 在节点记录分组，避免重复</strong> 基本思想：记录下分组传输的路径，避免分组被扩散进历史路径。</p>
<p>通信子网中，与主机相连的节点，称为“源端节点”，其余称为“非源端节点”。<br>
每个非源端节点，对应每个源端节点都有一张记录表。</p>
<p>主机向源端节点发送多个分组，源节点赋予每个分组一个序号，再扩散出去。</p>
<p>非源端节点每次收到分组时，会在“相应的源端节点记录表”中记下分组序号，得到“源端节点：序号”这样一个表项。 据此，可以判断收到的分组是不是重复分组，如果是就丢弃，从而避免了再次扩散。</p>
<p>因此每收到一个分组就要写入表中，源端节点记录表会不断增长，为控制表的长度，加入一个计数器 K ，表示K的序号已经看到。序号小于K的分组为复制品，不再存放。（但这里有点儿问题，数据报并非按序到达，序号小于K的分组可能在后续到达吧，不理解这里的K是什么意思）。</p>
<h6 id="扩散法的应用">扩散法的应用</h6>
<p>扩散法很少被实际应用，但也有它特定的用途：</p>
<ul>
<li>对强壮性要求很高的网络：军事网络，网络的拓扑结构可能被破坏</li>
<li>广播式数据交换：无线网络、分布式数据库应用——同步更新所有数据库</li>
<li>寻找网络的最短路径、最小传输延迟</li>
</ul>
<h4 id="选择扩散法selective-flooding">选择扩散法（Selective Flooding）</h4>
<p>选择扩散法是扩散法的改进版，节点不会把分组向每一条非来路链路发送，而只向与目标方向接近的那些链路发送（也会复制出多个分组）。</p>
<h3 id="基于流量的路由选择flow-based-routing">3. 基于流量的路由选择，Flow-based Routing</h3>
<p>网络负载：单位时间内流经设备（单一节点、多个节点、通信链路、通信子网）的数据量，单位 bps。</p>
<p>最短路径路由选择算法和扩散法，只考虑了网络的拓扑结构，没有考虑网络负载。</p>
<p>在一些网络中，节点间的平均流量是相对稳定的或可预测的。进行静态路由选择时，完全可以把网络负载考虑进去。</p>
<p>基于流量的静态路由选择算法，兼顾了拓扑结构和网络负载。</p>
<p>基于流量的路由选择法的基本思想：<br>
如果已知某条线路的负载和平均流量，就可以根据排队论计算出它的平均分组延迟。根据所有线路的平均分组延迟，可计算出流量的加权平均值，从而得到整个网络的平均分组延迟。（不懂排队论，这里并不真正的理解），具有最小平均延迟的线路（负载和节点处理能力匹配较好）自然是最佳线路。</p>
<p>至此，基于流量的路由选择问题，转化为：“寻找最小平均延迟线路”的路由选择算法。</p>
<p>P.S. 分组延迟：分组进入路由器后，先在缓冲区中排队，节点处理后再转发出去，这段时间称为延迟。</p>
<p>运用此方法的前提：</p>
<ul>
<li>拓扑结构已知</li>
<li>通信量矩阵、线路容量矩阵已知</li>
</ul>
<h2 id="动态路由选择算法">5.2.3 动态路由选择算法</h2>
<p>因为静态路由选择算法不考虑网络的实时状态，因此实际运用中，动态路由选择算法才是主流。</p>
<p>动态路由选择算法：根据网络的实时状态进行路由选择的算法，也称为自适应路由选择算法。</p>
<ul>
<li>优点：能适应网络流量、拓扑结构的变化，有助于改善网络性能。</li>
<li>缺点：算法复杂，会增加网络的负担，开销大。</li>
</ul>
<h3 id="距离矢量路由算法">1. 距离矢量路由算法</h3>
<p>每个路由器都保存、维护了一张路由表（即矢量），其中记录了3个要素：</p>
<ul>
<li>当前已知的所有路由器（包括自身）：作为目标路由表，这些路由器也是路由表的索引。“当前已知”表明子网中的路由器存在动态变化</li>
<li>从自身出发，“到达目标路由器的最佳线路”所要经过的相邻路由器</li>
<li>从自身出发，通过最佳线路到达相邻路由器的“距离”</li>
</ul>
<p>路由表的更新，是通过与相邻路由器的不断的信息交换来实现的。</p>
<p>工作步骤：<br>
假设：以“延迟”作为距离的度量标准，路由器A 具有3个邻居：XYZ，A知道它到XYZ的延迟。每隔T毫秒：</p>
<ul>
<li>路由器A就向它的每个邻居发送一个列表（列表不是路由表），其中记录了从A到子网中任一路由器i（目标路由器）的延迟估计值 <span class="math inline">\(A_{i}\)</span>。<br>
</li>
<li>同时，XYZ也向A发送它们自己的列表。 X 向 A 发送的一个列表中的一个表项显示：从 X 到目标路由器 i 的延迟估计值为 <span class="math inline">\(X_i\)</span> 毫秒。<br>
如果 A 到 X 的延迟是 <span class="math inline">\(X_{A}\)</span>，可以得知：从 A 经过 X 到达目标路由器 i 的延迟估计值最大为 <span class="math inline">\(X_{i} + X_{A}\)</span> 毫秒。 A 从 XYZ 都收到各自的列表，最终通过从 <span class="math inline">\(X_{i}+X_{A}\)</span>、<span class="math inline">\(Y_{i}+Y_{A}\)</span>、<span class="math inline">\(Z_{i}+Z_{A}\)</span> 取最小值，作为从 A 到目标路由器 i 的延迟估计值<span class="math inline">\(A_{i}\)</span>，写入 A 的路由表中。</li>
</ul>
<p>在下一次的 T 毫秒间隔后，路由器A 将更新后的 <span class="math inline">\(A_{i}\)</span>发送给XYZ，供它们计算、更新自己到目标路由器 i 的路由表。</p>
<p>说明：<br>
如果 <span class="math inline">\(X_i\)</span> 是 X 经过 A 到达 i 的延迟估计值，那么 A 到 i 的延迟估计值应该为 <span class="math inline">\(X_{i} - X_{A}\)</span> ，此时从 A 经过 X 到达目标路由器 i 的延迟估计值为 <span class="math inline">\(X_{i} - X_{A} + 2\cdot X_{A} = X_{i}+X_{A}\)</span>。</p>
<p>早期的ARPANET，和因特网的 RIP 路由信息协议，都使用了“距离矢量路由算法”。</p>
<h3 id="链路状态路由算法link-state-routing">2. 链路状态路由算法，Link State Routing</h3>
<p>1979年以前，ARPANET一直使用距离矢量路由算法，之后，采用了链路状态路由算法。</p>
<p>至今，链路状态路由算法是主流的动态路由选择算法。比如广泛应用的开放式最短路径优先协议OSPF(Open Shortest Path First)，就采用了链路状态路由算法。</p>
<h6 id="第一步.发现邻居节点">第一步.发现邻居节点</h6>
<p>每个路由器向连接自身的每一条点到点线路，发送一个特殊的HELLO分组，线路另一端的路由器回送一个包含它唯一名称等信息的应答信息。</p>
<p>路由器记录下应答信息即建立了邻居节点的数据库。</p>
<h6 id="第二步.测量线路开销延迟">第二步.测量线路开销（延迟）</h6>
<p>路由器在线路上发送一个特殊的ECHO分组，另一端立即回送一个应答，将这个时间除以2，发送方路由器就记录下这个延迟的估计值。</p>
<h6 id="第三步.创建链路状态分组">第三步.创建链路状态分组</h6>
<p>根据前两步收集到的数据，路由器就可以创建出“链路状态分组”，分组包含了：</p>
<ul>
<li>发送方的标识：发出分组的源路由器的唯一名称，比如A</li>
<li>链路状态分组的序列号：源路由器每次收集到新的邻居节点、线路开销，都会生成新的链路状态分组，第一个的序号为1，以此类推，从而进行区别。</li>
<li>年龄：这个不知道是什么</li>
<li>邻居列表、自身到邻居的延迟</li>
</ul>
<h6 id="第四步.发布链路状态分组">第四步.发布链路状态分组</h6>
<p>源路由器生成了链路状态分组后，就需要用扩散法将其发布到子网中。</p>
<p>每个路由器在收到链路状态分组后，会在一个表中记录下源路由器和序列号，当扩散产生的重复分组再次到达路由器时，通过查询记录表会发现它是重复分组，从而将其丢弃。<br>
而且，序列号还有记录分组产生时间的作用：如果一个路由器已经收到了某源路由器产生的序号为 k 的分组，随后又收到了同一源路由器序号为 j 的分组，j&lt;k ，那么可以直接将其丢弃，因为 j 所记录的链路状态已经过时了。</p>
<h6 id="第五步.计算新的路由">第五步.计算新的路由</h6>
<p>如果一个路由器，已经在扩散法的影响下，收到了子网中所有路由器产生的链路状态分组，那么就可以构造出完整的子网图（包括拓扑结构、线路开销等信息）。</p>
<p>此时，在自身节点上运用最短路由选择算法（比如Dijkstra算法），就可以生成自身的路由表。<br>
最终，每一个路由器都生成了自己的路由表，网络开始正常工作。</p>
<h2 id="移动主机的路由选择">5.2.4 移动主机的路由选择</h2>
<p>固定主机：物理位置几乎永远固定的主机，通常具有永久性的地址。</p>
<p>迁移主机：经常从一个固定位置迁移到另一个固定位置，移动中与网络断开，到达位置后才接入网络。</p>
<p>漫游主机(Mobile Host)：有原始接入点（路由器）、可以随时移动，移动中也利用网络传输数据的主机。或者说，离开了原始站点还继续连接网络的主机。通常具有变化的地址。</p>
<p>移动主机只是网络中的一部分，仍然还有很多固定主机。<br>
对这些包含移动主机的网络来说，移动主机的路由算法的目标是：<br>
能够在“地址不变的固定主机”和“地址可变的移动主机”之间进行路由选择，将分组正确的送达。</p>
<p>移动式主机的出现，引出了一个问题：</p>
<h6 id="网络如何找到移动主机或者说如何把移动主机接入网络">网络如何找到移动主机，或者说，如何把移动主机接入网络</h6>
<p>假设有一个网络系统，若干的LAN、MAN、无线蜂窝单元，通过一个WAN（内含路由器和主机）连接在一起。这些LAN、无线蜂窝单元称为“区域”。</p>
<p>每个区域中，有两种代理：</p>
<ol type="1">
<li>一个主代理：管理属于本区域，但此时移动到其他区域的移动主机。</li>
<li>一个或多个外地代理：管理不属于本区域但来到该区域的移动主机。</li>
</ol>
<p>一个移动用户进入其他区域时，以有线或无线的方式接入网络时，必须在该区域的外地代理中进行登记，称为登录。</p>
<p>登录过程：</p>
<ol type="1">
<li>外地代理定期向区域广播一个分组，告知各主机自己的地址等信息，新来的移动主机可以被动等待这个消息。移动主机也可以广播一个分组，主动询问外地代理的信息。</li>
<li>与外地代理联系上以后，移动主机需要提供：原区域的信息（比如在原区域的地址）、当前数据链路层地址（类似于物理地址）、一些安全性信息</li>
<li>外地代理与移动主机所属的原区域的主代理联系，核实移动主机是否真的来自那里。</li>
<li>外地代理从主代理得到确认后，在它的记录表中增加一项，并通知移动主机登录成功</li>
</ol>
<p>至此，就完成了移动主机接入其他区域的工作。</p>
<p>当用户离开其他区域时，应该告知外地代理注销自己，但大多数情况下都不是这样。</p>
<p>发给移动主机的分组，会先被原区域的主代理收到，然后它再转发给移动主机，如果此时移动主机已经移动到其他区域，那么主代理会查找移动主机的新位置，找到目前登录的外地代理。之后，主代理会做2件事：</p>
<ol type="1">
<li>将发给移动主机的分组，装入一个外地分组的有效载荷中（用外地代理地址再次封装了一个分组），再将该外地分组发给外地代理。</li>
<li>告诉发送者，将分组装入外地分组的有效载荷字段，直接发往外地代理所在的地址。</li>
</ol>
<p>外地代理最终会把分组转发给移动主机。</p>
<h2 id="广播路由选择-broadcasting">5.2.5 广播路由选择 , Broadcasting</h2>
<p>广播：给子网中所有的路由器发送分组。</p>
<p>实现广播路由的方法有几种。</p>
<h6 id="逐个发送最笨的办法">1. 逐个发送，最笨的办法</h6>
<p>源节点向每个节点依次发送分组，实现广播。</p>
<p>缺点：</p>
<ul>
<li>浪费带宽：节点可能会共享链路，而这种方法重复使用了链路</li>
<li>源节点必须知道所有目标节点的地址</li>
</ul>
<h6 id="扩散法">2. 扩散法</h6>
<p>扩散法不适合点对点的通信，但很适合广播式通信。</p>
<p>扩散法的缺点：产生大量重复分组，浪费带宽。</p>
<h6 id="多目标路由multi-destination-routing">3. 多目标路由，Multi-destination Routing</h6>
<p>发出的每个分组，或者包含了多个目标地址，或者包含了一个指示了目标节点的位图(bitmap)。</p>
<p>当路由器收到一个多目标分组时，会计算出所有的“必要的输出线路”（必要线路：到达至少一个目标节点的最佳线路）。</p>
<p>假设计算出3条必要线路：甲乙丙，甲通向目标 i，乙通向目标 j 和目标 k，丙通向目标 l 和目标 m 目标 n 。<br>
路由器会为每一条必要线路生成原分组的副本，但仅包含了“该条线路所连接目标的地址”：</p>
<ul>
<li>线路甲的分组副本 P1：仅包含了地址 i</li>
<li>线路乙的分组副本 P2：仅包含了地址 j k</li>
<li>线路丙的分组副本 P3：仅包含了地址 l m n 。</li>
</ul>
<p>这样，原分组中的目标集合被分散到了各必要线路上。多目标分组每经历一个节点的拆解后，最终只包含一个目标，就和普通分组没有区别了。</p>
<blockquote>
<p>多目标路由方法就如同单个地址的分组一样，只不过当多个分组必须沿着同样的路径被转发的时候，其中一个分组承担全部的费用，而其他的分组都是免费搭乘的。</p>
</blockquote>
<p>这段话不理解，多目标分组是在一个分组内包含了多个目标地址，这和多个分组都需要经过一段链路有什么关系呢(不论它们最终的目标是否相同）？所以感觉这段话没有意义。</p>
<h6 id="显式利用以广播源节点为根的生成树">4. 显式利用：以“广播源”节点为根的生成树</h6>
<p>生成树 (Spanning Tree) 是子网的子集，由：所有的路由器 + 不构成环的部分链路（没有循环）所构成。</p>
<p>P.S. 生成树包括了汇集树。</p>
<p>每个路由器都知道自己的哪些链路属于“以广播源为根的生成树”，当广播分组到来时，它就将其复制并发送到“生成树中除来路以外的”所有链路中。</p>
<p>注意：</p>
<ol type="1">
<li>以广播源节点为根的生成树并不唯一，但在这里不影响，只要找出一个就行了</li>
<li>所有的路由器都必须使用以广播源节点为根的同一棵树！否则会出问题</li>
</ol>
<p>优点：1. 最佳的利用了带宽（涉及的线路必要又不多余）； 2. 复制出了最少的分组。（最优化原则）</p>
<p>缺点：子网中的每个路由器都必须知道：以广播源为根的同一棵生成树，这就要求每个节点必须获取整个网络的状态信息——比如采用链路状态路由算法。如果采用了距离矢量路由算法，则无法获取生成树信息。</p>
<h6 id="逆向路径转发reverse-path-forwarding">5. 逆向路径转发，Reverse Path Forwarding</h6>
<p>如果路由器不知道生成树的信息，根据“广播分组的来路”是否是“当前路由与源节点的首选链路”，也可以实现“利用以广播源为根的生成树方法”近似的效果。</p>
<p>基本思想：<br>
当一个广播分组到达某个路由器时，路由器对分组的来路进行检查：</p>
<ul>
<li>如果来路是当前路由器向源节点发送分组的首选线路：说明广播分组是沿着最佳路径过来的，是到达当前路由器的第一份副本（最佳路径必然最先到达）。</li>
<li>如果来路不是当前路由器向源节点发送分组的首选线路：该分组属于非最佳路径的其他节点生成的重复分组，应该丢弃。</li>
</ul>
<p>具体操作不再描述，其实就是根据生成树来判断分组是否重复。</p>
<p>优点：不需要路由器都知道生成树（只需要知道与源节点的最短路径即可），也不需要分组中携带多个目标地址或位图，也不需要扩散法中对重复分组的控制。因此它效率相对合理，容易实现。</p>
<h2 id="多播路由选择">5.2.6 多播路由选择</h2>
<h6 id="什么叫多播和广播的区别">什么叫多播，和广播的区别</h6>
<p>多点播送，简称多播，又称组播，Multicasting。</p>
<p>分布在各主机的进程，以组的方式协同工作。<br>
组中的进程经常需要给组中其他所有的成员发送信息。</p>
<p>P.S. 组实际容纳的是进程，而非主机！多个进程可以共存于一台主机中，也可以分散在多个主机中。</p>
<p>如果组的规模比较小，那么可以用点对点的方式每个其他成员发送信息。</p>
<p>如果组的规模比较大，那么就不能逐个点对点的发送了，可以采用广播，但可能产生一些问题，比如：</p>
<ul>
<li>组的成员数量虽然多，但相对整个网络却很小，大多数节点对该分组没有兴趣：组有1000台主机，网络有100万个节点</li>
<li>组内的信息不应该让整个网络的节点看到</li>
</ul>
<h6 id="多播路由选择-1">多播路由选择</h6>
<p>适用于多播的路由算法，称为多播路由选择 Multicast Routing。</p>
<p>多播传输需要对组进行管理：</p>
<ul>
<li>需要创建、销毁组的方法</li>
<li>允许进程加入、离开组</li>
</ul>
<p>对于主机来所，自己是否有进程加入了某个组，需要由进程来告知它。</p>
<p>对于路由器，它连接的哪些主机属于哪个组时需要明确的。</p>
<p>当主机和组的从属关系发生变化时，要么是主机告诉路由器，要么是路由器定期询问自己连接的主机。</p>
<p>路由器获取到自己的主机属于哪些组后，将其告知邻居（类似于链路状态分组）。</p>
<h6 id="如何实现多播">如何实现多播</h6>
<p>子网中的每个路由器，都需要生成一棵以自己为根的生成树。</p>
<p>当某个主机中的某个进程向自己所在的组发送多播分组时，与主机相连的第一个路由器就检查以自己为根的生成树，把该树中“不通向该组其他成员主机的路由器”的链路修剪掉，得到一棵只通向同一组的成员主机的生成树。多播分组最终沿着修剪后的生成树传播。</p>
<p>修剪链路的工作，应该从每条路径的末端开始，逐步向根节点前进，去掉所有不属于改组的路由器。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第五章 网络层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 5.1 通信子网的操作方式和网络层提供的服务</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-5-1-%E9%80%9A%E4%BF%A1%E5%AD%90%E7%BD%91%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1/%E7%BD%91%E5%8E%9F-5-1-%E9%80%9A%E4%BF%A1%E5%AD%90%E7%BD%91%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>网络层是OSI参考模型的第3层，高于数据链路层，低于传输层。</p>
<p>数据链路层提供了相邻节点间利用帧传输数据的能力。<br>
网络层在此基础上，进一步管理网络通信，将数据从信源经过若干个节点传输到信宿，向传输层提供了最基本的点到点 <del>端到端</del> 的数据传输服务。</p>
<p>端到端，有2种理解：</p>
<ol type="1">
<li>源端-目的端：比如上文中“网络层提供了端到端的数据传输服务”。</li>
<li>源主机的某端口-目的主机的某端口：专用于传输层。</li>
</ol>
<p>网络层还控制了通信子网的运行，影响了资源子网访问通信子网的方式。</p>
<p>网络层是通信子网（物理层、数据链路层、网络层）中最复杂最关键的一层。</p>
<p>网络层的目的：<br>
实现信源和信宿之间，数据的透明传输。<br>
（换句话说，有了网络层，信源和信宿就不需要关心数据是如何传输的）。</p>
<p>网络层的具体功能包括：</p>
<ul>
<li>路由选择</li>
<li>拥塞控制</li>
<li>网际互连</li>
</ul>
<h1 id="通信子网的操作方式和网络层提供的服务">5.1 通信子网的操作方式和网络层提供的服务</h1>
<p>通信子网的职责：向资源子网（端系统，即信源/信宿）提供网络服务。</p>
<p>在OSI参考模型中，网络层是网络节点（通信子网）的最高层，“提供网络服务”的职责必然就落在在网络层（根据“低层向高层提供服务”的原则）。</p>
<p>如果通信子网采用分组交换方式，网络节点可以向端系统提供 2 种网络服务：</p>
<ol type="1">
<li>面向连接的服务（虚电路）</li>
<li>无连接服务（数据报）</li>
</ol>
<p>通信子网内部有虚电路和数据报两种操作方式（运行方式）。</p>
<p>服务和操作方式没有联系，任何一种操作方式都可以实现面向连接服务和无连接服务。</p>
<h2 id="虚电路操作方式">5.1.1 虚电路操作方式</h2>
<h6 id="虚电路">虚电路</h6>
<p>数据传输前，在源节点和目的节点（包括端系统）间的物理信道中，先建立一条用于传输分组的逻辑通路，这条逻辑通路称为“虚电路”。</p>
<p>物理信道复用：<br>
一条物理信道中可能存在多条虚电路，这些虚电路可能属于同一对信源信宿（不同的进程建立了不同的虚电路），也可能属于不同的信源信宿（不同的端系统的进程，建立的不同的虚电路）。</p>
<p>注意：<br>
<em>虚电路并非是信源-信宿的逻辑通路，而是信源和信宿间<strong>进程级</strong>的逻辑通路。</em></p>
<p>两个端系统之间，可以有多条虚电路为不同的进程服务。<br>
这些虚电路的实际物理路径可能相同，也可能不同，我认为这取决于物理信道能够划分出多少个虚电路吧。</p>
<h6 id="物理信道复用">物理信道复用</h6>
<p>频分多路复用 FDM 适用于模拟信号。<br>
时分多路复用 TDM，既适合模拟信号，也适用于数字信号。</p>
<p>对于分组交换方式，显然应采用时分多路复用 TDM。</p>
<p>物理信道是如何划分为多条逻辑信道的？<br>
每一段物理信道的起始网络节点内部，都有一组“分组缓冲器”（packet buffer），每个缓冲器的编号称为“逻辑信道号”（也称为虚电路号，VC号）。<br>
在该段物理信道上建立虚电路时，网络节点会为虚电路分配某个缓冲器以转发分组，这个过程也称为“虚电路获取逻辑信道号”。<br>
最终通过异步时分复用（动态划分时间片），实现物理信道复用。</p>
<h6 id="虚电路表">虚电路表</h6>
<p>虚电路可能会经过多个网络节点，在每段物理信道上都可能获取到不同的逻辑信道号。</p>
<p>分组到达某个网络节点时，携带了虚电路号（VC号），节点必须根据虚电路号，从某种表格中查出下一节点的名称和下一节点为虚电路分配的逻辑信道号，才能完成转发工作（虚电路的工作原理后文讲述）。<br>
这个表格就是“虚电路表”。</p>
<p>虚电路表记录了：</p>
<ul>
<li>每条虚电路的“来路”：前节点名称、前节点为虚电路分配的逻辑信道号</li>
<li>每条虚电路的“出路”：后节点名称、后节点为虚电路分配的逻辑信道号</li>
</ul>
<h6 id="虚电路分组交换如何工作">虚电路分组交换如何工作</h6>
<p>分组携带“出路”信息到达下一节点，节点将其作为“来路”查询虚电路表，从而确定：</p>
<ul>
<li>后节点名称</li>
<li>后节点为其分配的逻辑信道号。</li>
</ul>
<p>然后用“后节点逻辑信道号”，替换掉“前节点逻辑信道号”，再发给后节点。</p>
<p>后续节点重复上述操作。</p>
<h6 id="虚电路表的建立">虚电路表的建立</h6>
<ol type="1">
<li>自考教材上的虚电路节点名称有错误。②1-ABC应该是“②1-ACD”。</li>
<li>下图中的 H 指 HOST（端系统，信源/信宿）</li>
<li>HOST同样需要给分组分配逻辑信道号，H 0 表示端系统为虚电路分配了逻辑信道号 0。</li>
<li>建立虚电路时，节点采用和数据报传输一样的方式，通过各节点的路由能力，为呼叫请求分组寻找虚电路路径。</li>
</ol>
<img src="/2019/12/01/网原-5-1-通信子网的操作方式和网络层提供的服务/网原-5-1-通信子网的操作方式和网络层提供的服务/20190915015048716_2265.jpg">
<p>虚电路表是在建立虚电路时构建起来的。</p>
<p>假设有一条虚电路：信源H--A--B--C--D--信宿 H</p>
<p>建立虚电路时，信源发出一个“呼叫请求分组”，其中包含了：</p>
<ul>
<li>信宿的地址</li>
<li>信源为其分配的逻辑信道号<span class="math inline">\(N_{src}\)</span>。</li>
</ul>
<p>节点收到呼叫请求分组后，会在“和后节点之间的物理信道的”分组缓冲器中，分配一个<strong>未使用的、最小的</strong> 逻辑信道号 <span class="math inline">\(N_A\)</span>。<br>
然后将呼叫请求分组中“信宿分配的逻辑信道号 <span class="math inline">\(N_{src}\)</span>” ，替换成 <span class="math inline">\(N_A\)</span>，发给后节点。</p>
<p>此时，节点A中就生成了有关来路、出路信息的虚电路表。</p>
<p>需要注意的是：</p>
<ol type="1">
<li>分组缓冲器与物理信道有关。</li>
</ol>
<p>比如：<br>
A-B 和 A-C 是两段物理信道，在A节点内部就有 A-B的分组缓冲器 和 A-C的分组缓冲器。<br>
如果在A-B上要建立两条虚电路，那么就会有 A0-B(x), A1-B(x)。<br>
A-C只建立一条虚电路，就有 A0-C(x)。</p>
<ol start="2" type="1">
<li>虚电路上分组可以双向传输，由此引出一个问题：<br>
节点为新的虚电路分配逻辑信道号时，还需要考虑：不要与“该段物理信道正反两个方向已分配的逻辑信道号”相重复。</li>
</ol>
<p>记住一个原则：虚电路只能是进程对独占的，无法共享。</p>
<p>比如：<br>
存在虚电路 ABCD，虚电路A-B占用A0,B0，此时有两个方向都可以传输分组：A0-B0, B0-A0。<br>
如果再建立新的虚电路 BAC，B-A必然复用 A-B的物理信道，此时如果还为其分配 B0-A0就会和虚电路ABCD混淆（虚电路是进程独占的），因此，应该使用逻辑信道号B1- A1。</p>
<p>说明：逻辑信道号与虚电路建立的先后顺序有关。</p>
<p>教材解析：<br>
&gt;这里假设建立了6条虚电路。由于虚电路上的数据是双向传输的，为保证两节点之间正、反两个方向的虚电路不相混淆，在一个节点选取虚电路号来替换其前一节点使用的虚电路号时，不仅要考虑与下一节点之间的虚电路号不相同，还要考虑与下一节点作为另一条反向虚电路的上一节点时所选取的虚电路号相区别。</p>
<p>”不仅要考虑与下一节点之间的虚电路号不相同“，意思是说：该物理信道上已经存在虚电路，所以不能重复。</p>
<h6 id="拆除虚电路">拆除虚电路</h6>
<p>虚电路表、逻辑信道号都是网络资源，当虚电路拆除时必须释放。<br>
信源或信宿都可以发出一个拆除请求分组，各节点收到后就删除虚电路表中的对应项。</p>
<h2 id="数据报操作方式">5.1.2 数据报操作方式</h2>
<p>数据报：就是分组，在数据报操作方式中分组被称为“数据报”。</p>
<p>信源把报文分割成多个数据报，依次发送给与信源相连的网络节点。</p>
<p>每个数据报携带了：</p>
<ul>
<li>分组序号</li>
<li>信宿的地址</li>
</ul>
<p>通信子网中的网络节点收到分组后，根据分组中的地址信息、自身保存的路由信息、网络的实时流量、故障信息，独立决策，寻找下一个节点，并将分组发送出去。</p>
<p>同一报文的不同数据报，在网络中的路径可能不同。各数据报到达信宿的先后顺序也不同，还可能在中途丢失。</p>
<h2 id="虚电路服务">5.1.3 虚电路服务</h2>
<p>虚电路服务：网络层向传输层提供的一种数据传送方式。<br>
一种使分组“顺序到达”目的端系统的、可靠的（面向连接的）数据传送方式。</p>
<p>虚电路服务，也是通信子网向端系统提供的服务。</p>
<h6 id="建立虚电路的步骤">建立虚电路的步骤</h6>
<ul>
<li><p>在源端：</p>
<ol type="1">
<li>信源的传输层，向网络层发出“连接请求”</li>
<li>网络层，向与“端系统相连的网络节点”发出“呼叫分组”</li>
</ol></li>
<li><p>在通信子网中</p>
<ol type="1">
<li>节点之间传送“呼叫分组”，建立虚电路表</li>
</ol></li>
<li><p>在目的端</p>
<ol type="1">
<li>网络节点，向网络层传送“呼叫分组”</li>
<li>网络层，向传输层发出“连接指示”</li>
<li>传输层，向源端返回“连接响应”。</li>
</ol>
<p>如果以上步骤都成功，虚电路就建立起来了。</p></li>
</ul>
<h6 id="通信子网有2种方式实现虚电路服务">通信子网有2种方式实现虚电路服务</h6>
<p>在通信子网内部，有2种方式可以实现虚电路服务：</p>
<p><strong>1.纯虚电路操作方式</strong></p>
<p>虚电路贯穿了：源端系统 -- 通信子网的各网络节点 -- 目的端系统。<br>
两个端系统的网络层，和“通信子网中网络节点的网络层”，具有相同的操作方式。</p>
<p>SNA(IBM System Network Architecture)网络就是这种纯虚电路操作方式。</p>
<p><strong>2.虚电路+数据报混合操作方式</strong></p>
<p>与端系统相连的网络节点：简称为“端邻节点”。<br>
端邻节点包括：源节点、目的节点。</p>
<ul>
<li>端和“端邻节点”建立虚电路：“端邻节点和端”的网络层，向“端的传输层”提供面向连接的分组传输服务。</li>
<li>通信子网中的网络节点（包括端邻节点）：在网络层采用数据报传输方式。</li>
</ul>
<p>注意：</p>
<ol type="1">
<li>在端邻节点，虚电路中传输的分组只有来站信息，没有目的地址等信息，要在通信子网中以数据报的方式传输，就必须在端邻节点转换，附加上目的地址、序号等信息。<br>
</li>
<li>虚电路分组和数据报的长度不同。源端邻节点需要将虚电路分组再切割得到数据报。<br>
目的端邻节点将数据报排序组装成原来的虚电路分组，再发送给目的端系统的网络层。</li>
</ol>
<p>在这种混合操作方式中，尽管通信子网的数据传输是不可靠的，但端邻节点做了排序、重发（仅限于端和端邻节点之间）等工作，也算是虚电路服务的一种。</p>
<p>ARPANET 网络能够以混合操作方式提供虚电路服务。</p>
<h2 id="数据报服务">5.1.4 数据报服务</h2>
<h6 id="以数据报操作方式实现数据报服务">以数据报操作方式，实现数据报服务</h6>
<p>数据报服务：通常由通信子网以数据报操作方式来实现。</p>
<p>端系统的网络层，和网络节点的网络层，都以数据报的方式交换分组。目的端系统收到的数据报是乱序的，数据报也会发生丢失。</p>
<p>ARPANET、DNA 网络能够以数据报操作方式，由网路层向传输层提供数据报服务。</p>
<h6 id="以虚电路操作方式实现数据报服务">以虚电路操作方式，实现数据报服务</h6>
<p>一种仅陷于理论的操作形式，既不经济，效率也低。</p>
<ul>
<li>端系统的网络层发送、接收数据报。<br>
</li>
<li>端邻节点将数据报转换为虚电路分组</li>
<li>整个通信子网以虚电路操作方式工作，当端邻节点转换出虚电路分组时，就在源节点和目的节点间建立虚电路，然后完成传输，最后拆除虚电路。</li>
</ul>
<h2 id="虚电路子网和数据报子网的比较">5.1.5 虚电路子网和数据报子网的比较</h2>
<p>虚电路和数据报从不同的角度来看，各有优势和劣势。</p>
<h6 id="节点的内存空间与信道带宽之间的平衡">节点的内存空间，与，信道带宽，之间的平衡</h6>
<p>虚电路：</p>
<ul>
<li>分组只需包含来路信息（前节点名+虚电路号），无需目的地址，不浪费信道带宽。</li>
<li>每个节点都保存虚电路表，一条虚电路对应一条表项。看起来虚电路节点比数据报节点使用的内存空间少，但实际上，虚电路节点仍然需要保存每一个可能的目标地址，因为在虚电路建立阶段，仍然和数据报一样，是通过路由选择来寻找路径的。因此，虚电路节点的内存占用更大。</li>
</ul>
<p>数据报：</p>
<ul>
<li>如果每个分组都很短，那么目的地址的比特占比过大，可能比虚电路更浪费带宽。</li>
<li>每个可能的目标地址都对应一个表项，但也比虚电路少。</li>
</ul>
<h6 id="建立虚电路所耗费的时间与节点解析数据报目标地址耗费的时间之间的平衡">建立虚电路所耗费的时间，与，节点解析数据报目标地址耗费的时间，之间的平衡</h6>
<p>虚电路的建立既花费时间，也消耗资源（逻辑信道号，虚电路表）。但虚电路一旦建立，确定分组的后节点却非常简单。</p>
<p>数据报子网中，节点需要执行一个复杂的查找过程，才能确定数据报的下一个目标，这比较花时间。</p>
<h6 id="服务质量和拥塞控制">服务质量，和，拥塞控制</h6>
<p>通信子网发生拥塞，会大大降低服务质量。此时就需要进行拥塞控制。</p>
<ul>
<li>数据报子网：很难实现拥塞控制</li>
<li>虚电路子网：可以在建立虚电路时，事先预留各种资源（节点CPU周期、线路带宽、节点缓冲区空间等），从而一定程度避免拥塞</li>
</ul>
<h6 id="节点失效的影响">节点失效的影响</h6>
<ul>
<li>虚电路子网：所有流经失效路由器的虚电路都会断开。</li>
<li>数据报子网：如果一台路由器失效，则只有还有分组尚留在路由器队列中的用户会受到影响，甚至这些用户也只有一部分受到影响。（不太理解这里的意思，因为数据报子网提供的是无连接服务，应该没有确认这个功能。只有数据链路层提供了对帧的确认，还仅限于BSC和HDLC控制协议，因特网的PPP协议也没有确认功能）</li>
</ul>
<h6 id="数据报子网还可以提供流量平衡功能">数据报子网还可以提供流量平衡功能</h6>
<p>对于较大的分组流量，数据报子网可以把流量分散到多个节点去，而虚电路就无法做到。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第五章 网络层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 5.0 网际互连基础知识</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-5-0-%E7%BD%91%E9%99%85%E4%BA%92%E8%BF%9E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BD%91%E5%8E%9F-5-0-%E7%BD%91%E9%99%85%E4%BA%92%E8%BF%9E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="路由前缀-routing-prefix">路由前缀, routing prefix</h3>
<p><a href="https://en.wikipedia.org/wiki/Subnetwork" target="_blank" rel="noopener">Subnetwork</a> A subnetwork or subnet is a logical subdivision of an IP network.[1]:1,16 The practice of dividing a network into two or more networks is called subnetting.</p>
<p>Computers that belong to a subnet are addressed with an identical most-significant bit-group in their IP addresses. This results in the logical division of an IP address into two fields, the network number or routing prefix and the rest field or host identifier. The rest field is an identifier for a specific host or network interface.</p>
<p>The routing prefix may be expressed in Classless Inter-Domain Routing (CIDR) notation written as the first address of a network, followed by a slash character (/), and ending with the bit-length of the prefix. For example, 198.51.100.0/24 is the prefix of the Internet Protocol version 4 network starting at the given address, having 24 bits allocated for the network prefix, and the remaining 8 bits reserved for host addressing. Addresses in the range 198.51.100.0 to 198.51.100.255 belong to this network. The IPv6 address specification 2001:db8::/32 is a large address block with 296 addresses, having a 32-bit routing prefix.</p>
<p>routing prefix 就是 network number，是IP地址中除 host identifer/rest field 之外的部分。路由前缀可以表示成 CIDR 形式。比如：198.51.100.0/24 。</p>
<h3 id="自治系统autonomous-system-internet">自治系统，Autonomous system (Internet)</h3>
<p><a href="https://en.wikipedia.org/wiki/Autonomous_system_(Internet)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Autonomous_system_(Internet)</a></p>
<p>An autonomous system (AS) is a collection of connected Internet Protocol (IP) routing prefixes under the control of one or more network operators on behalf of a single administrative entity or domain that presents a common, clearly defined routing policy to the internet.[1]</p>
<p>RFC 1930中更新的定義：<br>
一個自治系統（AS，Autonomous system）是指：具有相关的 IP 路由前缀的集合（主机、路由器），代表了一个实体或区域，从 Internet 角度观察，这个集合内采用了共同的路由策略。</p>
<p>事实上，AS的定义发生过变化。在更早的时候，RFC 1771对AS的定义是：<br>
一个自治系统由一个单一实体管辖，实体通常是一个 ISP 或一个通过独立连接将多个网络互连起来的大型组织，在ISP内或大型组织的网络内执行一个单一且明确的路由策略。（此定义现在已经废止）</p>
<p>RFC 1930推出的原因在于：<br>
事实上，多个组织可使用各自私有的自治系统编号(AS number)，通过与“将它们连接到 Internet 的同一个 ISP”之间运行BGP协定来实现网络互连。<br>
此时，对 Internet 来说只能看到 ISP 的路由策略，看不到组织内的路由策略，而每个组织内仍然是一个自治系统，这就与RFC 1771的定义不相符。</p>
<p>使用BGP路由中的每个自治系统都被分配了一个唯一的自治系统编号（ASN）。ASN是连接到 Internet 的每个网络的唯一标识，所以 ASN 很重要。</p>
<h3 id="igpegp">IGP，EGP</h3>
<p>内部网关协议 IGP(interior gateway protocol) ：在自治系统内使用的一类路由协议，用于在网关(通常指路由器）之间交换路由信息。</p>
<p><em>P.S.这里的网关就是不规范用法，泛指 bridge + router + gateway。</em></p>
<p>已知的IGP协议有：</p>
<ul>
<li>Routing Information Protocol (RIP)</li>
<li>Interior Gateway Routing Protocol (IGRP)</li>
<li>Open Shortest Path First (OSPF)</li>
<li>Intermediate System to Intermediate System (IS-IS)</li>
</ul>
<p>EGP(exterior gateway protocol)：应用于自治系统之间的一类路由协议。</p>
<p>目前只有一种 EGP协议：</p>
<ul>
<li>BGP(Border Gateway Protocol)。</li>
</ul>
<h3 id="internet-和-ethernet-的区别">Internet 和 ethernet 的区别</h3>
<p>Internet是范围概念；ethernet 是技术概念。</p>
<p>以太网（英语：Ethernet）是为了实现局域网通信而设计的一种技术，它规定了包括物理层的连线、电子信号和介质访问层协议的内容。以太网是目前应用最普遍的局域网技术，取代了其他局域网标准如令牌环、FDDI和ARCNET。</p>
<p>互联网（英语：Internet）是一个将大量网络互连后构成的网络，它是由从地方到全球范围内几百万个私人的，政府的，学术界的，企业的和政府的网络所构成，通过电子，无线和光纤网络技术等等一系列广泛的技术联系在一起。</p>
<p>ethernet 可以有无数个， Internet 却只能有一个。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第五章 网络层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 4.5 Internet 的数据链路层协议</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-4-5-Internet-%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE/%E7%BD%91%E5%8E%9F-4-5-internet-%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>需要说明：</p>
<ol type="1">
<li>停等协议Stop and Wait、顺序接收管道协议 GBN和 Slidding Window、选择重传协议 SR ，属于数据链路层传输数据时采用的协议，包含了差错控制和流量控制策略，这种策略可适用于局域网和因特网。</li>
<li>BSC和HDLC属于OSI参考模型中数据链路层的控制协议，不是TCPIP网络的协议。<br>
</li>
<li>本节所讲的因特网的数据链路层协议，是指TCP/IP模型所使用的数据链路层协议，包括了控制协议和数据传输协议。（TCPIP模型没有单独的数据链路层，只有主机-网络接口层）</li>
</ol>
<h2 id="slip协议">4.5.1 SLIP协议</h2>
<p>串行线路 IP 协议，SLIP，Serial Line IP</p>
<p>SLIP协议的功能：</p>
<ul>
<li>在串行通信线路上，对网络层传递下来的 IP分组进行封装，组装成帧。</li>
<li>允许用户通过电话线和MODEM接入TCP/IP网络</li>
</ul>
<p>SLIP协议存在一些问题：</p>
<ul>
<li>连接过程中不支持动态 IP，通信双方必须事先告知对方IP地址。这对于没有固定IP地址的用户不方便。</li>
<li>SLIP帧没有“协议类型”字段，只支持IP协议</li>
<li>SLIP帧没有校验字段，无法检测差错。只能依赖更高层或更低层提供检错纠错功能。比如依靠物理层的MODEM提供检错能力（奇偶校验位）。</li>
</ul>
<h2 id="ppp协议">4.5.2 PPP协议</h2>
<p>SLIP协议存在各种缺点，于是又推出了PPP协议。</p>
<p>PPP协议（Point to Point Protocal）即”点到点协议“，是全世界广泛使用的数据链路层协议（一个主要原因是TCPIP网络的占比很大）。</p>
<p>用户使用拨号电话线接入Internet时，一般都使用PPP协议。</p>
<img src="/2019/12/01/网原-4-5-Internet-的数据链路层协议/网原-4-5-internet-的数据链路层协议/20190910232601006_17067.png">
<h6 id="ppp的功能">PPP的功能</h6>
<p>PPP协议有3个组成部分：</p>
<ol type="1">
<li>成帧：将网络层传递下来的 IP数据报 封装成帧，最终交给物理层形成位流。</li>
<li>提供链路控制协议 LCP (Link Control Protocol)：LCP支持同步/异步线路，支持面向字节/比特的编码方法，提供了 协商链路层参数、建链、测试链路、拆链 等功能。</li>
<li>提供网络控制协议NCP：PPP协议提供了“协商网络层参数”的方法，这些方法独立于网络层协议：对于每一种支持的网络层，都有一个不同的网络控制协议 NCP (Network Control Protocol)。</li>
</ol>
<h6 id="ppp的工作过程">PPP的工作过程</h6>
<p><strong>PC机接入Internet的过程</strong></p>
<p>1.建立物理连接：<br>
PC机通过自己的MODEM呼叫ISP的MODEM，ISP的MODEM应答了用户呼叫后，建立物理连接。</p>
<p>2.建立数据链路层：<br>
PC机给ISP的路由器发送多个 PPP帧，这些帧的净荷包含了很多的 LCP 分组。这些分组，以及ISP路由器的应答信息，共同确定了PPP协议的参数。由此，建立了PPP协议的数据链路。</p>
<p>3.建立网络层：<br>
PC机和ISP的路由器之间，传送 NCP 分组，开始配置网络层。<br>
比如：<br>
针对IP协议的NCP负责给PC机动态分配IP地址。针对其他协议的NCP负责给PC机配置对应的协议。<br>
最终这些NCP分组使PC机运行了一个TCP/IP协议栈。</p>
<p>至此，PC机就接入了 Internet，成为了一台Internet的主机，可以发送和接收 IP 分组。</p>
<p><strong>PC机如何断开与Internet的连接</strong></p>
<ol type="1">
<li>断开网络层连接，释放IP地址。<br>
</li>
<li>断开数据链路层连接<br>
</li>
<li>PC机通知MODEM 挂断电话，释放物理层连接。</li>
</ol>
<h6 id="ppp的帧格式">PPP的帧格式</h6>
<p>PPP帧 和 HDLC帧 在格式上非常相似，但存在本质上的不同：PPP帧面向字符，HDLC帧面向字节。</p>
<img src="/2019/12/01/网原-4-5-Internet-的数据链路层协议/网原-4-5-internet-的数据链路层协议/20190910233017876_15003.png">
<p>PPP在 <em>拨号调制解调器线路</em> 上使用了“字节填充技术“——有效数据中如果含有与标志字节相同的二进制模式，则通过填充字节来实现数据的透明性。<br>
因此，PPP帧的长度都是字节的整数倍！</p>
<p>首尾的标志字节 F，和HDLC一样，采用 01111110 的二进制模式。</p>
<p>地址字节 A ，恒为广播地址 11111111 ，避免了给站点分配”数据链路层地址“的问题。<br>
换句话说，PPP帧是广播帧，站点可以接收该帧，但帧内的IP数据报是否接收还取决于网络层的IP地址。</p>
<p>P.S. 数据链路层地址，即MAC地址。</p>
<p>控制字节 C，默认值是 00000011，此值表示该帧是一个无序号帧。换句话说，默认情况下，PPP帧无法利用序号（比如N(S)N(R))来实现重发表、选择重传等可靠传输。</p>
<p>协议字节 P，2个字节，指明净荷域（即数据，图中的信息部分）是哪一种分组，可能的分组有：LCP,NCP,IP,IPX,AppleTalk，其他协议。<br>
如果协议域的值以0开头，说明净荷域是网络层协议的分组，即信息字段是IP数据报（IP,IPX,OSI CLNP,XNS)。<br>
如果协议域的值以1开头，说明净荷域是LCP或NCP。</p>
<p>净荷域是变长的。</p>
<p>校验和域，2个字节。通常是CRC码，使PPP帧具有差错校验能力。</p>
<p>总之，PPP是一种多协议成帧机制，可以用于多种物理层上。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第四章 数据链路层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 4.4 链路控制规程</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-4-4-%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6%E8%A7%84%E7%A8%8B/%E7%BD%91%E5%8E%9F-4-4-%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6%E8%A7%84%E7%A8%8B/</url>
    <content><![CDATA[<p>数据链路控制协议，也称为“数据链路通信规程”（规程：规定的程序，操作序列）。<br>
它是OSI参考模型中数据链路层的协议。</p>
<p>说明：<br>
<em>在TCP/IP模型中，物理层和数据链路层并称为“主机-网络层”，而这里所讲的协议，仅仅是数据链路层的协议，因此说：属于OSI参考模型。</em></p>
<p>数据链路控制协议分为：</p>
<ol type="1">
<li>异步协议：以字符（实际应该是群）为基本传输单位，加上起始位（0）和结束位（1），实现“起止式传输”。缺点：每个传输字符都要添加起始位、校验位、停止位等冗余位，信道利用率太低，只适合低速通信场合。</li>
<li>同步协议：以帧为单位（一帧包含多个字符或较长的位流），发收双方通过帧头实现同步。优势：信道利用率较高，利用帧可以实现差错控制、流量控制。</li>
</ol>
<p>在4.1.1 帧同步功能一节中，已经介绍了几种帧定界法：</p>
<ol type="1">
<li>字符填充的首尾定界符法</li>
<li>比特填充的首尾标志法</li>
<li>违法编码法</li>
<li>字节计数法</li>
</ol>
<p>该节已经较详细的介绍了4. 字节计数法。<br>
下面详细讲解 1.字符填充的定界符法 2.比特填充的定界符法。</p>
<p>任何链路层控制协议都包含3部分内容：建立链路、数据传输、拆除链路。</p>
<h2 id="二进制同步通信协议">4.4.1 二进制同步通信协议</h2>
<p>字符填充的定界符法，也称为“面向字符的同步协议”。</p>
<p>面向字符的同步协议是最早提出的同步协议，典型代表是IBM公司推出的BSC协议。</p>
<h6 id="bsc协议binary-synchronous-communication二进制同步通信协议">BSC协议（Binary Synchronous Communication），二进制同步通信协议。</h6>
<p>为了实现建链、同步、拆链等功能，就必须引入控制字符。</p>
<p>BSC协议中的控制字符，采用了 ASCII 或 EBCDIC 字符集。</p>
<p>BSC的传输控制字符：</p>
<ul>
<li>SOH: Start Of Head, 序始，报文的标题，或报头的开始</li>
<li>STX: Start Of Text, 文始，标题信息的结束，或报文正文的开始。</li>
<li>ETX: End Of Text, 文终，报文文本的结束。</li>
<li>ETB： End of Transmission Block，块终（帧终），当报文分成多个数据块（帧）时，一个数据块的结束。</li>
<li>EOT：End Of Transmission，送毕，一个或多个数据块的结束，并拆除链路。</li>
<li>ENQ：Enquire, 询问，请求远程站给出响应，响应内容包括：远程站的身份、状态。</li>
<li>ACK：Acknowledge，确认，接收方发出的，对正确接收的报文的响应。</li>
<li>NAK：Negative Acknowledge，否认，接收方发出的，对未正确接收的报文的响应。</li>
<li>DLE：Data Link Escape，转义，对紧跟其后的有限个字符进行转移，从而实现BSC协议的透明传输，或者当原有的传输控制字符不够用时，利用转义提供新的传输控制字符。</li>
<li>SYN：Sychronous，同步，放在帧头，实现节点间的字符同步，或者，无数据传输时保持同步（换句话说，SYN也可以用作无数据的空白帧？)</li>
<li>BCC：Block Check Character，块校验字符。可以是垂直奇偶校验，也可以是16位CRC，校验范围从 STX 开始到 ETX 或 ETB为止。</li>
</ul>
<p>BSC协议把报文分为数据报文和监控报文两类。<br>
报文必然包含传输控制字符，用于确定报文中信息的性质，或实现控制作用。</p>
<p>BSC的任何报文都以2个 SYN 开头，以便接收方实现字符同步。</p>
<h6 id="数据报文">数据报文</h6>
<p>数据报文由报头和文本组成：</p>
<ul>
<li>报头：可选的辅助信息，与文本的传输、处理有关。主要包括：报文的包识别符（序号）、地址</li>
<li>文本：是要传输的有效数据。</li>
</ul>
<p>如果报文短于数据块（帧），可以只用一个来传输，否则需要切割成多个数据块（帧）传输。</p>
<p>BSC协议的数据块有如下4种格式：<br>
1.不带报头的单块报文，或，分块传输的最后一块报文 SYN| SYN| STX | 报文 | ETX | BCC</p>
<p>2.带报头的单块报文 SYN | SYN | SOH | 报头 | STX | 报文 | ETX | BCC</p>
<p>3.带报头的分块传输中的第一块报文 SYN| SYN | SOH | 报头 | STX | 报文 | ETB | BCC</p>
<p>4.分块传输中的中间报文<br>
SYN | SYN | STX | 报文 | ETB | BCC</p>
<p>如果报文不是字符，而是二进制位流，就可能包括与控制字符相同的二进制位串组合，为了区分，采取：</p>
<ul>
<li>SYN，DLE ：不加DLE，保持原样。</li>
<li>DLE + 控制字符：表示真正的控制字符</li>
<li>DLE + DLE : 表示数据的 DLE</li>
</ul>
<h6 id="监控报文">监控报文</h6>
<p>监控报文又分为：正向监控和反向监控。</p>
<p><em>书上没细讲区分，估计是主站对从站监控，或从站请求主站。</em></p>
<p>监控报文只含有单个控制字符。 （或者是，若干个其他字符做前缀 + 单个控制字符）</p>
<p>前缀字符包括了：识别号(序号)、地址、状态、其他所需信息。</p>
<p>监控报文有4种格式： 1.肯定确认 / 选择响应 SYN | SYN | ACK</p>
<p>肯定确认：对先前发来的帧正确接收的响应，ACK种必然包含序号。 选择响应：主站选择此从站进行监控，从站所返回的响应信息。</p>
<p>2.否定确认 / 选择响应 SYN | SYN | NAK</p>
<p>3.轮询 / 选择请求 SYN | SYN | P/S 前缀 | 站地址 | ENQ</p>
<p>主站轮询从站。<br>
主站选择某个从站进行监控。</p>
<p>4.拆链 SYN | SYN | EOT</p>
<p>表示两站间的报文交换结束，并拆除链路。</p>
<h6 id="bsc协议的优缺点">BSC协议的优缺点</h6>
<p>与字符集关系过于密切。<br>
字符填充法实现比较麻烦。<br>
半双工协议，链路传输效率很低。</p>
<p>需要的缓冲存储空间小，适合用于面向终端的网络系统（终端的硬件配置低）。</p>
<h2 id="高级数据链路控制协议">4.4.2 高级数据链路控制协议</h2>
<p>ISO 发布了高级数据链路控制协议 HDLC（High-Level Data Link Control）。</p>
<p>HDLC属于面向比特的同步协议（即使用<strong>特定的二进制模式</strong>作为帧定界符）。</p>
<p>HDLC具有很多优势，是目前普遍采用的数据链路层控制协议。</p>
<h3 id="hdlc的操作方式">1.HDLC的操作方式</h3>
<p>HDLC在建立数据链路时，可以选择站点的操作方式。</p>
<p>Q. 什么叫“站点的操作方式”？<br>
A. 站点在通信中的身份。一个站点可以是主站、从站、或二者兼备。</p>
<p>主站：控制从站、轮询其他站的站点。</p>
<p>主站的功能：组织数据流、恢复链路上的差错。</p>
<p>从站：受主站控制的站点。</p>
<ul>
<li>命令帧：主站发往从站的帧。</li>
<li>响应帧：从站发往主站的帧。</li>
</ul>
<p>需要说明：<br>
主站和从站仅仅是从信息传输的控制角度来看，并不是主站=发方、从站=收方。<br>
在数据发送的角度来看，谁发出数据谁就是发方，谁接收数据谁就是收方。</p>
<h6 id="主站和从站的关系并非绝对">主站和从站的关系并非绝对</h6>
<ul>
<li>连有多个站点、采用轮询技术的网络（疑指广播型？总树环无卫）中，轮询其他站点的站就是主站。</li>
<li>点-点的链路中（星环树网），每个站都可以成为主站。</li>
<li>主机-终端网络中，主机是主站，终端是从站。</li>
<li>一个发散出多条链路的站点，对于一些链路可能是主站，对另一些可能是从站。</li>
<li>有些站兼备主站和从站的功能，称为组合站。</li>
</ul>
<h6 id="平衡操作和非平衡操作">平衡操作和非平衡操作</h6>
<p>从通信双方和链路的整体来看，分为：</p>
<ul>
<li>平衡操作：双方都是组合站，通信协议是对称的。</li>
<li>非平衡操作：双方有主从之分，各自角色不同。</li>
</ul>
<h6 id="hdlc的操作方式-1">HDLC的操作方式</h6>
<p>1.正常响应方式 NRM (Normal Response Mode)<br>
NRM是一种非平衡操作方式，适用于面向终端的1对1、1对多的链路。</p>
<p>主站管理整个链路，具有轮询、选择从站、发送命令帧的功能，也负责管理超时、重传及各类恢复操作。</p>
<p>整个传输过程由主站发起：主站对从站发出命令帧；从站对命令帧做出响应，向主站传输信息。</p>
<p>2.异步响应方式 ARM (Asynchronous Response Mode)<br>
ARM也是一种非平衡操作方式。</p>
<p>从站主动向主站发送一个或多个帧，这些帧可以是包含了信息的数据帧，也可以是控制帧。</p>
<p>此时，从站管理了这些帧的传输过程，包括：超时、重发等。</p>
<p>对于采用轮询的链路，ARM方式必不可少。</p>
<p>3.异步平衡方式 ABM (Asynchonous Balance Mode)<br>
链路中的节点都是组合站，都可以作为主站和从站，都可以发起传输过程，发出命令帧和响应帧，每个站都可以对超时、重传、差错恢复进行控制。</p>
<h3 id="hdlc的帧格式">2.HDLC的帧格式</h3>
<p>BSC采用不同的帧格式传输数据报文和监控报文（控制报文）。<br>
HDLC 采用统一格式传输数据报文和控制报文，同样，命令帧和响应帧也具有统一的帧格式。</p>
<p>完整的HDLC帧包括：</p>
<ol type="1">
<li>标志字段<br>
01111110。<br>
标志着一帧的开始和结束。<br>
当没有数据传输时，可以作为同步控制使用：在无数据的时刻，信道仍处于激活状态，此时发送“只有开头和结束的标志字段，没有其他字段”的空帧，如果接收方发现某一帧的开头标志字段后接续的不是标志字段，说明新的一帧到来了。</li>
</ol>
<p>2.地址字段<br>
字段内容取决于发出该帧的站的操作方式。</p>
<p>操作方式分为：主站、从站、组合站。</p>
<p>从站、组合站具有唯一的地址。</p>
<ul>
<li>命令帧的地址字段内容：是对方站的地址（从站/组合站）。</li>
<li>响应帧的地址字段内容：是本站的地址。</li>
</ul>
<p>组地址：可以分配给多个站的地址。</p>
<p>携带组地址的帧可以被一个组的全部站点接收。但当一个从站/组合站对这种组地址发回响应帧时，应该应该使用它自己的唯一地址——换句话说：一个站可以拥有多个地址。</p>
<p>广播地址：全1，包含了所有站。<br>
无站地址：全0，不分配给任何站，仅用作测试。</p>
<p>3.控制字段<br>
控制字段是HDLC的关键字段。<br>
包含了各种控制命令和对命令的响应。</p>
<p>主站/组合站利用控制字段通知从站/组合站执行操作。 从站/组合站利用控制字段报告已完成的操作、状态的变化。</p>
<p>4.信息字段<br>
长度不限的任意的二进制位串。</p>
<p>但在实际应用中，其长度受限于FCS字段和站点的缓冲器容量。</p>
<p>对于监控帧，信息字段必须为0。</p>
<p>5.帧校验序列字段<br>
使用16位CRC，对首尾标志字段之间的内容进行校验。</p>
<p>0比特插入法：<br>
可以实现数据的透明传输。发送端检测除标志字段外的所有字段，如果出现连续的5个1就添加0。接收端如果收到5个1+1个0，则去掉0。</p>
<h3 id="hdlc的帧类型">3.HDLC的帧类型</h3>
<p>HDLC的帧分为3种类型：信息帧、监控帧、无编号帧。<br>
3种帧的控制字段中，各比特位的含义不同（格式不同）：</p>
<ul>
<li>第1、第1+2位：帧的类型。<br>
</li>
<li>第5位： P/F 位，Poll/Final 位，轮询位/终止位。如果是主站发出的命令帧，P/F位为1时，起轮询的作用，要求被轮询的从站给与响应；如果是从站发出的响应帧，P/F位为1时，表示从站的响应、或传输的终止。</li>
<li>帧编号位：为了实现连续传输，需要对帧进行编号，因此控制字段还包括了帧的编号。</li>
</ul>
<h6 id="信息帧i帧">信息帧，I帧</h6>
<p>用于传输数据的帧，通常简称为 I 帧。</p>
<ul>
<li>第一位：为0。表示信息帧。</li>
<li>N(S)位：Number(Sender)。如果当前帧是发送方发出的，那么这里就存放发送帧序号，已方便实现重发、滑动窗口等控制。</li>
<li>N(R)位：Number(Receiver)。如果当前帧是接收方发出的，那么这里就存放了准备接收的下一帧的序号，也暗示了前面的帧已经正确接收。</li>
</ul>
<h6 id="监控帧s帧">监控帧，S帧</h6>
<p>监控帧实现了差错控制、流量控制。简称为 S 帧。<br>
监控帧只有6个字段：标志位(1)+地址(1)+控制(1)+ 信息(0)+帧校验（2）+标志位(1)</p>
<p>需要说明：<br>
主站/从站是从操作方式，即控制与受控的角度来讲，它主要与监控帧相关。<br>
发方/收方主要是从信息帧的角度来讲。<br>
两个概念并不太相关。</p>
<ul>
<li>第1，2位：10，表示监控帧。</li>
<li>第3，4位有4种组合：
<ul>
<li>00：接收就绪 RR，Receiver Ready。主从站都可发出此帧。主站用控制字段7.8位帧序号=N(R)的RR帧轮询从站，希望被轮询的从站发送帧序号为N(R)的信息帧；从站也可以发送RR帧，表示从站等待接收的下一帧的编号是N(R)。</li>
<li>01：拒绝 REJ，Rejection。主从站都可发出此帧。要求发方重发N(R)及后续的所有帧。同时也暗示了N(R)-1的帧都已经正确接收。</li>
<li>10：接收未就绪 RNR，Receicver Not Ready。主从站都可以发出此帧。表示 N(R)-1的信息帧已经收到，但目前收方正忙，尚未准备好接收 N(R)的信息帧。此帧用于实现流量控制。</li>
<li>11：选择拒绝 SREJ，Selective Rejection。主从站都可发出此帧。要求发方重发编号为 N(R)的单个信息帧。暗示其他编号的信息帧已经正确接收。</li>
</ul></li>
</ul>
<p>总结：<br>
RR和RNR监控帧有两个共同的功能：</p>
<ol type="1">
<li>当主站向从站轮询状态时，从站向主站描述自己当前的状态。</li>
<li>从站向主站确认序号 N(R)-1 的帧都已经正确接收</li>
</ol>
<p>RR还具有主站请求从站发送N(R)的I帧的作用，同时还确认了N(R)都已正确接收。</p>
<p>REJ和SREJ监控帧的功能：</p>
<ol type="1">
<li>向发方指明发生了错误</li>
<li>REJ对应了GBN策略</li>
<li>SREJ对应了SR策略</li>
</ol>
<h6 id="无编号帧u帧">无编号帧，U帧</h6>
<p>因为控制字段没有N(S)N(R)这2个编号而得名，简称为U帧。</p>
<p>作用是：提供链路的建立、拆除、其他控制功能。</p>
<p>U帧带有 <span class="math inline">\(M_1\)</span>~<span class="math inline">\(M_5\)</span> 5个修正位，通过修正位的组合，实现了32种控制命令。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第四章 数据链路层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 4.3 基本数据链路协议</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-4-3-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%8D%8F%E8%AE%AE/%E7%BD%91%E5%8E%9F-4-3-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>数据链路层的各项功能，比如差错控制、流量控制，最终都是通过协议来实现。</p>
<p>差错控制方法，包括了ARQ法和FEC法。<br>
流量控制方法，包括了：停止等待方案、滑动窗口机制。</p>
<p>有时，一个协议会实现多个功能，比如同时实现了差错控制方法和流量控制方法。</p>
<p>自动重发请发法（ARQ），又分为：</p>
<ol type="1">
<li>空闲重发请求，Idle RQ</li>
<li>连续重发请求，Continuous RQ</li>
</ol>
<h2 id="停等协议stop-and-wait">4.3.1 停等协议(Stop and Wait)</h2>
<p>停等协议：<br>
结合了，流量控制方案中的停止等待方法，与差错控制方法中的空闲自动重发请求 Idle RQ。</p>
<ol type="1">
<li>发方把“待发送帧”放入缓冲区中</li>
<li>给“待发送帧”赋予帧序号，启动计时器，发送</li>
<li>收方收到帧后，放入收方缓冲区，之后进行检查。如果无差错则向发方发送一个相同帧序号的ACK确认帧</li>
<li>收方如果发现差错，则舍弃该帧</li>
<li>如果发方在规定时间内收到ACK确认帧，重置计时器，开始下一帧的发送</li>
<li>如果发方未在规定时间内收到ACK确认帧（即计时器超时），则重发发方缓冲区中的待确认帧。</li>
</ol>
<p>特点：</p>
<ul>
<li>发收双方只需要设置一个帧的缓存空间</li>
<li>待确认帧的序号只需要一个二进制位，0/1</li>
</ul>
<h2 id="顺序接收管道协议gbn">4.3.2 顺序接收管道协议（GBN）</h2>
<p>顺序接收管道协议：<br>
实现了，差错控制方法中的“连续重发请求（Continuous RQ)”，和，流量控制方法中的“滑动窗口机制”。</p>
<h6 id="采用gbn策略gobackn回退n的连续重发请求">采用GBN策略(GoBackN,回退N)的连续重发请求</h6>
<p>GoBackN策略可以有两种实现方法：</p>
<ul>
<li>（发方被动检测）发方发出多帧，如果重发表的第N帧及后续帧，计时器超时后ACK确认帧仍未返回，就重新发送第N帧及后续帧</li>
<li>（收方主动请求）收方检测到失错（丢失、错误）的信息帧后，请求发方重发“最后正确接收的信息帧之后的”的待确认帧</li>
</ul>
<p>GoBackN策略的工作流程如下：</p>
<ol type="1">
<li>发方设置一个“发方缓冲区”（即重发表），采用先进先出(FIFO)的队列规则。</li>
<li>在发方，“信息帧”依次发出，其副本被放入重发表中，成为“待确认帧”。重发表是一个连续序号的队列（比如用3位二进制数表示0~7），副本帧进入重发表时被自动赋予序号。</li>
<li>到达收方的信息帧进入“收方缓冲区”，等待检错、处理。</li>
<li>收方对信息帧进行检错。如果无差错，向发方返回ACK确认帧，其中包含了信息帧的序号。同时，收方还有一个“接收次序表”，记录了最后正确接收的信息帧的序号。</li>
<li>如果发现信息帧的差错，则丢弃“该帧及所有序号大于它的后续信息帧”，从而确保了：顺序接收。</li>
<li>发方收到ACK确认帧后，删除重发表中对应序号的待确认帧。（因为收方保证了顺序接受，因此发方也会顺序删除）</li>
<li>如果发方发现重发表中某一帧的确认帧超时，说明信息帧丢失或出错。就需要退回重发表队列的头部（已确认的元素已经删除了，剩下都是未确认的），再次发送整个重发表。</li>
</ol>
<img src="/2019/12/01/网原-4-3-基本数据链路协议/网原-4-3-基本数据链路协议/20190927163612247_8836.png">
<p>疑问：</p>
<ol type="1">
<li>如果采用数据报的分组交换方式，帧可能会乱序到达收方。比如，假设第21帧没有差错，收方返回确认帧，之后又收到第16帧，发现有差错，这样就至少需要丢弃序号&gt;=16的所有信息帧。<br>
这样一来，收方就需要对发方本轮次发出的所有信息帧检错后，才能确定哪些帧该丢弃，哪些帧该保留。</li>
</ol>
<p>回答：可能不影响，即使乱序，收方不断的丢弃即可。</p>
<ol start="2" type="1">
<li>收方可能还需要一个计时器来区分到达的信息帧是本轮发出的，还是下一轮次重发的。或者不同同一信息帧，在不同的重发轮次中需要编不同的序号？<br>
否则可能带来问题：<br>
假设发方发出第一轮次的信息帧队列，收方在处理第一轮的第12帧时发现错误，需要舍弃 序号&gt;=12的所有信息帧。<br>
发方无法收到 序号&gt;=12的ACK确认帧，重新发送重发表。<br>
收方收到重发的序号&gt;=12的信息帧后，认为需要舍弃，于是将重发的12+信息帧也丢弃了。 发方再次重发，陷入死循环。</li>
</ol>
<p>回答：不会发生这种事，收方丢弃以后，应该会等待接收新的第12+帧</p>
<h6 id="采用滑动窗口机制slidding-window进行流量控制">采用滑动窗口机制(slidding window)，进行流量控制</h6>
<p>回退N策略的连续重发请求，确实提高了信道的利用率，但也存在一些缺点：</p>
<ul>
<li>已发送待确认的帧越多，当其中某帧失错后，需要重发的帧也就越多</li>
<li>发方缓存可能会过载：如果发方发出速度高于收方的接收处理速度，发方重发表种的帧数量就会不断增长，直到超出缓存区大小。</li>
</ul>
<p>因此，必须控制发方“待确认帧”的数量，也就是流量控制，这可以通过窗口机制来实现。</p>
<p>窗口机制：</p>
<ul>
<li>发方设置了“发送窗口”：容纳“已发送、待确认的帧”。发送窗口是重发表的子集，其元素个数称为窗口尺寸。</li>
<li>收方设置了“接收窗口”：容纳“等待接收的帧”</li>
</ul>
<img src="/2019/12/01/网原-4-3-基本数据链路协议/网原-4-3-基本数据链路协议/4rE8Hp.gif">
<p>状态变化过程如下：</p>
<ol type="1">
<li>发方没有发出信息帧，发方窗口上下沿重合，没有元素。收方窗口打开帧0，等待接收。</li>
<li>发方窗口容纳帧0，帧0发出待确认，收方窗口等待帧0。（此时信息帧0还未到达收方）</li>
<li>因为发方窗口最大尺寸为2，在帧0未收到确认帧前，还可以发出帧1，因此发方窗口容纳了帧0帧1。收方窗口仍然等待帧0。</li>
<li>发方窗口容纳帧0帧1，等待确认帧；收方窗口接收了信息帧0，返回了帧0的确认帧，然后关闭帧0窗口，打开帧1窗口，等待接收帧1。</li>
<li>发方收到帧0的确认帧，关闭帧0的窗口，此时发送窗口容纳了帧1；收方继续等待帧1的信息帧。</li>
<li>发方打开帧2的窗口，此时发方窗口容纳了帧1帧2；收方窗口收到帧1，返回了帧1的确认帧，之后关闭帧1窗口，打开帧2窗口，等待接收帧2.</li>
<li>发方收到帧1的确认帧，关闭帧1窗口，此时发送窗口容纳了帧2；收方继续等待帧2的信息帧。</li>
</ol>
<p>需要说明：<br>
因为信息帧和确认帧在每次传输中花费的时间都可能不相同，因此，上图中各状态不会随时间规律变化，从某个状态到另一个状态可能花费很长时间，也可能很短时间。</p>
<p>引申：</p>
<ul>
<li>停等协议：发送窗口尺寸=1，接收窗口尺寸=1</li>
<li>GoBackN协议：发送窗口尺寸&gt;1，接收窗口尺寸=1</li>
</ul>
<h2 id="选择重传协议srselective-repeat">4.3.3 选择重传协议（SR，Selective Repeat)</h2>
<p>GoBackN协议的缺点：<br>
收方收到多帧，即使只有中间第n帧出错，后续帧都无差错，也需要发方重发第n帧及后续帧。这是一种浪费。</p>
<p>此时可以采用选择重传策略：</p>
<ul>
<li>收方收到多帧，如果中间有少量帧出现错误，其后续帧没有错误，那么就把后续的正确帧先放入缓存，向发方返回错误帧的“否认帧”NAK。<br>
</li>
<li>发方收到“否认帧”NAK后，不需要等待该帧的计时器超时，就可以重发出错的帧。<br>
</li>
<li>收方收到重发的帧后，将其与先前缓存的帧组装后，递交给网络层。</li>
</ul>
<p>显然，选择重传策略具有一些优势：</p>
<ol type="1">
<li>减少浪费：只要求发方重发错误帧。</li>
<li>节约了等待超时的时间：GBN策略中，发方需要等待失错帧超时。（收到否认帧即可重发）</li>
</ol>
<p>唯一的缺点是：收方需要较大的缓存空间。</p>
<img src="/2019/12/01/网原-4-3-基本数据链路协议/网原-4-3-基本数据链路协议/wE4X2V.gif">
<p>图上信息帧2到达收方后出错，收方返回NAK否认帧，而后续的帧3，4，5都没有错误，被放入缓存中，同时收方返回ACK确认帧。发方收到NAK否认帧后，再次重发帧2。</p>
<p>SR策略中，一定范围内不按顺序到达的帧都可以接收，如果将这个范围视为窗口，那么SR策略中接收窗口是大于1的。</p>
<p>注意：选择重传协议也会丢弃分组，它只能暂存窗口范围内的分组，超过窗口的分组仍然只能丢弃。</p>
<h5 id="发送窗口和接收窗口的尺寸问题">发送窗口和接收窗口的尺寸问题</h5>
<p>假设重发表中的帧序号采用3位2进制数表示，则最大帧序号 <span class="math inline">\(S_{max}=2^3-1=7\)</span></p>
<h6 id="有序接收方式">有序接收方式</h6>
<p>对于有序接收方式（比如Stop and Wait、GBN），发送窗口的最大尺寸可以等同于重发表的最大序号。<span class="math inline">\(S_{max} = 2^m -1\)</span>。m是重发表的最大序号，从10进制形式转换成2进制形式后的位数。</p>
<p>比如重发表序号为0~7，则 m = 3。</p>
<p>接收窗口大小始终为1。</p>
<p>发送窗口尺寸不能大于重发表序号范围。<br>
例如重发表最大序号是3，允许的序号：0,1,2,3；发送窗口尺寸是6。<br>
窗口中帧的序号就会被标记为 0,1,2,3,0,1。<br>
当收到接收方返回的ACK确认帧时，就无法分辨到底时第一个0帧，还是第二个0帧。</p>
<p>接收方一般都是采用“累积确认”的方式。接收方不必对收到的帧逐个发送确认，可以在收到几个帧后，对按序到达的最后一个帧发送确认，这样就表示：到 这个帧为止的所有帧都已正确收到了。</p>
<h6 id="对于无序接收方式">对于无序接收方式</h6>
<p>对于无序接收方式（SR策略)，发送窗口的最大尺寸，最多只能是<span class="math inline">\(S_{max} \cdot 1/2\)</span>。</p>
<p>首先，无序接收方式中，</p>
<ul>
<li>发送窗口不能比接收窗口大，不然接收窗口可能会溢出。但接收窗口可以比发送窗口大。因此，发送窗口 &lt;= 接收窗口</li>
<li><p>增大发送窗口可以提高传输效率，但要避免产生二义性。<br>
假设重发表序号最大为7(即序号为0,1,2,3,4,5,6,7)，设发送窗口和接收窗口的尺寸都为5(0,1,2,3,4)。<br>
同时假设：发送窗口发出0,1,2,3,4帧，接收窗口全部接收成功，返回ACK，接收窗口向前移动，等待接收5,6,7,0,1帧(注意：这里帧的序号溢出了队列，导致循环）。<br>
再假设，发送窗口并没接收到任何确认帧（返回的ACK全部丢失）。<br>
此时，只能重发0,1,2,3,4帧。而接收窗口就无法区分0,1帧到底是重发的，还是本轮应该等待的，这就是二义性。</p></li>
<li><p>因为发送窗口&lt;=接收窗口。要最大化传输效率，应使 发送窗口尺寸=接收窗口尺寸。<br>
假设发送窗口尺寸为M，接收窗口尺寸也为M。发送窗口发出M个帧后，接收窗口向前移动M格，接收窗口等待序号为 M+1,M+2,...2M的帧。要避免二义性，就必须满足2M&lt;=重发表序号最大值。</p></li>
</ul>
<h6 id="用窗口的观点来看三种策略">用窗口的观点来看三种策略</h6>
<p>可以用窗口的观点来看待三种策略：</p>
<ul>
<li>停等 : 发送窗口 =1 ，接收窗口 =1</li>
<li>GBN : 发送窗口 &gt;1 ，接收窗口 =1</li>
<li>SR选择重传：发送窗口 &gt;1 ，接收窗口 &gt;1</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第四章 数据链路层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 4.2 差错控制</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-4-2-%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/%E7%BD%91%E5%8E%9F-4-2-%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>差错控制： 通信过程中</p>
<ul>
<li>发现错误</li>
<li>纠正错误，</li>
</ul>
<p>把控制错误率的技术和方法。</p>
<p>数据传输中发生的码元差错，都是由噪声引起的。<br>
噪声分为两大类：</p>
<ol type="1">
<li>信道固有的、持续存在的随机热噪声</li>
</ol>
<p>热噪声引起的差错称为“随机错”。<br>
随即错的错误码元往往是单个出现的，不连续。</p>
<p>通常把信道的信噪比设计得很大，来减少随机错，因此随机错占比很少。</p>
<ol start="2" type="1">
<li>来自外界的、短暂突发的冲击噪声</li>
</ol>
<p>冲击噪声引起的差错称为“突发错”。</p>
<p>突发错的错误码元通常是连续出现，因为即使持续时间很短的冲击噪声也会使连续多个码元发生错误。</p>
<p>冲击噪声的幅度可能很大，就无法通过提高信噪比来抑制突发错。</p>
<p>突发长度：<br>
突发错中，错误码元的数量（长度）。</p>
<p>突发错在传输差错中占比很高。</p>
<h2 id="差错检测">4.2.1 差错检测</h2>
<p>差错控制的首要任务：差错检测。</p>
<p>差错检测包含了两个方面：</p>
<ol type="1">
<li><p>差错控制编码（发方）：<br>
发送前，数据位+冗余位，构成“码字”。</p></li>
<li><p>差错校验（收方） 检查数据位和冗余位的关系，从而检测错误。</p></li>
</ol>
<h2 id="差错控制方法">4.2.2 差错控制方法</h2>
<p>利用差错控制编码来进行差错控制的方法：</p>
<p>1.自动请求重发，ARQ，Automatic Repeat reQuest</p>
<p>收方检测到差错，就通知发方重发，直到收到正确的码字为止。</p>
<p>优点：</p>
<ul>
<li>码字的冗余位更少</li>
<li>检错设备较简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>信道必须是双向的。（收方才能通知发方）</li>
<li>发方必须有重发表</li>
</ul>
<p>2.前向纠错，Forward Error Correction, FEC</p>
<p>收方不仅能发现错误，还能确定是错误位的位置，进行纠正。</p>
<p>优点：</p>
<ul>
<li>不要求双向信道，</li>
<li>发方也不需要重发表。</li>
<li>实时性高（不需要重发）</li>
</ul>
<p>缺点：</p>
<ul>
<li>纠错码比检错码的冗余位更多</li>
<li>纠错设备比检错设备复杂。</li>
</ul>
<p>根据ARQ和FEC，差错控制编码也分为了：</p>
<ul>
<li>检错码</li>
<li>纠错码</li>
</ul>
<p>ARQ差错控制方式是主流，某些场合也会混合使用ARQ和FEC方式。<br>
即，如果码字中的错误位数量在纠正能力范围内，则使用FEC进行纠正，否则使用ARQ请求重发。</p>
<p>编码效率：码字中信息位的比例。<br>
设，信息位<span class="math inline">\(k\)</span>位，编码时附加冗余位<span class="math inline">\(r\)</span>位，码字长度为<span class="math inline">\(n=k+r\)</span>位，编码效率<br>
<span class="math inline">\(R = k / (k+r) = k/n\)</span></p>
<p>编码效率R越大，码字传送信息的效率就越高。</p>
<h2 id="奇偶校验码和循环冗余码">4.2.3 奇偶校验码和循环冗余码</h2>
<h3 id="奇偶校验码">1. 奇偶校验码</h3>
<p>奇偶校验码：<br>
增加冗余位，使码字中保持奇数或偶数个1的编码方法。</p>
<p>奇偶校验码是一种检错码。</p>
<p>又可分为：</p>
<ul>
<li>垂直奇偶校验码</li>
<li>水平奇偶校验码</li>
<li>水平垂直奇偶校验码</li>
</ul>
<h4 id="垂直奇偶校验纵向奇偶校验">垂直奇偶校验（纵向奇偶校验）</h4>
<p>信道串行发送若干个码元，表示了 n 个二进制位，每 p 位划分为一个段，共分为 q 段，pq矩阵组成了一个位的数据块。<br>
在每一段后添加一个冗余位，称为垂直奇偶校验。</p>
<p>段的长度通常为一个字符的长度，这种称为字符奇偶校验。</p>
<p>偶校验的编码和检测公式：（+为模2运算）</p>
<p><span class="math display">\[
r_{i} = I_{1i} + I_{2i} + \cdots + I_{pi}
\]</span></p>
<p>奇校验的编码和检测公式：（+ 为模2运算）</p>
<p><span class="math display">\[
r_{i} = I_{1i} + I_{2i} + \cdots + I_{pi} + 1
\]</span></p>
<p>垂直奇偶校验只能检测出奇数个二进制位错误，不能检测偶数个二进制位错误。</p>
<p>突发错误中，奇数位错和偶数位错的发生几率相等，因此垂直奇偶校验的漏检率是 1/2。</p>
<p>垂直奇偶校验还有个优势：发方可以边发边附加冗余位，收方可以边收边校验边去除冗余位。</p>
<p>编码效率：<br>
<span class="math inline">\(R= p/(p+1)\)</span></p>
<h4 id="水平奇偶校验横向奇偶校验">水平奇偶校验（横向奇偶校验）</h4>
<p>同样是 pq 数据块，通过在水平方向（q段）给二进制位附加 1 个冗余位，称为水平奇偶校验。</p>
<p>水平奇偶校验的漏检率比垂直奇偶校验低，它可以检测出两种错误：</p>
<p>1.水平方向上（即各段同一位上），奇数个二进制位错误 这点和垂直奇偶校验是一样的。</p>
<p>2.数据块中一个突发长度 <span class="math inline">\(\le p\)</span> 的突发错。<br>
如果存在突发长度 <span class="math inline">\(\le p\)</span> 的突发错，必然分布在1个或相邻的2个段上，从水平方向来看，这些错误位分布在连续的行上，且不会重叠（包括跨2个段的情况，首尾不会重叠）。<br>
水平奇偶校验码，可以检测出这不重叠的 p 行错误。<br>
但仅限于一个突发错，如果有多个，则可能在水平方向出现偶数个错误位，造成漏检。</p>
<p>水平奇偶校验编码，要求发收双方都有数据缓冲区，在整个数据块发完和收完后才能进行冗余位的附加、检测、去除操作，比垂直奇偶校验码复杂。</p>
<p>编码效率：<br>
<span class="math inline">\(R = q/(q+1)\)</span></p>
<h4 id="水平垂直奇偶校验纵横奇偶校验">水平垂直奇偶校验（纵横奇偶校验）</h4>
<p>同时进行水平奇偶校验和垂直奇偶校验，就构成了水平垂直奇偶校验。</p>
<p>同样是 pq 数据块。水平方向上，在 q 列后增加冗余位，在 p 行上增加冗余位。</p>
<p>编码和检测的计算公式：<br>
假设水平方向和垂直方向都采用偶校验。<br>
水平方向</p>
<p><span class="math display">\[
(i是行号，i=1,2,\cdots,p) \\ 
\\
r_{i,q+1} = I_{i1} + I_{i2} + \cdots + I_{iq}
\]</span></p>
<p>垂直方向</p>
<p><span class="math display">\[
(j是列号， j = 1,2,\cdots,q) \\
\\
r_{p+1,j} = I_{1j} + I_{2j} + \cdots + I_{pj}
\]</span></p>
<p>交叉点：</p>
<p><span class="math display">\[
r_{p+1,q+1} = r_{1,q+1} + r_{2,q+1} + \cdots + r_{p,q+1} + r_{p+1,1}+ r_{p+1,2}+ \cdots + r_{p+1,q}
\]</span></p>
<p>水平垂直奇偶校验能够检测出：</p>
<ul>
<li>3位或3位以下的错误，因为此时至少在某一行或某一列上有一位错</li>
<li>奇数位错：这个可以理解，奇偶校验就是可以检测奇数位错</li>
<li>突发长度 <span class="math inline">\(\leq p+1\)</span> 的突发错：垂直/水平奇偶校验，长度<span class="math inline">\(\leq p\)</span>的突发错可以被检测出来，而在纵横奇偶校验中，可检测的突发长度达到了<span class="math inline">\(p+1\)</span>，p+1的突发错必然跨段，在某一行中形成偶数个错。又因为跨段的最后一个错，可以被第2个段的列检测，所以p+1是允许的。但如果p+2，则第2列出现偶数错，就会漏检，同时第一列也可能无法被检测出来（除非第一列是奇数错）。</li>
<li>部分偶数位错</li>
</ul>
<p>误码率： 经测量，这种方式的误码率可降至原误码率的百分之一到万分之一。</p>
<p>纵横奇偶校验不仅是检错码，某型情况下也可以作为纠错码使用。<br>
比如当整个数据块中只有一个位错误时，可以通过行检错和列检错，确定出行列坐标。</p>
<p>编码效率： <span class="math inline">\(R = pq / ((p+1)(q+1))\)</span></p>
<p>纵横奇偶校验，要求发收双方都有数据缓冲区，在整个数据块发完和收完后才能进行冗余位的附加、检测、去除操作。</p>
<h3 id="循环校验码">2. 循环校验码</h3>
<p>奇偶校验码的漏检率太高，所以通常使用另一种漏检率低、便于实现的循环冗余码CRC（cyclic Redundancy Code)。</p>
<p>循环校验码是一种检错码。</p>
<p>前提条件：</p>
<ol type="1">
<li>任何一个 N 位二进制数，都唯一对应一个 “最高位是 (N-1) 次、系数只可能是0和1的”多项式。 比如： 1010111 对应 <span class="math inline">\(x^6+x^4+x^2+x+1\)</span>，101111 对应 <span class="math inline">\(x^5+x^3+x^2+x+1\)</span></li>
</ol>
<p>具体到校验码中，<br>
<span class="math inline">\(k\)</span>位信息位对应了<span class="math inline">\((k-1)\)</span>次多项式 <span class="math inline">\(K(X)\)</span>，<br>
<span class="math inline">\(r\)</span>位冗余位对应了 <span class="math inline">\((r-1)\)</span>次多项式 <span class="math inline">\(R(X)\)</span><br>
<span class="math inline">\(n=(k+r)\)</span>位码字则对应了 <span class="math inline">\((n-1)\)</span>(即<span class="math inline">\((k+r-1)\)</span> )次多项式 <span class="math inline">\(T(X)\)</span></p>
<p>根据码字的定义，可得： <span class="math inline">\(T(X) = X^r \cdot K(X) + R(X)\)</span></p>
<h6 id="发方如何生成码字">发方如何生成码字</h6>
<p>问题可以简化为：<br>
已知信息位 <span class="math inline">\(K(X)\)</span>，如何求冗余位 <span class="math inline">\(R(X)\)</span> 呢？</p>
<p>需要先了解一下”生成多项式“G(X)。<br>
生成多项式是一个特定的多项式，它的最高项系数恒为1，次数为 <span class="math inline">\(r\)</span>次，收发双方都事先约定了生成多项式。 发方计算 <span class="math inline">\(X^r \cdot K(X) / G(X)\)</span>，余数即冗余位 <span class="math inline">\(R(X)\)</span>。</p>
<p>发方码字 <span class="math inline">\(T_{send}(X) = K(X) + R(X)\)</span></p>
<p>需要说明的是：</p>
<ol type="1">
<li>除法中的减法是模2减：即异或减，不借位。因此除法也称为模2除</li>
<li>模2除中计算余数时“不计算最高位“：被减数和减数的最高位不做减法，不计入余数。</li>
<li>生成多项式 G(X)， 信息位 K(X)，冗余位 R(X) 三者缺一不可。</li>
<li>生成多项式一旦变化，冗余位就立刻变化。</li>
</ol>
<h6 id="收方如何校验码字">收方如何校验码字</h6>
<p>收方校验原理：<br>
计算<span class="math inline">\(T_{rec}(X)/G(X)\)</span> ，若能整除说明传输无差错，若不能整除证明传输有差错。</p>
<p>证明如下：</p>
<p>因为 <span class="math inline">\(X^r \cdot K(X) = G(X) \cdot Q(X)+ R(X)\)</span> ， 其中<span class="math inline">\(Q(X)\)</span> 为商。</p>
<p>又，据模2运算规则可知： <span class="math inline">\(R(X) + R(X) = 0\)</span> 。</p>
<p>因此：<br>
<span class="math inline">\(X^r \cdot K(X) + R(X) = G(X) \cdot Q(X)\)</span></p>
<p><span class="math inline">\((X^r+ R(X))/ G(X) = Q(X)\)</span></p>
<p>最终得到：<br>
<span class="math inline">\(T(X)/G(X) = Q(X)\)</span></p>
<h6 id="crc码也会发生漏检">CRC码也会发生漏检</h6>
<p>当差错模式也能被生成多项式整除时就会漏检。</p>
<p>分析如下：<br>
首先需要知道：</p>
<ol type="1">
<li>发方码字 + 差错模式 = 收方码字</li>
<li>差错模式 = 收方码字 / 生成多项式 说得的余数</li>
<li>差错模式记为E(X)</li>
</ol>
<p>推理如下： 发方码字 <span class="math inline">\(T_{send}(X)=1011001,1010\)</span>，信息位 <span class="math inline">\(K(X)=1011001\)</span>，冗余位 <span class="math inline">\(R(X)=1010\)</span>，传输受到干扰后，收方码字<span class="math inline">\(T_{rec}(X) = 1011001 ,1100\)</span>。</p>
<p>收方校验时无法整除，会得到差错模式<span class="math inline">\(E(X)=0110\)</span>。</p>
<p>此时可以发现，<code>1011001，1010 +  0110 = 1011001，1100</code>，</p>
<p>证明： <span class="math inline">\(T_{send}(X) + E(X) = T_{rec}(X)\)</span></p>
<p>收方验证码字时，</p>
<p><span class="math display">\[
T_{rec}(X) / G(X) = (T(X) + E(X))/G(X) = T(X)/G(X) + E(X)/G(X)
\]</span></p>
<p>如果 <span class="math inline">\(E(X) / G(X) =0\)</span>， 则会发生漏检。</p>
<p>为了降低漏检率，生成多项式<span class="math inline">\(G(X)\)</span>并不是随意选取的，而是需要数学运算得到，常用的CRC码有：</p>
<ul>
<li>CRC12</li>
<li>CRC16(IBM公司)</li>
<li>CRC16(ITU)</li>
<li>CRC32</li>
</ul>
<p>理论证明，CRC码可以检测出下列错误：<br>
1. 所有奇数位错 2. 所有双比特的错 3. 所有小于等于校验位长度的突发错</p>
<p>可以检测哪些错误这部分比较复杂，暂时不管。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第四章 数据链路层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 4.1 数据链路层的功能</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-4-1-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD/%E7%BD%91%E5%8E%9F-4-1-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>物理层传输的数据单位：比特流，数据在传输过程中可能发生各种错误：</p>
<ul>
<li>数据内容错误：比如，受到干扰后，数据内容变化</li>
<li>数据丢失（比如报文交换/数据报的分组交换中，当输入的报文量/分组量超过节点存储容量时，就会丢弃报文/分组）</li>
<li>分组达到信宿的顺序混乱，需要重组</li>
</ul>
<p>数据链路层通过各种手段，把在数据传输上“可能出错”的物理线路，改造成了“逻辑上，无差错的”数据链路。只要经过数据链路层的传输，数据错误、数据丢失、顺序混乱等问题都不存在，网络层收到的数据就是无差错的。</p>
<p>数据链路层的数据单位：帧（Frame)——帧定界符+比特流</p>
<p>数据链路层的主要功能：</p>
<ol type="1">
<li>将“可能出错的”物理层，改造为“逻辑上无差错的”数据链路层。</li>
<li>向网络层提供“透明的”、“可靠的”数据传输服务：<br>
把“源机网络层“发来的数据，可靠的传输到<span style="border-bottom:2px solid red;">相邻节点</span>的“目标机网络层”。（数据链路层并不只作用在信源-信宿之间，而是在“信源-中间节点-信宿”中每一个节点上都存在）</li>
</ol>
<ul>
<li>透明的：可以传输任何数据，而不关心数据语义、语法。</li>
<li>可靠的：保证数据的完整性（正确性、一致性、相容性）。</li>
</ul>
<p>为实现其主要功能，数据链路层需要解决以下问题：</p>
<ul>
<li>如何将比特位和帧定界符组装成帧</li>
<li>如何处理传输差错</li>
<li>如何调节发送速率，以使收发双方速度匹配</li>
<li>在两个网络实体间（信源、信宿、节点），建立、维持、拆除数据链路层</li>
</ul>
<h2 id="帧同步功能">4.1.1 帧同步功能</h2>
<p>Q. 为什么需要帧？<br>
A. 通过帧把比特流划分成片段，出现传输错误时，只需要重传错误所在的帧。</p>
<p>Q. 帧同步是什么？<br>
A. 帧同步就是接收方如何从比特流中识别出帧的起始和结束。只有实现了帧同步，接收方才能对帧进行处理，数据链路层才能够对帧传输进行各种控制、操作。</p>
<p>Q. 实现帧同步的手段<br>
A.</p>
<ul>
<li>收方双方约定固定的时间间隔来确定帧的起始和结束：因为双方的时钟很难保证正确和同步，此法不可行。</li>
<li>对帧的结构进行设计，收方可以从比特流中直接识别出帧的开始和结束。</li>
</ul>
<h3 id="使用字符填充的首尾定界符法">1.使用字符填充的首尾定界符法</h3>
<p>将特定的字符作为帧的定界符。</p>
<p>字符填充法：<br>
转义控制字符+ 帧内数据字符。</p>
<p>缺点： 定界符依赖于字符集，数据没有透明性。<br>
比如 采用unicode 字符集的帧的定界符，和 采用ansi 字符集的帧的定界符可能不同。</p>
<h3 id="使用比特填充的首尾标志法">2. 使用比特填充的首尾标志法</h3>
<p>使用特定的比特位串（或者叫比特模式）作为帧的定界符。</p>
<p>比特填充法：<br>
按照某种规则，发方对帧内的数据位串，添加比特位，以区别于定界符。<br>
收方对帧内的数据比特位，执行逆操作。</p>
<p>比特填充容易由硬件来执行，速度比字符填充法快，而且对数据透明（任何数据都可以用此法）。</p>
<p>HDLC 就采用了比特填充法。</p>
<h3 id="违法编码法">3. 违法编码法</h3>
<p>当物理层采用特殊的编码方法时，可以采用违法编码法。<br>
比如曼彻斯特编码，采用”低-高“电平对表示0，”高-低“电平对表示1。<br>
此时可以采用”高-高“、”低-低“来作为定界符。</p>
<p>优点： 不需要任何填充技术，即可实现数据的透明性。</p>
<p>缺点：<br>
只适用于采用冗余编码（曼彻斯特、差分曼彻斯特等一个比特位由2个电平来表示）的环境。</p>
<h3 id="字节计数法">4. 字节计数法</h3>
<p>以一个特殊字符作为帧的起始位置，再用一个字段标明帧的字节数。<br>
根据起始字符和帧的字节数，即可确定帧的结束位置。</p>
<p>数字数据通信报文协议DDCMP，就采用了字节计数法。</p>
<p>优点：<br>
数据透明。</p>
<p>缺点：<br>
一旦 计数字段 count 出错，会导致帧的结束位置计算错误，造成灾难性的后果。</p>
<p>在实际应用中，多采用 比特填充法、违法编码法。</p>
<h2 id="差错控制功能">4.1.2 差错控制功能</h2>
<p>数据链路层必须具有差错检测的能力，并能够纠正错误。包括以下几种手段：</p>
<h6 id="反馈重发机制确认重传">反馈重发机制（确认重传）</h6>
<p>接收方用差错编码（奇偶校验码、CRC码）检查帧，并反馈给发送方</p>
<ul>
<li>没有错误：发方视该帧发送成功</li>
<li>有错误：发方重发该帧</li>
</ul>
<p>需要注意：<br>
反馈重发机制不等于停等机制，只要有帧编号，发送方可以发送多帧（GoBackN)，甚至根据反馈回来的错误帧的帧号，仅仅重发错误帧（选择重传）。</p>
<h6 id="超时机制">超时机制</h6>
<p>信道中的噪声可能“淹没”一帧，导致发方发出的数据帧/或接方发出的“反馈信息帧”丢失，发送方就始终处于等待接收“反馈信息帧”的状态中，因此必须引入超时机制。</p>
<p>超时机制：<br>
发送方发出数据帧时就启动一个计时器，如果发送方等待反馈帧的时间超过设定上限，视为数据帧发送失败，重发数据帧。</p>
<p>对于确认重传多帧，需要多个计时器来计算超时。</p>
<h6 id="用帧序号来区分重复帧">用帧序号来区分重复帧</h6>
<p>发送方具有重复发送同一帧的能力，接收方就必须具备识别重复帧的能力，否则可能出现向网络层提交重复帧的错误。</p>
<p>发送方在发送数据帧时，就赋予了一个唯一的序号，接收方通过序号就直到是不是收到了重复帧。</p>
<h2 id="流量控制功能">4.1.3 流量控制功能</h2>
<p>Q. 什么叫流量控制？<br>
A. 收发两端工作速率和缓存大小的差异，会导致发送与接收不匹配。接收方只能丢弃来不及接收的帧。流量控制，就是通过某种机制，告知发送方暂停发送，等待通知后再继续发送。</p>
<p>在OSIRM模型中，数据链路层和很多高层协议都提供了流量控制功能，但它们的作用对象不同：</p>
<ul>
<li>数据链路层的流量控制：控制的是相邻节点间的流量。数据链路层是所有节点（信源、信宿、中间节点）共有的，所以数据链路层的流量控制功能遍布网络。 两个节点之间的流量，可能是多个信源到信宿流量的集合，也可能是单个信源到信宿流量的子路径流量。</li>
<li>高层协议的流量控制：比如传输层的流量控制，控制了端到端（信源某端口--信宿某端口）的流量。</li>
</ul>
<h6 id="停止等待机制">停止等待机制</h6>
<p>缓冲存储空间可以缓解发、收双方的传输速率差异，但有两个限制： 1. 缓存空间不可能无限大 2. 如果收发双方速率差异过大，且数据量过大时，再大的缓存也会失效</p>
<p>停等机制解决了此问题。</p>
<p>停等机制： + 发送方发出一帧，就等待接收方的应答信号，收到应答后，再发下一帧 + 接收方收到一帧后就发出应答信号</p>
<p>停止等待机制不等同于确认重传机制，停等是只能一帧一帧的应答，而确认重传机制前面分析过了，可以应答多帧（需要帧号、多个计时器）。</p>
<h6 id="gbn机制允许连续发送多帧滑动窗口机制实现流量控制">GBN机制允许连续发送多帧，滑动窗口机制实现流量控制</h6>
<p>停等机制效率最低，收发双方每次只对一帧进行操作。</p>
<p>为提高信道利用率，引入了重发表机制：<br>
发收双方都设有缓存，允许发方连续发出多帧。</p>
<ul>
<li><p>已发出待确认的帧，备份在发方缓存中，并且缓存中的每一帧都被赋予了一个序号：如果收到确认帧，则从发方缓存中删除该帧；如果超时未收到确认帧（信息帧丢失、出错，确认帧丢失），那么需要重新发送整个发方缓存，因此发方缓存称为“重发表”。</p></li>
<li><p>收到后待检错处理的帧，放入收方缓存。</p></li>
</ul>
<p>但可能出现这种情况：<br>
发方连续发出多帧，收方却不能及时处理，发方缓存会溢出、过载。</p>
<p>因此就需要一种流量控制手段，对发方允许发送的信息帧数量进行控制。<br>
从而引入了滑动窗口机制：</p>
<p>发方</p>
<ol type="1">
<li>每发一帧，就在重发表中备份一份，等待收方的确认帧，同时打开一个发送窗口。</li>
<li>发送窗口的最大数量事先设定（小于重发表），如果发方窗口未满，重复步骤1</li>
<li>如果发方窗口满了，停止发送。</li>
<li>每收到一个确认帧，重发表就删除对应帧，关闭对应帧的窗口，进入步骤2</li>
</ol>
<p>收方</p>
<ol type="1">
<li>在收方缓存中打开一个接收窗口，收方窗口指示了当前等待接收的帧。</li>
<li>信息帧到达后，放入收方缓存，如果序号同收方窗口一致，则关闭收方窗口，重复步骤1，从缓存中删除该帧。</li>
</ol>
<p>需要注意：</p>
<ol type="1">
<li>发方节点和收方节点都有缓存，说明它们之间不是电路交换，只能是分组交换。</li>
<li>而且一定是虚电路交换，分组按顺序到达是实现滑动窗口的前提，如果是数据报交换，数据帧/确认帧都会乱序到达，重发表无法依序删除待确认帧，就无法实现滑动效果。</li>
<li>滑动窗口的大小可以随时调整，从而实现动态改变信道利用率。</li>
</ol>
<p>需要说明：</p>
<ul>
<li>滑动窗口、停止等待只是机制，具体实现要靠特定的协议</li>
<li>协议是软件，是可选的，换句话说，流量控制不是数据链路层必须的功能，如果安装了协议，就能控制，不安装就不能。</li>
</ul>
<h2 id="链路管理功能">4.1.4 链路管理功能</h2>
<p>链路管理包括两个方面：</p>
<ol type="1">
<li>如果信源和信宿采用面向连接的服务进行通信，那么数据链路层还需要负责建立、维持、释放链路，这就是链路管理功能。</li>
<li>多个站点共享同一物理信道（比如环形网，树形网），在站点间分配、管理信道。</li>
</ol>
<p>todo：<br>
链路管理这个还是讲得太粗浅，大致理解是建立逻辑链路，还需要深入的了解。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第四章 数据链路层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 3.5 数据交换技术</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-3-5-%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF/%E7%BD%91%E5%8E%9F-3-5-%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="数据交换技术">3.5 数据交换技术</h1>
<p>信源和信宿之间需要中间节点。<br>
中间节点只负责传输数据（提供交换功能），而不关心数据内容。</p>
<p>交换： 英文switch，本意指开关，节点通过拨动开关来建立不同信源信宿之间的通信路径，中文翻译为交换。</p>
<p>信源信宿称为网络站。</p>
<p>中间节点的集合称为通信网络。</p>
<h2 id="电路交换">3.5.1 电路交换</h2>
<p>传输的数据单位：二进制位流</p>
<p>利用信源、信宿、节点建立专用物理连接（电路）来传输数据。</p>
<p>专用物理线路允许复用：<br>
通过TDM或FDM把物理线路划分成多个信道，占用某个作为专用信道。</p>
<p>电路交换技术需要三个步骤：</p>
<ol type="1">
<li>建立电路：通过呼叫请求，信源与信宿建立物理的电路连接。</li>
<li>数据传输：传输数据时，电路保持连接。</li>
<li>拆除电路：信源或信宿发出拆除请求，逐节拆除到对方。</li>
</ol>
<p>优点：</p>
<ul>
<li>数据传输可靠、迅速</li>
<li>数据不会丢失</li>
<li>数据保持了原来的序列</li>
<li>节点转发速度很快：节点是个电子的或机电结合的交换设备，不具有存储能力，不使用“存储-转发”方式，而是”即收即发“——收到数据后即刻发送出去。</li>
</ul>
<p>缺点：</p>
<ul>
<li>传输空闲时造成信道浪费</li>
<li>如果传输的数据量小，建立和拆除电路就浪费时间</li>
</ul>
<p>电路交换适用于：时延要求低、数据量大的高质量数据传输场景。</p>
<h2 id="报文交换">3.5.2 报文交换</h2>
<p>传输的数据单位：报文</p>
<p>报文：Message，本次通信中，需要发送的全部数据，长度不限。</p>
<p>对于突发性、随机长度（尤其是小数据量）的数据，电路交换显得太笨重，于是出现了报文交换。</p>
<p>报文交换：</p>
<ul>
<li>无需建立专用通路：报文上有目的地址，各节点根据地址转发数据</li>
<li>节点采用存储-转发方式：节点是计算机，存储收到的完整报文，再根据路由找到下一个节点转发出去。</li>
</ul>
<p><strong>报文在节点的延迟时间 = 接收报文所需时间（包括检查、存储的时间） + 转发前的排队时间</strong></p>
<p>优点：</p>
<ul>
<li>信道带宽要求低，信道利用率高：多个报文可以“分时共享”信道（类似于时分多路复用，但又不同，分时共享允许<span style="border-bottom:2px solid red;">完整的报文</span>在某个时间片独占信道，而非TDM中由<span style="border-bottom:2px solid red;">二进制位流的片段</span>在某个时间片独占信道）。</li>
<li>报文的输入量理论上没有上限：假设节点具有无限的存储能力，报文增多只会增大排队时间。而电路交换就有输入数据量的上限（即使信道复用，信道数量也有上限）。</li>
<li>支持多播：一个报文可以发送给多个目的地。而电路交换只能单播。</li>
<li>不同传输速率的节点可以互连：电路交换中，相同传输速率的节点才能相连</li>
<li>通信子网可以转换编码：节点可以转换报文的编码</li>
</ul>
<p>缺点：</p>
<ul>
<li>不适合实时通信、交互式通信：因为报文在节点的延迟时间较长且不定<br>
</li>
<li>报文输入量过大，节点没有存储空间时，就会丢弃报文：数据会丢失<br>
</li>
<li>因为延迟的存在，报文不按发出的先后顺序达到目的地。</li>
</ul>
<h2 id="分组交换">3.5.3 分组交换</h2>
<div style="border-style:none none none solid;border-color:#2196F3;border-width:10px;background-color:#DDFFFF ">
分组：把报文分成有有限长度的小段，每个小段称为分组。
</div>
<p>每个分组由数据+目的地址构成。</p>
<p>优点：<br>
+ 有限长度的分组，转发速度更快：节点将分组缓存入内存而不是硬盘，提高了读写速度，也就提高了转发速度</p>
<p>分组交换分为：虚电路、数据报</p>
<p>需要注意：<br>
不要把虚电路等同于TCP，数据报等同于UDP。因为虚电路交换、数据报交换只是一种机制，而TCP/UDP属于具体实现，也可以由其他协议来实现虚电路/数据报，只是目前的实现是TCP/UDP。</p>
<h6 id="虚电路">1. 虚电路</h6>
<p>传输的数据单位：虚电路分组</p>
<p>虚电路分组：<br>
每个分组中有一个虚电路标识符。</p>
<ul>
<li>建立虚电路：信源发出”呼叫请求分组“，各节点将请求分组路由给信宿，信宿回复”呼叫接收分组“，各节点将接收分组路由给信源，逻辑通路建立成功。逻辑通路也称为虚电路，是一条预先建立好的路径。</li>
<li>传输数据：节点根据<span class="math inline">\(\underline{虚电路标识符}\)</span>转发分组，不再需要路由选择，转发速度更快。</li>
<li>拆除虚电路：信源或信宿向对方发出”清除请求分组“来拆除虚电路。</li>
</ul>
<p><strong>信源与信宿之间可建立多条虚电路</strong><br>
当两个网络站之间有多个进程进行通信时，每对进程都可以建立自己的虚电路，这些虚电路的路径可能不同也可能相同。<br>
1对1，但路径多条。</p>
<p><strong>信源可以同时与多个信宿建立虚电路.</strong><br>
1对多。</p>
<p><strong>虚电路和实电路的区别</strong><br>
虚电路并不是信源和信宿之间的专用信道，任何分组都可以通过这个信道。<br>
信道上可能同时存在多条虚电路，甚至存在数据报传输。<br>
虚电路的分组在每个节点上仍然需要缓存和排队，和数据报分组唯一的不同是：不需要路由判定，节点根据分组内的虚电路标识符即可确定下一个转发节点。</p>
<p>而实电路就是占用了一条专用信道，其他二进制位不得通过该信道——即使目前空闲。</p>
<p>虚电路优点：</p>
<ul>
<li>适合长时间的通信，尤其是交互式会话（每次数据量都很小）</li>
<li>节省了每个分组附加目的地址的开销，</li>
<li>更可靠的传输：不会丢失分组</li>
<li>分组到达信宿的顺序不变</li>
<li>可以对流量进行控制</li>
</ul>
<p>缺点：当某个节点、链路出现故障时，所有经过该点的虚电路都失效。</p>
<h6 id="数据报">2. 数据报</h6>
<p>传输的数据单位：数据报分组，简称数据报。</p>
<p>数据报：<br>
每个分组携带了一个目的地址。</p>
<ul>
<li>信源把报文拆分成数据报：给每个分组附加目的地址，发送出去</li>
<li>中间节点根据路由信息存储-转发数据报</li>
<li>各数据报可能走不同的路径，可能丢失，不按先后顺序抵达目的地</li>
<li>信宿需要重新组装数据报才能得到完整的报文</li>
</ul>
<p>优点：</p>
<ul>
<li>省去了建立、拆除虚电路过程</li>
<li>传输少量数据时比虚电路灵活</li>
<li>可以绕开故障节点继续传输</li>
</ul>
<p>缺点：</p>
<ul>
<li>分组不能按序到达</li>
<li>分组丢失不能立刻察觉</li>
</ul>
<h2 id="高速交换">3.5.4 高速交换</h2>
<h3 id="电光结合">电光结合</h3>
<p>todo: 什么叫：电路交换的用户与WDM之间的流量力度不匹配问题</p>
<p>当把光纤作为传输媒介时，带宽不再是瓶颈。<br>
高速交换：主干线路采用电路交换，融入光传输技术，本地网络采用分组交换。</p>
<p>理论上：</p>
<ul>
<li>电路交换技术的缺陷：中间节点和线路利用率低，节点或线路故障时传输可靠性为0<br>
</li>
<li>分组交换技术具有优势：通过路由选路可以提高中间节点和线路的利用率（尤其是某条路径带宽有限时），节点或线路故障时通过重新选路，大大提高传输可靠性。</li>
</ul>
<p>但现状是：通过分组交换提高中间节点和线路的利用率，故障时提高传输可靠性，是没有意义的。</p>
<ul>
<li>很多线路没有接入交换机也就无法被选路利用，真正可以被路由的线路不到10%。<br>
</li>
<li>路由器（中间节点）几乎不发生故障，重新选路的实际意义几乎没有。</li>
</ul>
<p>同时，分组交换还有弊端：<br>
当采用数据报的分组交换方式时，实时性的业务往往无法满足（分组丢失、不按顺序到达等）。</p>
<p>而电路交换技术的优势很明显：<br>
+ 面向连接，适用于实时业务。<br>
+ 实现简单：铺设光纤即可 + 不需要缓存：易于与光技术结合</p>
<p>最终实现：</p>
<ul>
<li>主干线路采用电路交换：比如同步光纤SONET、同步数字系列SDH，传输光信号。</li>
<li>本地网络采用分组交换：IP路由器，传输电信号</li>
<li>主干和本地之间需要：电光转换设备，其体积巨大且昂贵，</li>
</ul>
<h3 id="全光交换">全光交换</h3>
<p>采用全光交换就需要使用光交换设备。</p>
<p>光交换技术：<br>
1. 微电子机械系统的光交换机 MEMS 微型镜子组成的阵列，通过旋转角度，把入射光纤反射到出射光纤。</p>
<ol start="2" type="1">
<li><p>无交换式光路由器 不明白</p></li>
<li><p>阵列波导光栅路由器 不懂</p></li>
</ol>
<p>光交换的优点：<br>
+ 不需要光电转换，速度提高 + 光交换的技术费用，不随着接入端口的带宽增加而增大，传统交换技术就要受到影响 + 对比特率和调制方式透明，可以提高交换单元的吞吐量：不懂</p>
<h2 id="交换技术的比较">3.5.5 交换技术的比较</h2>
<p>这段基本上没有新内容，属于总结。</p>
<p>但有些描述似乎有错误：<br>
不同的交换技术适用于不同的场合：</p>
<ul>
<li><p>对于交互式通信来说，报文交换肯定是不适合的</p></li>
<li><p>对于较轻和间歇式的负载来说，电路交换是最合适的</p></li>
</ul>
<p>报文交换、分组交换才适合这种间歇的、突发的小数据量通信。</p>
<ul>
<li><p>对于较重和持续的负载来说，使用租用的线路以电路交换方式是合适的</p></li>
<li><p>对于必须交换中等到大量数据的情况，可用分组交换方法 这主要是从带宽来说，因为分组交换会调用全网的资源来分担负载，而如果用电路交换，就只能使用单一线路的带宽。</p></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第三章 物理层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 3.4 数据编码</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-3-4-%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/%E7%BD%91%E5%8E%9F-3-4-%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="数据编码技术">3.4.1 数据编码技术</h2>
<h3 id="数字数据的数字信号编码">1. 数字数据的数字信号编码</h3>
<h4 id="基带和频带">1.基带和频带</h4>
<p>Q.基带是什么？<br>
A.基带就是基本频带，指不经调制（频谱搬移和变换）的原始脉冲信号所固有的频率带。</p>
<p>基带传输<br>
利用基本频带（也就是利用原始脉冲信号）传输数据，就称为基带传输。</p>
<p>基带信号<br>
基带信号就是“直接表达了要传输的信息”的信号，比如我们说话的声波就是基带信号。</p>
<p>基带传输适用于近距离传输<br>
由于在近距离范围内基带信号的衰减不大，信号内容不会发生变化。因此在传输距离较近时，计算机网络都采用基带传输方式。<br>
如<br>
从计算机到监视器、打印机等外设号就是基带传输。<br>
大多数的局域网使用基带传输，如以太网、令牌环网。常见的网络设计标准10BaseT使用的就是基带信号。</p>
<p>基带信号的特点：速率高、误码率低</p>
<p>Q. 什么是频带？<br>
A. 基带信号调制后的信号，占用的频率带宽，称为频带。</p>
<p>频带信号可以抗干扰、提高传输率，但速率慢、误码率高。</p>
<p>频带传输，主要用于网络电视和有线电视的视频广播。</p>
<p>本节只讲基带。<br>
基带传输时，需要解决两个问题： + 数字数据的数字信号表示 + 收发两端的同步问题</p>
<h4 id="数字数据的数字信号表示">2.数字数据的数字信号表示</h4>
<p>最简单的办法：用不同的电平来表示两个二进制数字。</p>
<h5 id="不归零码全宽码">不归零码（全宽码）</h5>
<p>NRZ码，Non-Return-to-Zero Code.</p>
<p>优点：<br>
因为每个脉冲不归零，不需要传输归零后的零电平，节约了传输带宽。</p>
<p>缺点：<br>
脉冲之间没有间隔，不易识别区分，需要用某种方法使发送器和接收器之间进行定时或同步。</p>
<p>全宽码<br>
脉冲时间内，高电平（或正负电平）占据整个脉冲宽度，不会回到零电平。</p>
<h6 id="单极性不归零码">单极性不归零码</h6>
<ul>
<li>高电平代表逻辑1</li>
<li>零电平代表逻辑0</li>
</ul>
<img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/20190616165930095_2652.gif">
<h6 id="双极性不归零码">双极性不归零码</h6>
<ul>
<li>正电平代表逻辑1</li>
<li>负电平代表逻辑0</li>
</ul>
<img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/20190616165859380_12338.gif">
<h5 id="归零码">归零码</h5>
<p>RZ码，Return-to-Zero Code</p>
<p>波形特征：<br>
脉冲之间有零电平间隔，而且脉冲可以很窄，脉冲间隔可以大于窄脉冲的宽度。</p>
<p>优点：<br>
+ 具有自同步特性，或者叫自带时钟信号。在每个窄脉冲归零之后，信号读取者即可读取数值，不需要另外的时钟信号。</p>
<p>缺点：<br>
+ 大部分的数据带宽（产生脉冲信号的信号线，实质上就是传输数据的数据线），都用于传输“零电平”，浪费传输带宽。 + 因为 <span class="math inline">\(\frac{1}{脉宽} = 传输带宽\)</span>，所以窄脉冲占用的频带就较宽。</p>
<h6 id="单极性归零码">单极性归零码</h6>
<ul>
<li>高电平代表逻辑1</li>
<li>零电平代表逻辑0</li>
<li>脉冲时间内会回到零电平（窄脉冲）</li>
</ul>
<img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/20190616162310645_17552.gif">
<h6 id="双极性归零码">双极性归零码</h6>
<ul>
<li>正电平代表逻辑1</li>
<li>负电平代表逻辑0</li>
<li>脉冲时间内会回到零电平（窄脉冲）</li>
</ul>
<p>信号线上会出现3种电平： + 正电平 + 负电平 + 零电平</p>
<img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/RZcode.png">
<h5 id="单极性码和双极性码的比较">单极性码和双极性码的比较</h5>
<ul>
<li>单极性码会积累直流分量，无法在通信设备和周围环境之间用变压器做良好绝缘的交流耦合。直流分量会损坏连接点的电镀层。</li>
<li>双极性码的直流分量可以忽略，有利于数据传输。</li>
</ul>
<h5 id="不归零翻转码或称反向不归零编码">不归零翻转码（或称反向不归零编码）</h5>
<p>NRZI, Non-Return-to-Zero Inverted Code.</p>
<ul>
<li>电平的高低翻转（高-&gt;低，低-&gt;高，），表示一个逻辑值</li>
<li>电平不变，表示另一个逻辑值</li>
<li>全宽码</li>
</ul>
<p>USB 2.0传输就采用了NRZI码：<br>
+ 电平翻转代表0， + 电平不变代表1。</p>
<p>NRZI码的特点：<br>
即使整个脉冲波形完全翻转，也表示了相同的数据。</p>
<img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/20190701141949127_25773.png">
<h5 id="曼彻斯特编码">曼彻斯特编码</h5>
<ul>
<li>双极性码</li>
<li>每个脉冲的中间有一个正负电平的跳变</li>
<li>正-&gt;负，表示0</li>
<li>负-&gt;正，表示1</li>
</ul>
<p>曼彻斯特编码常用于局域网中。</p>
<h5 id="差分曼彻斯特编码">差分曼彻斯特编码</h5>
<ul>
<li>双极性码</li>
<li>脉冲开头有跳变（不论方向），表示0</li>
<li>脉冲开头无跳变（不论方向），表示1</li>
<li>脉冲中间必有跳变（时钟信号）</li>
</ul>
<p>差分曼彻斯特编码比曼彻斯特编码的变化更少，是对前者的改进，广泛的用于宽带高速网中。</p>
<img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/20190701141342452_27213.gif">
<h4 id="收发两端的同步问题">2.收发两端的同步问题</h4>
<p>Q. 同步是什么？<br>
A. 串行通信中，收发双方统一时钟、频率等相关物理量的过程，称为同步。</p>
<p>同步包括：</p>
<ol type="1">
<li>尺子(脉宽）：双方统一脉宽，脉宽= 1 / 脉冲频率，因此也称为频率同步。</li>
<li>时间(时钟)：频率统一后，双方的时钟必须一致，否则会出错。</li>
<li>数据起点(起始位、帧头）：双方必须从同一起点测量数据线上电平的变化。</li>
<li>数据终点(终止位、帧尾)：让收方知道数据何时结束。</li>
</ol>
<p>电平信号的传输速度接近光速，因此发方发出一个信号，收方几乎同时收到。</p>
<p>假设要发送以下数据：12，23，34，45，56，67，78，89。<br>
收方就必须知道数据什么时候开始发送，什么时候结束等信息，否则，可能会将数据接收成22，33，44，55，66，77，88。</p>
<p>同步方法主要有： ##### 1. 位同步法（同步传输） 对于每一位数据，收方都要和发方保持同步。</p>
<p>实现位同步的方法，分为： ###### 外同步（专门的同步脉冲，帧头/帧尾，帧包含了多个字符或较长的位流） + 发方先发同步脉冲（帧头），再发数据（字符/位流），最后发帧尾。<br>
+ 收方根据同步脉冲计算出：频率（脉宽）、数据起点等同步信息。<br>
+ 收方与发方在帧头处同步，之后开始接收数据， + 如果帧的字符数或比特数过大，发收双方可能无法保持同步，但可以在帧尾再次同步。</p>
<h6 id="自同步数据脉冲自带同步信息">自同步（数据脉冲自带同步信息）</h6>
<ul>
<li>收方从数据信号中提取同步信号。<br>
</li>
<li>每一个码元都是同步的。</li>
</ul>
<p>比如：<br>
曼彻斯特编码：<br>
每一个脉冲中间有一个电平跳变，这就是时钟信号，从高-&gt;低跳变表示1，从低-&gt;高跳变表示0。<br>
跳变既是时钟信号，又是数据信号。</p>
<p>差分曼彻斯特编码：<br>
每个脉冲中间的电平跳变提供时钟信号。<br>
根据脉冲开头有无跳变来决定数据是0还是1。<br>
同样，中间跳变是时钟信号，开头跳变是数据。</p>
<p>勘误：<br>
&gt; 曼彻斯特编码和差分曼彻斯特编码的每一个码元都被调制成两个电平，所以数据传输速率只有调制速率的1/2。</p>
<p>这句话是错误的：<br>
波特率：即调制速率，单位时间内传输码元符号的个数（传符号率）。<br>
以曼彻斯特编码为例，每个中间跳变（从高到低/从低到高）的脉冲都只是一个符号，只能视为一个码元。<br>
而不是 电平数/单位时间。 数据传输速率：每个码元符号代表的二进制位数 * 波特率。也称为信息传输速率（传信率）。</p>
<p>对于同步通讯协议，发送方在发送数据之前先发出一个特殊的电信号，让接收方准备好接收数据，然后发送方就将以上数据全部连续发出，发送完毕后，再发送一个特殊的电信号表示数据发送结束。我们可以用下图表示同步信号通讯。 <code>开始 1223344556677889 结束</code> 然后，接收方按照事先约定，即每两位一个数值，将数据包分成一个个数值。</p>
<h5 id="群同步法异步传输每次传输一个字符也称为起止式传输">2. 群同步法（异步传输，每次传输一个字符，也称为“起止式传输”）</h5>
<ul>
<li>以“群”为单位发送数据，通常一个群就是一个字符（5~8个比特位）。<br>
</li>
<li>群前加起始位，群后加终止位。起始位+群的字符位+终止位 = 一个字节。<br>
</li>
<li>群的间隔时间任意，此期间，收方和发方可能不同步，也无需同步。</li>
<li>群内，收方以一个固定的频率接收比特位(严格来说，收方与发方不可能完全同步，但对于一个字符这么短的数据流来说，可以视为同步）</li>
</ul>
<p>对于异步通讯协议，发送方每发送一个数据都要发一“开始”标志，每个数据发送结束后都发出一个“结束”标志。<br>
用下图表示异步通讯信号： <code>开始 12 结束 开始 23 结束 开始 34 结束 ...</code></p>
<p>因此，对于发送方发送数据的时间不确定的情况，适合采用异步通讯。</p>
<p>同步传输和异步传输的比较：<br>
+同步传输的编码效率较高，信道利用率高，适合高速传输 + 异步传输的编码效率较低，信道利用率低，适合低速传输</p>
<p>需要说明一下：<br>
教材上说的同步和异步，和正常的理解存在偏差。</p>
<p>一般人的理解：<br>
+ 收发双方根据同步信号校准，称为同步。比如曼彻斯特编码、差分曼彻斯特编码。 + 通过帧头/起始位，双方实现同步后，按照自己的时钟各自发/收数据，直到遇到帧尾或终止位，这段时间内的传输应该叫异步，因为可能出现双方不同步的情况。</p>
<p>但教材的理解是：<br>
+ 收发双方根据同步信号校准后，就一直处于同步状态。同步传输中的外同步“接收端按照这一时钟的脉冲频率和时序锁定接收端的接收频率”，以及异步传输中的“字符中比特之间的同步定时”就是这么来的。 + 而没有同步信号的时间段内，称为异步。群同步中的”字符间的异步定时和......“就属于这种。</p>
<p>网上看到的另一种对同步、异步的解释： 我们看最典型的SPI、I2C，这两种方式都有一个专用的CLK信号线。<br>
发方产生一个CLK信号，通过CLK信号线传给收方方，收方根据CLK信号与发方同步：<br>
+ CLK的宽度就是一个数据位的宽度，<br>
+ CLK的上升或下降沿就是“起点”标志。 这种在通信过程中有CLK线专门传送同步信号的方式，就是同步通信。</p>
<p>同步通信由于有专用的CLK线控制，通信双方比较容易实现“同步”，速度比较快。</p>
<p>但是对于长距离的通信，同步方式就不行了：<br>
1. 需要专门一个信号线，成本提高。<br>
2. 通信线越长，干扰就越多，通信的速度也上不去。<br>
因此同步方式多是同一PCB板上芯片级之间的通信使用。</p>
<p>而长距离通信多使用“异步”通信方式，这里的“异步”不是指通信双方不需要同步，而是指双方不使用专用的同步信号线传送CLK，而是各自仅依赖于自己的系统时钟（这个就是异步的！），再根据约定的规程，调节自己的“步伐”达到双方的同步。</p>
<h3 id="模拟数据的数字信号编码">2. 模拟数据的数字信号编码</h3>
<h4 id="采样定理">采样定理</h4>
<p>模拟信号转换成数字信号，通常采用脉码调制PCM（Pulse Code Modulation）的方式。</p>
<p>PCM的数学原理是采样定理：<br>
只要采样频率大于等于模拟信号的最高频率，或模拟信号带宽的两倍，采样值就可以包含原始信号的全部信息。 以数学形式表示如下<br>
<span class="math inline">\(F_{d}\)</span>：数字信号采样频率， <span class="math inline">\(F_{a-min}\)</span>：模拟信号的最低频率， <span class="math inline">\(F_{a-max}\)</span>：模拟信号的最高频率，<br>
<span class="math inline">\(H_{a} = F_{a-max} - F_{a-min}\)</span>：模拟信号的带宽</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
F_{d} \ge 2 \cdot H_{a}  \\
\\ F_{d} \ge  F_{a-max}
\end{aligned}
\end{equation}
\]</span></p>
<h4 id="发送端模拟信号转为数字信号">发送端，模拟信号转为数字信号</h4>
<ol type="1">
<li><p>采样 以采样频率<span class="math inline">\(F_{d}\)</span>采样模拟信号，得到时间轴上各模拟量的值。</p></li>
<li><p>量化 把模拟信号的波幅划分为多个离散的量级（2的N次方），把采到的模拟量“取整”归入各个量级。</p></li>
<li><p>编码 将离散值写作2进制形式，从而将模拟值转换成数字值。</p></li>
</ol>
<p>如果有N个量化级，则每一个采样值将使用 <span class="math inline">\(log_{2}{N}\)</span> 个二进制位。<br>
每一个采样后得到的二进制码组称为“码字”，二进制位数 <span class="math inline">\(log_{2}{N}\)</span> 称为字长。</p>
<h4 id="接收端数字信号转为模拟信号">接收端，数字信号转为模拟信号</h4>
<p>把收到的每一个码字，转换为对应量级的脉冲，得到数字脉冲形态的“波形”。<br>
最后采用低通滤波得到模拟信号（只允许脉冲的峰值电平通过）。</p>
<p>数字信号的优点： 1. 抗干扰性强<br>
模拟信号的有用信号，与噪声混合后，难以再分开，信噪比会降低。<br>
数字信号也会受到噪声干扰，但只要原始低电平叠加噪声后仍低于判决门限电平，或原始高电平叠加后仍高于判决门限电平，则信号不会受到影响。 2. 保密性好<br>
数字信号的二进制序列 <span class="math inline">\(I_{(t)}\)</span>，数字密码机产生二进制密码序列<span class="math inline">\(C_{(t)}\)</span>，对两者进行“模2加”运算，得到传输序列<span class="math inline">\(B_{(t)}\)</span>。 只要密码序列不被人知道，原始数字信号序列的内容就无法得知。<br>
而且密码序列可以随时变换，保密性大大增强。</p>
<h2 id="调制解调器">3.4.2 调制解调器</h2>
<h3 id="电话系统介绍">电话系统介绍</h3>
<h4 id="电话系统的组成">电话系统的组成</h4>
<ol start="0" type="1">
<li>计算机</li>
<li>计算机到调制解调器的数字线路：比如RS-232C接口</li>
<li>调制解调器</li>
<li><p>本地回路：从调制解调器到端局的双线本地回路，常称为“最后一公里”，但实际长度可能几公里。 本地回路通常采用双绞线，传输模拟信号。</p></li>
<li>端局：编解码器(CODEC），有用于切换电话的交换设备</li>
<li>端局到长途局的干线：中带宽数字线路</li>
<li>长途局：有用于切换电话的交换设备</li>
<li><p>长途局之间的干线：高带宽数字线路</p></li>
</ol>
<h4 id="电话系统的信号传输与转换过程">电话系统的信号传输与转换过程：</h4>
<ol type="1">
<li>计算机产生数字信号，通过信源的调制解调器MDOEM转换成模拟信号，传输到端局<br>
</li>
<li>端局的编解码器CODEC，将模拟信号转换为数字信号，通过光纤等数字信道传输到长途局</li>
<li>长途局将数字信号，通过光纤传给目的地端局，</li>
<li>目的地端局通过CODEC，将数字信号转为模拟信号，发给目的地MODEM</li>
<li>目的地MODEM将模拟信号，转为数字信号，发给目的地计算机。</li>
</ol>
<h4 id="传输线路的问题">传输线路的问题</h4>
<p>传输线路存在3个问题： + 衰减：衰减就是信号传输时损失能量的现象，可表示为“多少分贝/公里”。波是由很多不同频率的傅里叶分量构成的，衰减量的多少与傅里叶分量的频率有关，因此信号传输中不同频率的傅里叶分量发生程度不同的衰减后，会导致波形变化。 + 延迟畸变：不同的傅里叶分量的传输速度不同，会导致波形变化。 + 噪声：线路中电子的随机运动，会造成热噪声。相距太近的线路的感应耦合会引起串音。尖峰干扰等原因会引起脉冲噪声。脉冲噪声可能会淹没几位数据。</p>
<p><em>淹没：本应是低电平的脉冲，混合噪声后成为高电平。</em></p>
<p>因此，发出的信号和收到的信号往往不会完全一致。</p>
<h5 id="模拟用户线路的调制解调器">1. 模拟用户线路的调制解调器</h5>
<p>标题应该简化为：模拟线路的调制解调器，之所以叫用户线路是因为从计算机到调制解调器这段线路往往由用户购置建设，且物理上位于用户户内。</p>
<p>衰减和延迟畸变与信号频率有关，而数字信号的方波有一个很宽的频谱，其衰减和延迟畸变会很严重。因此，数字信号采用基带传输并不合适，除非是低速、短距离情况下。</p>
<p>数字信号不采用基带传输，又应该怎么传输呢？<br>
在模拟线路上（比如电话线），可以用调制的办法将数字信号转为模拟信号。</p>
<p>首先采用一个1Khz~2Khz的正弦波载波，再使用不同的调制方法得到调制信号：<br>
+ 调幅（AM,Amplitude Modulation)<br>
用两种不同的振幅来表示0和1。</p>
<ul>
<li>调频(FM,Frequency Modulation) 将波调制为两种频率，来表示0和1。</li>
</ul>
<p>调频也称为移频键控（Shift Keying）,键控Keying 是工业界使用的术语，是调制Modulation的同义词。</p>
<ul>
<li>调相(Phase Modulation) 每一个码元，用载波的不同相位来表示不同的逻辑值。</li>
</ul>
<p>比如：<br>
用90°和180°相位来表示0和1。（90°相位就是正方向的最大振幅，180°相位是0振幅）</p>
<p>更好的方案是采用45°、135°、225°、315°相位，从而每一个码元表示2位二进制数。</p>
<h6 id="调制解调器-1">调制解调器</h6>
<div style="border:2px dashed #000;">
<p>调制解调器的定义：<br><br>
输入<span style="border-bottom:2px solid red;">位序列</span>，输出<span class="math inline">\(\underline{调幅、调频、调相的调制载波}\)</span>的设备（或者输入输出相反的设备）。</p>
</div>
<p>MODEM位于<span class="math inline">\(\underline{\textrm{数字信源（计算机）}}\)</span>和<span class="math inline">\(\underline{模拟线路（电话线路）}\)</span>之间。</p>
<p>我们知道，波特是码元速率、调制速率，表示了每秒钟有多少个码元在线路上传输，时信号传输速率。<br>
同时，波特表示了调制解调器的采样率（每秒钟采样生成多少个码元）。</p>
<p>需要说明一下：<br>
码元不单止脉冲，调制得到的符号都叫码元，比如调制得到的模拟波。<br>
模拟信号转数字信号，有采样、量化、编码3个步骤。数字信号通过调制解调器转为模拟信号，也有采样过程，通过控制采样率，可以得到数量不同的调制码元。</p>
<p>结论:<br>
线路的波特率=调制解调器的采样率。</p>
<h6 id="提高模拟信道数据传输速率r的办法">提高模拟信道数据传输速率R的办法</h6>
<p>提高采样率的作用有限，<br>
提高码元代表的二进制位数的作用无限。</p>
<p>推导如下：<br>
根据奈奎斯特定理<span class="math inline">\(B=2 \cdot H\)</span>可知，一条信道的最大波特率只有其带宽的2倍。</p>
<p>因此：调制解调器的采样率超过线路带宽的2倍后，就无法继续提高数据传输速率了。</p>
<p>要进一步提高数据传输速率，根据奈奎斯特公式（即理想信道的容量）<span class="math inline">\(C=B \cdot log_{2}{N}\)</span>可知：<br>
只有提高每一个码元表示的二进制位数。</p>
<p>比如：<br>
（调幅）用2种电压表示1位二进制数，扩展为用4种电压表示2位二进制数。 （调相）用4个相位表示2位二进制数，称为正交相移键控（QPSK,Quadrature Phrase Shift Keying）。</p>
<h6 id="星座图">星座图</h6>
<p>实际应用中，调制解调器会综合运用多种调制方法来实现“一个码元表达多个二进制位”。<br>
通常是把调幅AM和调相PM结合起来。</p>
<p>调幅和调相结合的调制方式可以用星座图来表示：<br>
+ 点到原点（0，0）的距离，是该点在信号波上的振幅。<br>
+ 点到原点的直线，与正向X轴（0,0出发到+∞,0)的夹角，就是相位角。 + 一个点就是一个码元可能表示的状态</p>
<img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/20190710141825287_26967.png">
<ol type="1">
<li>QPSK(Quadrature Phrase Shift Keying)，正交相移键控 4个点，每个码元表示2位二进制数。</li>
</ol>
<p>P.S. 移频键控(Frequency Shift Keying)</p>
<ol start="2" type="1">
<li><p>QAM-16(Quardrature Amplitude Modulation)，正交振幅调制 16个点，每个码元可以表示4位二进制数。</p></li>
<li><p>QAM-64 64个点，每个码元可以表示6位二进制数。</p></li>
</ol>
<h6 id="星座模型的纠错机制">星座模型的纠错机制</h6>
<p>传输中的噪声会导致模拟信号的相位、振幅发生变化，接收方的调制解调器会收到错误的模拟信号，转化为数字信号后，在星座图中成为位置错误的点。<br>
星座图的点越多越密集，即使很小的噪声也容易导致这种点位错误。</p>
<p>而每一个点位错误在二进制码中对应了多个二进制位出现错误。</p>
<p>为解决此问题引入了纠错机制：<br>
在发送方将数字信号转化为模拟信号时，就对数字信号的二进制形式附加额外的二进制用于纠错。</p>
<p>随着数字信号的二进制串的变长，原本只需要N个点即可表示的星座图，就需要N+X个点来表示。 举例说明：<br>
V.32调制解调器标准<br>
每个码元传输4个数据位和1个奇偶校验位。<br>
原来4个数据位只需要<span class="math inline">\(2^4=16\)</span>个点，现在使用了<span class="math inline">\(2^{(4+1)}=32\)</span>个点。 QAM-32，</p>
<p>注意：在计算数据传输速率时，只计算数据位，不考虑纠错位。</p>
<p>假设 B=2400 Baud ，则数据传输速率R等于<br>
<span class="math inline">\(R=2400 \cdot log_{2}{16}=9600 bps\)</span></p>
<div style="border:2px dashed #5DAF0E;">
V.32bis调制解调器标准
</div>
<p>每个码元传输6个数据位和1个奇偶校验位，最终使用128个点，QAM-128。</p>
<p>数据传输速率 2400 * 6 = 14400 bps<br>
传真机就使用此速度传输位图。</p>
<p>V.34调制解调器<br>
每个码元传输12个数据位，1个奇偶校验位，最终使用8192个点。QAM-8192。 数据传输速率 2400 * 12 = 28800 bps</p>
<p>V.34bis调制解调器<br>
每个码元传输14个数据位，1个奇偶校验位，最终使用 32768个点。QAM-32768。<br>
数据传输速率 2400 * 14 = 33600 bps</p>
<img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/20190711112458850_24221.png">
<p>上图的点，绕着原点逆时针旋转了45°，是出于工程的需要。旋转的星座图具有相同的数据传输能力。</p>
<h6 id="两个本地回路模拟信道的最大容量35kbps标准调制解调器最大数据传输速度33.6kbps">两个本地回路模拟信道的最大容量35Kbps，标准调制解调器最大数据传输速度33.6Kbps</h6>
<p>标准调制解调器的数据传输速度，最大是33.6kbps。</p>
<p>这是由传输信道（电话系统）的物理特性（带宽）决定的，根据香农定理可以计算出电话系统的信道容量是35kbps，这个速度与本地回路的平均长度、线路的质量有关。</p>
<img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/20190710163912154_11781.png">
<ol type="1">
<li><p>两个计算机通信时，两个本地回路（计算机连接的调制解调器 -- 端局的编码解码器）都传输模拟信号，模拟信号比数字信号更容易受到信道噪声干扰的影响。如果去掉一个本地回路，则噪声影响减少一半，信道容量提高一倍。<br>
通过计算，两个计算机通过调制解调器相互通信的最大数据传输率是35Kbps。</p></li>
<li><p>单个计算机和ISP通信时，ISP和端局之间使用光纤传输数字信号，没有调制解调器，没有模拟信道，光纤受到噪音干扰的影响可以视为0，相当于去掉了一个本地回路，此时的数据传输速率最大可达到70Kbps。</p></li>
</ol>
<h6 id="如何突破35kbps的信道容量">如何突破35Kbps的信道容量</h6>
<p>为了进一步提高模拟线路的数据传输速率，可以采用：</p>
<ul>
<li><p>传输压缩过的数据，实际的MODEM数据传输速率仍然是33.6Kbps，但压缩后的数据传输速率会高于33.6Kbps</p></li>
<li><p>提高采样率，电话信道的带宽大约是4000Hz，最大采样率（波特率）可以达到8000Hz。</p></li>
</ul>
<div style="border:1px dashed #000;">
V.90 调制解调器
</div>
<p>在美洲，每个码元有7个数据位+1个控制位，最终的数据传输速率：<br>
<span class="math inline">\(R= 2 \cdot 4000 \cdot log_{2}{128} = 56000 bps\)</span> 。</p>
<p>在欧洲，每个码元有8个数据位，数据传输速率：<br>
<span class="math inline">\(R= 2 \cdot 4000 \cdot log_{2}{256} = 64000 bps\)</span> 。</p>
<p>为了统一，国际标准最终确定为56000bps，这种调制解调器标准称为 V.90。</p>
<p>在V.90标准中，上行的数据传输速率是33.6Kbps（用户计算机到ISP），下行的数据传输速率是56Kbps（ISP到用户计算机）。因为下行数据量远大于上行数据量。</p>
<div style="border:2px dashed #5DAF0E;">
V.92调制解调器
</div>
<p>在V.90基础上，把上行数据传输率增大到了48Kbps。</p>
<h5 id="数字用户线路xdsl">2.数字用户线路（xDSL)</h5>
<p>调制解调器可以提供最大56Kbps的数据传输速率，但同时期的有线电视（10Mbps）、卫星公司（50Mbps）可以提供非常高速的数据传输服务，电话公司不得不推出更有竞争力的产品：宽带（Broad Band）。</p>
<p>宽带：利用本地回路，提供比传统调制解调器更大的带宽。</p>
<h6 id="传统电话线路为语音而生宽带为数据而生">传统电话线路为语音而生，宽带为数据而生</h6>
<p>传统电话线路，是为传输语音信号而设计，因此在端局设立了一个滤波器，滤掉了300Hz~3400Hz的信号，使本地回路带宽限制在3100Hz的宽度（常被当做4000Hz来使用）。</p>
<p>而数字用户线路（xDSL，Digital Subscriber Line）去掉了滤波器，充分发挥了本地回路的全部带宽（大约1.1Mhz)。</p>
<p>本地回路的带宽取决于：<br>
+ 长度 + 粗细 + 线路质量</p>
<p>xDSL带宽与距离成反比 <img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/20190712162223352_30893.png"></p>
<p>上图说明：带宽以端局为圆心，本地回路的带宽随半径而降低。</p>
<h6 id="dsl利用频分多路复用实现设计目标">DSL利用频分多路复用实现设计目标</h6>
<p>xDSL服务的设计目标：<br>
1. 必须在现有的本地回路上工作 2. 不影响传统的电话和传真机 3. 比56Kbps快 4. 采用月租收费，而不是时长收费</p>
<p>通过频分多路复用可以实现设计目标。<br>
以最常见的ADSL为例，它采用了“分离式多信道调制DMT（Discrete MultiTone)”的频带划分方法，将本地回路上的频谱分为三个频带： 1. POTS（Plain Old Telephone Service，简单老式电话服务） 2. 上行数据流（用户到端局） 3. 下行数据流（端局到用户）</p>
<img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/20190712162612394_6279.png">
<p>将1.1Mhz的信道划分成256条独立信道，每条信道4312.5Hz： + 信道0传输电话信号POTS + 信道1~5不传输数据，用于隔离保护 + 1条用于上行控制， + 1条用于下行控制， + 248条信道用于传输用户数据</p>
<p>理论上，248条信道都可以作为全双工信道，但实际传输会受到各种影响而达不到理论性能，因此都只作为单工信道使用。<br>
又因为上行和下行数据量的不同，ISP通常将多数信道用作下行，少数信道用作上行。这就是非对称的由来。</p>
<p>常见的作法是：32条用于上行，216条用于下行。</p>
<h6 id="adsl标准">ADSL标准</h6>
<p>ADSL标准允许的速度：下行速度 8Mbps ，上行速度 1Mbps。</p>
<p>但通常ISP提供的速度远低于ADSL标准： + 普通：512Kbps下行，64Kbps上行 + 高级：1Mbps下行，256Kbps上行</p>
<p>在DMT划分的每条信道中，调制方案类似于V.34：<br>
+ 采样率不是2400 Baud，而是4000 Baud。 + 每条信道采用QAM-32768调制，每个波特可以表示15位二进制数据， + ADSL会监视每条信道的线路质量，随时调整信道的数据传输速率</p>
<p>假设有224条下行信道，每条信道4000Baud，每个波特传输15位二进制数据。则理论下行带宽为13.44Mbps。 实际中，可能达到8Mbps的下行数据传输率。</p>
<h6 id="adsl的部署结构">ADSL的部署结构</h6>
<p>ADSL的部署结构有两种：</p>
<ol type="1">
<li>带网络接口设备NID和分离器Splitter 用户家中： 需要安装NID和分离器。<br>
分离器将POTS信号分离出来，路由给电话机和传真机，并把数据信号分离并路由到ADSL调制解调器中。<br>
ADSL调制解调器本质上是一组传统调制解调器，每个都工作在不同频率的信道上。</li>
</ol>
<p>端局：<br>
也需要安装分离器。<br>
语音信号被分离并路由到语音交换机。<br>
数字信号被路由到数字用户线路访问复用器（DSLAM,Digital Subscriber Line Access Multiplexer）。<br>
DSLAM类似于ADSL调制解调器，将模拟信号解调为数字信号，发送给ISP。</p>
<img src="/2019/12/01/网原-3-4-数据编码/网原-3-4-数据编码/20190712173538351_2608.png">
<ol start="2" type="1">
<li>不带NID和分离器（非正式名称 G.lite) 在电话插孔中放置了低通滤波器，消除了数据。<br>
ADSL调制解调器中放置了高通滤波器，消除了语音信号。</li>
</ol>
<p>缺点：可靠性不如方式1，数据传输速率只能达到 1.5Mbps。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第三章 物理层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 3.0 通信基础知识</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-3-0-%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BD%91%E5%8E%9F-3-0-%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h4 id="电平是什么">电平是什么</h4>
<p>电平：是指两个功率、电压的比值的对数（以10为底）。<br>
(偶尔也指两个电流之比的对数）</p>
<p>电平的单位是分贝(dB)。</p>
<p>使用对数表示两个物理量之比有好处：<br>
1.读写、计算方便。<br>
如多级放大器的总放大倍数，为各级放大倍数相乘。用对数表示，则直接把各级放大倍数相加即可。 2. 能如实地反映人对这些物理量的感受。实践证明，声音的分贝数增加或减少一倍，人耳听觉响度也提高或降低一倍。即人耳听觉与两个声音功率的比值的对数（分贝数）成正比。例如蚊子叫声与大炮响声相差1000000倍，但人的感觉仅有60倍的差异，因为10lg(1000000)=60dB。</p>
<h4 id="逻辑电平高电平低电平">逻辑电平（高电平、低电平）</h4>
<p>逻辑电平是指一种表示逻辑信号（1，0）的电路状态，通常由信号线与地线之间的电位差来体现。</p>
<p>高电平低电平主要应用于数字电路。体现在电路上就是‘有’和‘无’，没有中间值。<br>
（这个“有”在不同的电路上对应的电压值并不相同）</p>
<p>如果是5V供电的数字电路，高电平就是5V，或接近5V。</p>
<p>低电平就是‘无’，就是0V或接近0V。</p>
<h4 id="nrznrzi的采样频率同步问题">NRZ,NRZI的采样频率、同步问题</h4>
<p>NRZ,NRZI不带有自同步特性： + 发送者发送数据后，接受者如何知道脉冲宽度是多少时间？ + 发送者和接受者的时钟如何保持一致？</p>
<p>解决办法： + 另外发送一个时钟信号 + 利用同步头和信号高低电平变化随时校正接受者时钟</p>
<p>同步头：<br>
发送者先发送一个同步头，接受者通过这个同步头计算出发送者的频率（脉冲总时间 / 脉冲数量 = 每个脉冲占据的时间宽度），之后就采用这个频率来采样实际数据信号。</p>
<p>比如：<br>
对于NRZ编码，发送0101010的方波。<br>
USB传输中的每个USB 数据包，开头都有个同步域，固定为00000001，经过NRZI编码后，得到一串方波，接受者计算这个方波的频率后即可用于采样。</p>
<p>在实际的数据传输中，可能会遇到以下问题： + 收发双方时钟不同步：比如发送者的时钟正常，接受者的时钟快或者慢，就会影响采样结果。 + 同步头发送出现故障，导致计算结果有误。<br>
+ 同步头频率计算除不尽，致使接受者的采样时间有误差 解决办法：接受者利用信号的电平变化，随时校正自己的时钟，去掉时钟误差。</p>
<h4 id="模拟数据数字数据模拟信号数字信号模拟信道数字信道">模拟数据/数字数据、模拟信号/数字信号，模拟信道/数字信道</h4>
<p>数据和信号不同：<br>
数据是具有语义的原始信息，信号是通信线路上传输的光电特性。</p>
<ul>
<li>模拟数据：由传感器采集得到的连续变化的值，例如温度、压力，以及目前在电话、无线电和电视广播中的声音和图像。</li>
<li>数字数据：模拟数据经人为量化后得到的离散的值，例如在计算机中用二进制代码表示的字符、图形、音频与视频数据。</li>
</ul>
<p>不论何种数据，必须被调制为信号才能传输，而信号又分为： + 模拟信号(Analog Signal)：连续变化的电磁波(无线电与电视广播中的电磁波)，或电压信号(电话传输中的音频电压信号)； + 数字信号(Digital Signal)：断续变化的电压脉冲，或光脉冲。</p>
<p>模拟信道和数字信道：<br>
传输模拟信号的信道称为模拟信道，传输数字信号的信道称为数字信道。</p>
<p>但实际上，几乎所有的信道既可以传输模拟信号，也可以传输数字信号。<br>
因为模拟信号和数字信号的确定，与接收者的采样频率有关系。<br>
+ 如果采样频率非常高，即使传输的是模拟信号，也可以将其转换为数字信号（一个波形被切分成多个高低电平，代表了多个数字）， + 如果采样频率非常低，数字信号也可以转变成模拟信号（多个脉冲形成了连续的波形变化）。</p>
<p>P.S. 光纤，大多数时候传输数字信号（光的闪烁），某些时候也可以利用光的波长来传输模拟信号。</p>
<h4 id="带宽">带宽</h4>
<p>1）带宽：某个较高频率，与，某个较低频率的差值，称为频带宽度，简称带宽/频宽。单位赫兹（Hz).</p>
<p>2）信号的带宽：信号波所占用的频宽（模拟信号的波、数字信号的脉冲都有频率）。</p>
<p>3）传输介质的带宽：允许“通行”的信号的频宽。它应该比放行信号的带宽更宽，信号才能顺利通过，否则就会产生失真。</p>
<p>注意：<br>
有时候会误以为脉冲的电平幅度、模拟信号波的振幅占据的幅度宽度就是频率带宽，这是错误的认识，频率宽带和脉冲的电平、波的振幅是两个东西，不要混淆。</p>
<h3 id="相位">相位</h3>
<p><a href="https://zhuanlan.zhihu.com/p/69582734" target="_blank" rel="noopener">相位调制基础</a></p>
<p>正弦载波是信号的基础，其瞬时振幅先正向移动然后负向移动，在一个完整周期后返回到起始点 - 遵循正弦波的曲线。</p>
<img src="/2019/12/01/网原-3-0-通信基础知识/网原-3-0-通信基础知识/v2-53208c837fa1cf5cf12376d2337d9a8a_hd.jpg">
<p>正弦波也可以表示为：<br>
“以正弦波振幅为半径的圆”上移动的一个点，它在垂直方向的幅度（Y轴）和时间（X轴）的关系的函数曲线。</p>
<p>任意点的相位：<br>
圆的起点（0°）和该点在圆上位置之间的夹角角度。</p>
<img src="/2019/12/01/网原-3-0-通信基础知识/网原-3-0-通信基础知识/20190708164228894_20064.jpg">
<p>正弦波上任意两点具有相位差。</p>
<img src="/2019/12/01/网原-3-0-通信基础知识/网原-3-0-通信基础知识/20190708164304365_18568.jpg">
<p>相位调制：将信号调制为不同的相位，来表示不同的信息。</p>
<p>相位调制的本质：<br>
在极短时间内增大了正弦波的频率，使圆上的点快速移动到需要的相位上，从而实现所谓的相位瞬间跳变。</p>
<img src="/2019/12/01/网原-3-0-通信基础知识/网原-3-0-通信基础知识/20190708164332291_10914.jpg">
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第三章 物理层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 3.3 数据通信技术</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-3-3-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/%E7%BD%91%E5%8E%9F-3-3-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h4 id="通信信道">3.3.1 通信信道</h4>
<h5 id="数据传输速率-r">数据传输速率 R</h5>
<p>数据传输速率：每秒钟传输的二进制位数。单位 bps。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">R = \frac&#123;1&#125;&#123;T&#125; log_&#123;2&#125;N</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>R表示Rate。</p>
<p>T是一个脉冲的宽度（即脉冲在时间轴上占据的宽度，单位秒）。<span class="math inline">\(\frac{1}{T}\)</span>就是脉冲波的频率，也是后文要讲的码元传输速率B。</p>
<p><em>码元，本质上是一个脉冲信号。<br>
因为脉冲的高低电平状态可以表示N进制数字——即某种码，而它又是信号的最小单元，因此称为码元。</em></p>
<p>N是一个码元能够表达的离散值个数，通常是2的整数次方。<br>
比如：</p>
<ul>
<li>N=2，电平对应的值可能是 0 1</li>
<li>N=4，电平对应的值可能是 0 1 2 3</li>
<li>N=8，电平对应的值可能是 0 1 2 3 4 5 6 7</li>
</ul>
<p>码元的离散值个数 N ，实际上是电平的N种高低状态，也称为“调制电平数”。 <img src="/2019/12/01/网原-3-3-数据通信技术/网原-3-3-数据通信技术/20190617121225131_8118.jpg"></p>
<p><span class="math inline">\(log_{2}N\)</span> 的含义：一个码元表示的二进制数，的位数。</p>
<p>比如</p>
<ul>
<li>N=2，一个码元能表达1位二进制数<br>
</li>
<li>N=4，能够表达2位二进制数<br>
</li>
<li>N=8，能够表达3位二进制数</li>
</ul>
<h5 id="信号传输速率-b">信号传输速率 B</h5>
<p>信号传输速率：单位时间内，通过信道的码元个数。单位是波特（Baud，简写为B）。</p>
<p>信号传输速率，从本质上讲，是原始数据经过调制成为信道上的码元后，码元的传输速率。</p>
<p>假设码元宽度为 T秒，则信号传输速率为：</p>
<p><span class="math display">\[
B = \frac{1}{T} 
\]</span></p>
<p>信号传输速率也称为“码元速率”、“调制速率”、“波特率”。</p>
<h4 id="数据传输速率与信号传输速率的关系">数据传输速率与信号传输速率的关系</h4>
<p><span class="math display">\[
R = B \times log_{2}N
\]</span></p>
<p>在某些调幅和调频的调制解调器中，一个码元只能表达2种离散值，N=2，<span class="math inline">\(R=\frac{1}{T} \times log_{2}2= B\)</span>，此时，数据传输速率 R = 信号传输速率 B 。</p>
<p>在调相的4相信号方式中，一个码元对应了两个二进制位，N=4，<span class="math inline">\(R= \frac{1}{T} \times log_{2}4 = B \times 2\)</span></p>
<h4 id="信道容量">信道容量</h4>
<p>信道容量：信道的最大数据传输速率。单位 bps。</p>
<ul>
<li>信道容量描述了：信道的极限数据传输速率。<br>
</li>
<li>数据传输速率描述了：信道中某时点实际的数据传输速率。</li>
</ul>
<h6 id="信道的最大信号传输速率">信道的最大信号传输速率</h6>
<p>带宽H是信道的物理特性（单位Hz），物理信道一旦被生产出来，带宽就确定了。<br>
<span class="math inline">\(H=f2 - f1\)</span> ，<br>
f2是信道能够通过的最高频率，f1是信道能够通过的最低频率。</p>
<p>在“无噪声”情况下，信道的最高码元速率 B 是信道带宽 H 的两倍：</p>
<p><span class="math display">\[  
B = 2 \cdot H
\]</span></p>
<p>此公式打通了模拟世界与数字世界。</p>
<h6 id="奈奎斯特公式无噪声下的信道容量">奈奎斯特公式：无噪声下的信道容量</h6>
<p>根据数据传输速率公式，可以推导出信道容量，即奈奎斯特公式：</p>
<p><span class="math display">\[
C = B \cdot log_{2}{N} = 2 \cdot H \cdot log_{2}{N}
\]</span></p>
<p>C是信道容量，单位 bps。</p>
<p>信道的带宽H是无法改变的物理特性，要提高信道容量C，只能提高码元代表的离散值的个数N。</p>
<h6 id="香农公式有噪声下的信道容量">香农公式：有噪声下的信道容量</h6>
<p>实际的信道，会受到随机噪声的干扰。此时，信道容量：</p>
<p><span class="math display">\[ 
C = H \cdot log_{2}{(1+S/N)}
\]</span></p>
<p>S是信号的功率，N是噪声的功率，S/N是信噪比。</p>
<p>因为信噪比 S/N 通常都很大，为了方便书写和阅读，往往将信噪比 S/N 书写成分贝形式，</p>
<p><em>分贝：两个功率之比的对数。</em> <em>对数，为了更方便的表示、计算大数值而发明。</em></p>
<p>即：<br>
S/N 写做 <span class="math inline">\(10 \cdot log_{10}{(S/N)}\)</span></p>
<p>因此，在计算有噪声干扰的信道容量时，如果信噪比 S/N 采用分贝表示，则需要先计算S/N的值。<br>
比如：带宽为5KHz，信噪比为60分贝，信道容量计算如下： 首先，<span class="math inline">\(10 \times log_{10}{(S/N)} = 60(dB)\)</span>，<br>
计算出 S/N = <span class="math inline">\(10^{(60/10)}\)</span></p>
<p>，最后再计算信道容量<br>
<span class="math inline">\(C=5000 \cdot log_{2}{(1+1000000)} = 99657.85006009246814572889 (bps)\)</span> 。</p>
<p>由香农公式可知，只要提高信噪比 S/N，就可以提高信道容量。</p>
<h4 id="误码率">误码率</h4>
<p>误码率<span class="math inline">\(P_e\)</span>：数据传输中，比特位出现错误的概率。</p>
<p><span class="math display">\[
P_e = N_e / N
\]</span></p>
<h4 id="通信方式">通信方式</h4>
<p>计算机内部各部件之间、计算机与外设之间、计算机与计算机之间的数据交换，都是以通信的方式完成的。</p>
<p>通信方式分为： ###### 1. 并行通信 多根数据线连接发送设备和接收设备，数据的N个二进制位在N条数据线上并行发送，接收设备同时收到这些二进制位，无需转换直接使用。</p>
<ul>
<li>传输速度快，处理简单。适合于近距离传输。</li>
<li>远距离传输时，线缆费用太高</li>
</ul>
<h6 id="串行通信">2. 串行通信</h6>
<p>发送设备和接收设备之间只有一根连接线，发送设备通过“并-串转换硬件”先将并行的N位数据转换成串行方式，在线路上逐位传输，接收设备再将串行数据转换为并行方式。</p>
<ul>
<li>传输速度慢，处理较复杂</li>
<li>远距离传输时，可以利用现有的电话网络，线缆建设费用少。</li>
</ul>
<h6 id="串行通信的方向性结构">串行通信的方向性结构</h6>
<p>串行通信根据数据传输的方向性可以分为： + 单工：只能在一个方向传输数据 + 半双工：可以在两个方向传输，但在某个时点，只能单个方向传输 + 全双工：可以同时在两个方向传输数据。</p>
<h4 id="模拟数据通信和数字数据通信">模拟数据通信和数字数据通信</h4>
<h6 id="基本术语">基本术语</h6>
<ol type="1">
<li>数据：反映了事物的存在形式。<br>
分为</li>
</ol>
<ul>
<li>模拟数据：在某个区间内连续变化的值。比如温度、压力。模拟数据是时间的函数，并占有了一定的频率范围——频带，比如声音数据的频率范围是20Hz~20KHz。</li>
<li>数字数据：离散的值，比如整数、文字。</li>
</ul>
<ol start="2" type="1">
<li>信号：数据的电子、电磁、光特性形式的编码。</li>
</ol>
<ul>
<li>模拟信号：利用随时间连续变化的电流、电压、电磁波的某一参量（幅度、频率、相位）来表示数据。</li>
<li>数字信号：利用离散的电脉冲来表示数据。</li>
</ul>
<ol start="3" type="1">
<li><p>信息：数据的含义，或者说如何解读这些数据。</p></li>
<li><p>信源：产生和发送信息的设备。</p></li>
<li><p>信宿：接收和处理信息的设备。</p></li>
<li><p>信道：信源和信宿之间的通信线路。</p></li>
</ol>
<h6 id="模拟数据数字数据可以任意转换为模拟信号数字信号">模拟数据/数字数据，可以任意转换为模拟信号/数字信号</h6>
<p>无论信源产生的是模拟数据还是数字数据，最终都要转换成信号，才能在信道上传输。<br>
模拟数据和数字数据，都可以随意转换成模拟信号或数字信号。</p>
<p>模拟数据可以直接用模拟信号来表示：<br>
比如：电话系统将语音数据的频带(300Hz~3400Hz)，直接映射为信道上相同频带的电信号。</p>
<p>模拟数据也可以用数字信号来表示：<br>
发送方通过编码解码器CODEC(Coder Decoder)，将语音模拟数据编码转换成二进制位流近似表示的数字信号。接收方通过CODEC将数字信号解码成模拟数据。</p>
<p>数字数据可以用模拟信号来表示：<br>
通过调制解调器MODEM（Modulater Demodulater)，将数字数据调制成模拟信号。<br>
接收方通过MODEM将模拟信号解调成数字数据。</p>
<p>数字数据可以用数字信号来表示： 数字数据可以直接用二进制形式的数字脉冲信号来表示。但为了改善传播特性，一般会对二进制原始数据再编码。</p>
<h6 id="信号的衰减放大器和中继器">信号的衰减，放大器和中继器</h6>
<p>模拟信号经过一段距离的传输后会发生衰减，需要使用放大器来增强信号，但放大器也会增大噪音，引起信号畸变。 对某些模拟信号，一定程度的畸变是可以接受的。</p>
<p>数字信号的传输距离是有限的，超出范围后，电平信号就无法识别，接收方会认为没有信号，直接影响数据的完整性。此时需要使用中继器，将衰减的电平信号恢复到正常值，从而增大传输距离。</p>
<p>对于数字信号，传输中发生的畸变会直接影响数据的正确性，可以通过检错、纠错手段解决。</p>
<p>数字传输在价格、质量方面，都比模拟传输优秀。</p>
<h4 id="多路复用技术">3.3.3 多路复用技术</h4>
<p>多路复用技术：<br>
物理信道的带宽（模拟信道）或容量（数字信道）通常远超过传输一路信号的带宽需求，为了提高通信线路的利用率，将多路信号组合起来同时传输，这就是多路复用技术。</p>
<h6 id="频分多路复用fdmfrequency-division-multiplexing">1.频分多路复用（FDM，Frequency Division Multiplexing)</h6>
<p>频分多路复用主要用于模拟信道。</p>
<p>当物理信道的带宽超过传输单路信号的带宽需求时（“带宽”表明是模拟信道），可以将物理信道的总带宽划分成多个“<u>子信道</u> ”，每个子信道的带宽等于或略大于<span style="border-bottom:2px dashed red;">传输单路信号所需的带宽</span>，每个子信道传输单路信号。</p>
<p>P.S. 带宽是频率范围。因此，频分多路复用就是把物理信道的总频率带划分成了多个频率带。</p>
<p>在实际应用中，多路复用器（MUX）把多路信号调制到多个不同的载波频率上，每个信号占用一个以它的载波频率为中心的子信道，每个子信道之间还有不使用的频谱区——保护带，避免干扰，这就是频谱搬移技术。</p>
<h6 id="时分多路复用tdmtime-division-multiplexing">2.时分多路复用（TDM，Time Division Multiplexing)</h6>
<p>时分多路复用主要用于数字信道。</p>
<p>当物理信道的信道容量大于单路信号的数据传输速率时，就可以采用时分多路复用技术。 解释：<br>
一般情况下，单个脉冲的有效离散值N=2（一个脉冲仅代表一个二进制位），当信道容量C 大于 单路信号的数据传输速率R时，说明单位时间内的脉冲密度还可以提高，这就是TDM的实现基础。</p>
<p>时分多路复用技术：<br>
把物理信道划分成多个时间片，轮流分配给多路信号使用，从而在一条物理线路上传输多路数字信号。每一个时间片内可以传输一个二进制位，也可以传输一个字节、或者更大的比特组合。</p>
<ul>
<li>同步时分多路复用：预先划分好固定长度的时间片。</li>
<li>异步时分多路复用：动态划分长度不定的时间片。</li>
</ul>
<p>宽带局域网中，可以混用：频分多路复用FDM + 时分多路复用TDM ：<br>
物理信道上先用频分多路复用FDM划分出子信道，子信道中采用时分多路复用TDM交替传输多路信号。</p>
<p>注意：<br>
Mbps和bps的转换，是1000，而不是1024。</p>
<h6 id="波分多路复用wdmwavelength-division-multiplexing">3.波分多路复用（WDM,Wavelength Division Multiplexing)</h6>
<p>波分多路复用运用于光纤。</p>
<p>光，就是一种极高频率的波。频率不同，则波长不同（频率和波长成反比）、颜色不同。</p>
<p>波分多路复用，就是光纤上的频分多路复用技术：<br>
多路光信号，由组合器(combiner)汇聚到一条主干光纤，通过频谱搬移技术分布在不同频率的子信道中，同时传输到主干光纤的另一头。<br>
另一头的分离器把光信号分配到多条目的地子光纤中。<br>
每条子光纤上的过滤器可以过滤出特定频率的光，从而得到某路原始光信号。</p>
<h4 id="异步传输和同步传输">3.3.4 异步传输和同步传输</h4>
<p>通信过程中，收发双方需要在多个方面保持同步： 1. 时间同步：双方的时间必须一致</p>
<ol start="2" type="1">
<li>时钟同步：时钟就是频率，将收发双方视作两块手表，当时间调到相同以后，只有秒针跳动的频率保持一致，才可能一直保持时间同步。</li>
</ol>
<p>时间同步和时钟同步，是通信的重要基础条件，比如在时分多路复用中，如果发方和收方的时钟不同步，则接收方会采集到错误的数据。</p>
<ol start="3" type="1">
<li><p>码元同步：也称为位同步。<br>
码元同步用于保证收、发端的主时钟频率相同。<br>
码元同步的方法过于专业，就不讲了。</p></li>
<li>由码元组成的“字符、数据块”的起止同步： ###### 异步传输 也称为“群同步传输“，</li>
</ol>
<ul>
<li>发送方一次只发送一个字符（5<sub>8二进制组成，假设一个码元可以取的有效离散值N=2,那么就是5</sub>8个码元）。</li>
<li>每个字符都有一个起始位、一个停止位。<br>
</li>
<li>不发送字符时，发送方就连续的发送停止位。<br>
</li>
<li>接收方根据起始位来判断字符流中新字符的开始，然后接收字符中的所有位，直到停止位。</li>
</ul>
<p>特点：<br>
+ 发送方可以在任何时刻发送字符，而接收方不直到字符会在什么时候达到，只能根据起始位和停止位来判断。 + 实现比较简单 + 每个字符都带上了同步信息——起始位，而且字符位流的长度短（5~8位），收发两端的时钟误差几乎没有。 + 缺点是位开销较大：每个字符会消耗掉2~3个比特位作为起始位和停止位。</p>
<p>假设，每8个比特要多传送2个比特，总的传输负载就增加25%。<br>
对于数据传输量很小的低速设备来说问题不大，但对于那些数据传输量很大的高速设备来说，25%的负载增值就相当严重了。因此，异步传输常用于低速设备。</p>
<h6 id="同步传输">同步传输</h6>
<p>同步传输是给数据块加上帧头和帧尾，它们合在一起称为一帧（Frame）。</p>
<p>帧头的作用： + 接收方通过帧头来得知有数据过来了，和异步传输中的起始位相同 + 接收方通过帧头计算出采样频率，与发送方同步时间和时钟，最终收发双方进入同步。</p>
<p>同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。另外，同步传输的开销也比较少。例如，一个典型的帧可能有500字节（即4000比特）的数据，其中可能只包含100比特的开销。这时，增加的比特位使传输的比特总数增加2.5%，这与异步传输中25 %的增值要小得多。随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。</p>
<p>3， 区别 同步传输方式中发送方和接收方的时钟是统一的、字符与字符间的传输是同步无间隔的。同步传输要求发送方和接收方的时钟频率必须严格一致。具体表现在收发双方在硬件上的时钟端是连接在一起的。 异步传输方式并不要求发送方和接收方的时钟完全一样，字符与字符间的传输是异步的，即字符间相隔的时间是不固定的，数据传输是通过起止位来同步的，但字符中每一个bit的时间间隔必须是相同的。双方的时钟不需要严格同步，即使有百分之几的差异(差异不能太大)也可以保证数据的可靠传输。在硬件上收发双方没有时钟端相连。</p>
<p>在具体实现上，根据数据块是字符还是“位序列”，帧头和帧尾有所不同：<br>
1. 数据块是字符，称为面向字符： + 每个数据块以一个同步字符作为起始（同步字符称为SYN）。<br>
+ 帧头和帧尾都具有唯一的位模式，与数据的位模式完全不同。<br>
+ 接收方根据帧头、帧尾即可判别字符的开始和结束。</p>
<ol start="2" type="1">
<li>数据块是不定长的位流，称为面向位序列：<br>
</li>
</ol>
<ul>
<li>内部的数据块不是字符，而是任意长度、任意排列组合的位流。</li>
<li>帧头和帧尾规定为特殊的模式：01111110</li>
<li>发送方，内部数据位一旦出现5个1，就添加一位0，从而避免和帧头帧尾混淆</li>
<li>接收方，一旦接收到5个1，就看下一位，如果是0，就删掉，如果是1，就表示是帧头或帧尾，从而实现同步。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第三章 物理层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 3.2 传输介质</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-3-2-%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8/%E7%BD%91%E5%8E%9F-3-2-%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8/</url>
    <content><![CDATA[<p>传输介质：通信子网中，发送方和接收方之间的物理通路。</p>
<p>传输介质分为： + 有线传输介质：双绞线、同轴电缆、光纤 + 无线传输介质：无线电通信、微波通信、红外通信、激光通信。</p>
<p>传输介质的特性： + 物理特性：传输介质的物理性质。 + 传输特性：信号形式（模拟、数字）、调制技术、传输速率、频带宽度等。 + 连通性：点到点连接，还是多点连接。 + 地理范围：节点间的最大距离。 + 抗干扰性：抵抗噪音、电磁干扰对传输影响的能力。 + 相对价格：元件、安装、维护的价格</p>
<h4 id="双绞线">3.2.1 双绞线</h4>
<p>物理特性：<br>
双绞线：2根、4根、8根绝缘线螺旋状扭在一起，减少相互间的辐射电磁干扰。</p>
<p>传输特性：<br>
双绞线既可传输模拟信号，也可传输数字信号。</p>
<p>地理范围：<br>
模拟信号，每隔5~6公里，需要一个放大器。<br>
数字信号，每2~3公里，需要一个中继器。</p>
<p>抗干扰性：<br>
双绞线分为： + 无屏蔽：UTP，易受外部电磁场干扰，价格便宜。 + 有屏蔽：STP，抗干扰性强，价格较贵。</p>
<h4 id="同轴电缆">3.2.2 同轴电缆</h4>
<p>物理特性：<br>
同轴电缆由一对“同轴”导体（内芯、屏蔽层）构成。 结构从内向外：内芯、绝缘层、屏蔽层、塑料外套。</p>
<p>传输特性：<br>
同轴电缆分为： + 基带同轴电缆：(又分为粗缆、细缆) 传输数字信号。</p>
<ul>
<li>宽带同轴电缆：比如闭路电视的CATV电缆 传输模拟信号，和数字信号。
<ul>
<li>利用频分多路复用，传输模拟信号</li>
<li>不利用频分多路复用技术，传输数字信号、模拟信号</li>
</ul></li>
</ul>
<p>连通性：<br>
+ 点到点连接 + 多点连接。</p>
<p>地理范围：<br>
+ 基带电缆，细缆最大距离在几公里，粗缆的传输距离更长。<br>
+ 宽带电缆，可达几十公里。</p>
<p>抗干扰性能：比双绞线强。 价格：比双绞线贵，但比光纤便宜。</p>
<h4 id="光纤">3.2.3 光纤</h4>
<h6 id="物理特性">物理特性</h6>
<p>光纤：超细石英玻璃纤维 + 保护层 构成。</p>
<p>多条光纤组合成一条光缆。</p>
<h6 id="传输特性">传输特性</h6>
<p>传输过程：<br>
电信号---&gt;驱动器----&gt;光源-------光纤上传输-------&gt;光检测器----&gt;放大器---&gt;电信号</p>
<p>光源：产生光信号的设备。通常是发光二极管。<br>
光源可分为： + 发光二极管：光的方向性差 + 注入型激光二极管：激光的方向性好</p>
<p>光源不同，光纤也不同： + 多模光纤：发光二极管连接的光纤，依靠多次反射传播（光损耗大），适用于近距离传输。 + 单模光纤：激光二极管连接的光纤，沿着光导纤维直接传输，折射少、损耗小，传输距离远。</p>
<p>光检测器：把光信号转为电信号的设备。通常是光电二极管。</p>
<p>调制技术：移幅键控法，也称为亮度调制（Intensity modulation)：<br>
在给定的频率下，光的出现和消失表示两个二进制数字。</p>
<p>计算机网络中，采用一来一去两根光纤来组成传输系统。</p>
<h6 id="地理范围">地理范围</h6>
<p>几十公里。</p>
<p>波分复用技术使一条光路能传输多个载波：<br>
传统的光纤线路，只能传输一个载波。<br>
波分复用技术，使一条光纤上可以传输不同波长的多个载波。</p>
<h6 id="连通性">连通性</h6>
<p>光纤普遍用于点到点的连接。<br>
但实际上，光纤是可以多点连接的，而且比双绞线和同轴电缆可以分接的设备要多得多，但目前多点连接尚处于实验阶段。</p>
<h6 id="抗干扰性">抗干扰性</h6>
<p>不受电磁干扰、噪声干扰。</p>
<h4 id="无线传输介质">3.2.4 无线传输介质</h4>
<p>无线传输介质，按照频率从低到高排列： 无线电波、微波、红外线、可见光。</p>
<p>P.S. 微波实质上是无线电波的一种，只是其波长比无线电波短，具有方向性，因此列为单独一类。</p>
<h5 id="无线移动通信">无线移动通信</h5>
<blockquote>
<p>早期的大区制无线通信网络</p>
</blockquote>
<ul>
<li>结构简单，不需要交换：覆盖区域内只有一个无线基站</li>
<li>很大的发射功率（50W~200W），</li>
<li>覆盖 30km ~ 50km，很高的天线塔</li>
<li>频道数量少，覆盖范围有限</li>
</ul>
<p>频道：每个移动站与基站之间使用不同的两个频率进行通信（上行、下行），称为一个频道。 服务区域内，频道不能重复。因此，大区制能够使用的频道数有限。</p>
<blockquote>
<p>小区制，蜂窝移动网络</p>
</blockquote>
<ul>
<li>将一个大区制划分成多个小区(Cell)。每个小区设立一个基站(BS，Base Station)，基站与移动站（即用户的手机等设备，MS，Mobile Station)建立通信。基站之间通过电缆、光纤、微波等方式，与移动交换中心（MSC，Mobile Switch Center）连接。移动交换中心再与市话交换局连接，构成完整的蜂窝移动通信网络结构。</li>
<li>每个小区内的基站覆盖范围小，1KM~20KM</li>
<li>基站的发射功率小，5~10W</li>
<li>每个基站只提供几个频道，因为基站和用户站功率小，相隔较远的小区可以重复使用频率，从而在多个小区构成的整个覆盖区域内，仅用少量频道即可满足大量用户的通信需求，大大提高了整个通信网络的总容量。</li>
</ul>
<p>第一代蜂窝移动通信是模拟方式：语音信息以模拟信号方式传输的。</p>
<p>第二代蜂窝移动通信是数字方式：语音信息的数字化，数字信息的处理、传输。</p>
<blockquote>
<p>多址接入问题 无线电波不具有方向性，移动网络中传输的数据（包括基站发出、移动站发出），所有的用户都会接受，再通过数据的地址决定是否接受。<br>
如何避免用户间的互相干扰，让多个用户能同时接入基站，同时享受基站提供的服务，就是多址接入问题。</p>
</blockquote>
<blockquote>
<p>多址接入技术 多址接入技术，解决多址接入问题。<br>
多个用户通过公共信道接入到基站，和多路复用有相似之处：在一个信道上同时传输多路信号。 + 频分多址接入 FDMA + 时分多址接入 TDMA + 码分多址接入 CDMA</p>
</blockquote>
<p>蜂窝移动网络的设计，涉及到了OSI/RM模型中的物理层、数据链路层、网络层。</p>
<h5 id="微波通信">微波通信</h5>
<ul>
<li>微波的频率很高，100Mhz~10Ghz，可同时传送大量信息</li>
<li>如果传输数字数据，速率可达数Mbps</li>
<li>微波沿直线传播，传输距离与天线高度有关，越高则越远。</li>
<li>只需要很小的功率即可实现远距离传输</li>
</ul>
<p>视线介质： 红外线、激光、微波都有很强的方向性，都是沿直线传播的，在发送方、接收方之间需要一条视线，因此称为视线通信。 ##### 卫星通信</p>
<h4 id="传输介质的选择">3.2.5 传输介质的选择</h4>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第三章 物理层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 3.1 物理层接口与协议</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-3-1-%E7%89%A9%E7%90%86%E5%B1%82%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/%E7%BD%91%E5%8E%9F-3-1-%E7%89%A9%E7%90%86%E5%B1%82%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h4 id="物理层接口与协议">3.1.1 物理层接口与协议</h4>
<h6 id="物理层的定义">物理层的定义</h6>
<p>物理层不是具体的物理设备，也不是物理传输介质。<br>
而是一种在DTE和DCE之间，建立、保持、断开物理连接的手段，具体包括了机械、电气、功能性的、规程性的4个方面。</p>
<ul>
<li>标准接口的机械连接特性</li>
<li>电气信号特性</li>
<li>信号的功能特性</li>
<li>交换电路的规程特性</li>
</ul>
<p>DTE：</p>
<ul>
<li>Data Terminal Equipment，数据终端设备。</li>
</ul>
<p>DTE属于资源子网，是信源或信宿，包括：计算机、终端。是用户所有的设备。</p>
<p>DCE：包括了数据通信设备，或者数据电路终接设备</p>
<ul>
<li>Data Communication Equipment，数据通信设备</li>
<li>Data Circut-Terminating Equipment，数据电路终接设备</li>
</ul>
<p>DCE属于通信子网，是为用户提供网络接入点的通信设备。包括：自动呼叫应答设备、调制解调器等，是网络运营商所有的设备。</p>
<p>ACE：</p>
<ul>
<li>Automatic Calling Equipment，自动呼叫设备。</li>
</ul>
<h6 id="物理层协议也称为接口">物理层协议也称为接口</h6>
<p>因为物理层是连接DTE和DCE的中间系统，因此物理层协议有时也称为接口。 <img src="/2019/12/01/网原-3-1-物理层接口与协议/网原-3-1-物理层接口与协议/225445361.jpg"></p>
<h6 id="物理层的传输单位是bit">物理层的传输单位是bit</h6>
<p>物理层的传输单位是bit，即一个0或1。</p>
<h6 id="物理层的功能">物理层的功能</h6>
<p>只关心能否实现比特流的传输，而不关心比特流的含义，因此也无法进行传输差错的控制。</p>
<h4 id="物理层的功能和提供的服务">3.1.2 物理层的功能和提供的服务</h4>
<h5 id="机械特性">1.机械特性</h5>
<p>DTE和DCE之间，通常采用连接器（即插头、插座）实现机械上的互连。 物理层的机械特性，对插头插座的几何尺寸、插针或插孔的芯数及排列方式，锁定装置形式等做了详细的规定。</p>
<h5 id="电气特性">2.电气特性</h5>
<p>DTE与DCE之间有多根导线相连，物理层的电气特性就规定了这组导线的电气连接方式，及其特性。</p>
<p>电气连接方式： + 非平衡方式 + 采用差动接收器的非平衡方式 + 平衡方式</p>
<h5 id="信号的功能特性">3.信号的功能特性</h5>
<p>物理层的功能特性规定了接口中每根信号线的各方面： + 信号传输方向（DTE-&gt;DCE，或DCE-&gt;DTE) + 信号的作用：发送数据、接受数据、保护地线、请求发送...... + 信号线之间的关系 ：某一信号线可以控制其他几个信号线，或，几个信号线组合起来表示某个意思。</p>
<p>信号线按功能可分为几类： + 数据信号线 + 控制信号线 + 定时信号线 + 接地线</p>
<p>信号线的命名方法可分为几类： 1. 数字命名法：<br>
用于DTE-DCE接口时，信号线名称均为1XX<br>
用于DTE-ACE接口时，信号线名称均为2XX</p>
<ol start="2" type="1">
<li><p>字母组合法：<br>
比如 RS 232C 中 TxD 表示Data Out。<br>
<img src="/2019/12/01/网原-3-1-物理层接口与协议/网原-3-1-物理层接口与协议/VNote_2019-12-01_23-35-30.png"></p></li>
<li><p>英文缩写命名法：<br>
比如 RS-449中，SD是Send Data的缩写。</p></li>
</ol>
<img src="/2019/12/01/网原-3-1-物理层接口与协议/网原-3-1-物理层接口与协议/rs449pic_1-27-98.jpg">
<h5 id="规程特性">4.规程特性</h5>
<p>规程，即“规则+流程”。</p>
<p>规程特性规定了：使用交换电路进行数据交换的控制步骤。</p>
<p>这些控制步骤保证了比特流的正常传输。</p>
<p>ITU建议使用的物理层规程包括： + V系列标准：V.24 ， V.25, V.54等 + X系列标准：X.20, X.20 bis， X.21，X.21 bis 等 V系列标准和X系列标准分别适用于不同的交换电路中。</p>
<h4 id="物理层协议举例">3.1.3 物理层协议举例</h4>
<h5 id="eia-rs-232c-接口标准">1. EIA RS-232C 接口标准</h5>
<p>EIA：Electronic Industry Association，美国电子工业协会。 RS：Recommand Standard，推荐标准。</p>
<p>EIA RS-232 C：<br>
232是标准的标识号码，C是修订版本号。</p>
<p>EIA RS-232C 是一个串行物理接口标准。</p>
<p>RS-232C标准提供了两种连接DTE和DCE的方式： 1. 远程连接 使用公用电话网络（模拟网络）作为传输媒介，通过调制解调器（DCE）将两个远程的DTE（计算机、终端）连接起来。</p>
<p>DTE1通过RS232C接口与调制解调器DCE1相连，DCE1把DTE1的数字信号转换成模拟信号，通过模拟电话网络传输到远程的调制解调器DCE2，DCE2将模拟信号转换成数字信号，发送给远程的DTE2，从而实现比特流的传输。<br>
在这个过程中， + DTE是信源或信宿，负责生成和处理信号 + DCE负责通过传输媒介，将信号从信源送到信宿 + RS232C负责DTE和DCE之间的通信</p>
<ol start="2" type="1">
<li>近地连接 既不使用公用电话网络，也不使用调制解调器。 直接使用RS232C接口连接两台计算机。</li>
</ol>
<p>RS232C要求两端必须是DTE和DCE，所以在近地连接中使用“信号线交叉跳接”电缆，使任一方都会将对方视为DCE。</p>
<p>这根交叉跳接信号线的电缆，称为零调制解调器，null modem。</p>
<p>近地连接，又有两种连接方式： + 完整连接 + 简单连接</p>
<h6 id="rs232机械特性">RS232机械特性</h6>
<p>规定：使用25芯标准连接器，对连接器的尺寸、针或孔的排列位置做了详细规定。</p>
<p>但在实际应用中，尤其是个人计算机中，某些厂家去掉了不常用的信号线，制造了RS232C的简化版本，9芯标准连接器。 ###### RS232C的电气特性 正负15V的负逻辑电平：<br>
逻辑1的电平为-15V<sub>-5V，逻辑0的电平为5V</sub>15V。</p>
<p>RS232C采用非平衡式发送接受电路。传输距离短，通信速率低。</p>
<h6 id="rs232c的功能特性">RS232C的功能特性</h6>
<p>略</p>
<h6 id="rs232c的规程特性">RS232C的规程特性</h6>
<p>RS-232C的工作过程必须在各根控制信号线的有序配合下进行。</p>
<p>比如：<br>
只有当CD和CC都处于ON状态时，RS232C接口才能进行各种操作。<br>
要发送数据，必须先将CA置为ON状态。<br>
要等待CB处于ON状态后，才能在BA上发送数据。</p>
<h5 id="eia-rs-449rs-422rs-423接口标准">2. EIA RS-449（RS-422,RS-423）接口标准</h5>
<p>因为RS-232C采用高电平信号 + 非平衡发送接受方式，存在：传输距离短、通信速率低、串扰信号大等问题。</p>
<p>为了解决上述问题，就推出了 RS449标准。<br>
之后又发布了449的两个电气子标准：RS422、RS423。</p>
<p>机械特性：规定采用37芯和9芯连接器。</p>
<p>电气特性：有两个子标准： + RS 422：平衡式，抗串扰能力大大增强，传输距离远，速率高。 + RS 423：非平衡式，比RS232C好很多，差于RS422。</p>
<h5 id="系列和200系列接口标准">3. 100系列和200系列接口标准</h5>
<p>ITU：国际电信联盟。</p>
<p>CCITT：国际电报电话咨询委员会，是ITU的前身。<br>
从事通信标准的研究和制定。<br>
其制定的标准通常称为建议。</p>
<p>ITU对 DTE - DCE的接口标准有V系列和X系列两大类： + V系列：DTE与，调制解调器、网络控制器（即网络适配器，网卡）之间的接口。接口复杂，信号线+控制线。 + X系列：DTE与，“公共数据网(PDN)的电路终接设备DCE”之间的接口。接口简单，只有很少的信号线。X系列接口标准是应用于广域网的接口标准。</p>
<p>公共数据网，PDN，Public Data Network：<br>
是由电信部门或广泛认可的私有组织建立、运营的网络，用于向公众提供数据传输服务。<br>
PDN可以是电路交换，或分组交换网络，以数字形式提供传输服务。</p>
<p>ITU V.24建议中，与DTE-DCE连接有关的接口标准有： + 100系列：DTE与不带自动呼叫设备的DCE（如调制解调器）之间的接口 机械特性：根据传输速率不同，采用34芯或25芯连接器。 电气特性：根据传输速率不同，采用V.28、或V.35两种建议。</p>
<ul>
<li>200系列：DTE与带有自动呼叫设备的DCE（如网络控制器）之间的接口 机械特性：采用25芯连接器。 电气特性：采用V.28建议。</li>
</ul>
<h5 id="x.21-和-x.21-bis-建议">4. X.21 和 X.21 bis 建议</h5>
<p>X.21建议：<br>
用户计算机DTE和数字化DCE之间的接口标准。<br>
所谓数字化DCE，是指传输介质上传输的不是模拟信号，而是数字信号。</p>
<p>X.21的设计目标： + 减少信号线的数目，机械特性上：采用15芯连接器代替传统的25芯连接器，且其中仅使用了8芯。 + 允许DTE-DCE的接口距离更长、速率更高（相对于RS232C）。电气特性：采用类似于平衡式的发送接受器，</p>
<p>X.21的优点：<br>
形式简单，操作过程全自动，有助于消除传输差错（数字信号可以奇偶校验、循环冗余校验等方式），数据与控制信号比特流都可以通过该接口进行传输。</p>
<p>X.21适合数字线路的公用数据网（比如欧洲），不适用于模拟线路的公用数据网。<br>
OSIRM建议采用X.21作为物理层规范。</p>
<p>因为从V系列标准升级到X系列标准，需要升级很多硬件，比如接入用户端的信道仍然是模拟信道（电话线），大多数计算机和终端不具备X.21接口。<br>
最终ITU推出了X.21 bis接口标准，作为从V到X.21的过渡标准： + 公共数据网使用数字传输方式，但用户入户可以使用模拟信道 + DTE-&gt;DCE之间，仍然使用V系列标准，连接器与RS-232D非常类似。</p>
<p>X.21和X.21 bis 为三种类型的服务定义了物理电路： 1. 租用电路：专用线，两个DTE之间的持续连接。 2. 直接呼叫服务：可使用户在任何时间直接连接指定的目标。 3. 设备地址呼叫服务：如同拨号电话，每次连接前由用户呼叫指定目标。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第三章 物理层</category>
      </categories>
  </entry>
  <entry>
    <title>网原 2.4 OSI/RM 与 TCP/IP 参考模型的比较</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-2-4-OSI-RM-%E4%B8%8E-TCP-IP-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83/%E7%BD%91%E5%8E%9F-2-4-osi-rm-%E4%B8%8E-tcp-ip-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h4 id="相似之处">相似之处</h4>
<ul>
<li>都采用了协议栈的形式，协议栈中的协议彼此独立</li>
<li>都采用了层级结构的概念，层的功能有相似之处</li>
</ul>
<h4 id="不同之处">不同之处</h4>
<ul>
<li>OSI/RM有7层，TCP/IP只有4层</li>
<li>OSI/RM的网络层支持面向连接服务和无连接服务；而TCPIP的网络层只支持无连接服务</li>
<li>OSI/RM的传输层支持：面向连接服务；而TCP/IP的传输层支持：面向连接服务、无连接服务</li>
</ul>
<h4 id="osirm的缺点">2.4.1 OSI/RM的缺点</h4>
<ul>
<li>模型和协议自身的缺陷。比如：会话层、表示层几乎是空的，数据链路层和网络层包含太多内容。</li>
<li>服务定义和协议极其复杂，难以实现</li>
<li>某些功能（比如编址、流控制、差错控制）在每一层上重复出现，降低系统效率</li>
</ul>
<p>OSI/RM没有成为业界标准的原因： 出现时间晚于TCP/IP，TCP/IP已经普及，各厂家不愿意再支持另一个协议栈。</p>
<h4 id="tcpip-模型和协议的缺点">2.4.2 TCP/IP 模型和协议的缺点</h4>
<ul>
<li>没有区分哪些是规范，哪些是实现，TCP/IP参考模型对设计新网络没有指导意义</li>
<li>TCP/IP模型不适合于“其他非TCP/IP协议簇”</li>
<li>TCP/IP模型的主机-网络层并非传统意义的层，它实际上是一个接口集，包括了网络层与数据链路层的接口。接口和层并不相同，TCP/IP没有区分这一点。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第二章 计算机网络体系结构</category>
      </categories>
  </entry>
  <entry>
    <title>网原 2.3 TCP/IP 参考模型</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-2-3-TCP-IP-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/%E7%BD%91%E5%8E%9F-2-3-tcp-ip-%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="tcpip简介">2.3.1 TCP/IP简介</h4>
<p>同一网络体系结构的网络可以互连。<br>
前面介绍了 OSI/RM 网络体系结构， 本文介绍TCP/IP网络体系结构。</p>
<p>注意：<br>
“TCP/IP”既是网络体系结构。 同时也是一个协议簇，两者的作用都是实现网络互连。</p>
<p>TCP/IP，Transmission Control Protocol / Internet Protocol，传输控制协议 / 互联网协议。</p>
<p>TCP/IP的特点：</p>
<ul>
<li>免费的、开放的协议</li>
<li>与计算机硬件、操作系统独立。各种计算机硬件、操作系统都可以运行TCP/IP协议簇。</li>
<li>与网络硬件独立。大量厂家的网络硬件（中间节点）都可以运行TCP/IP协议簇。</li>
<li>统一的地址分配方案。每一个网络设备都可以获得唯一的地址。</li>
<li>标准化的高层协议，可以提供多种用户服务。</li>
</ul>
<h4 id="tcpip参考模型">2.3.2 TCP/IP参考模型</h4>
<h5 id="tcpip参考模型对比osirm参考模型">TCP/IP参考模型，对比OSI/RM参考模型</h5>
<p>TCP/IP参考模型分为4层，从上到下依次是： + 应用层(Application Layer)： 等价于 OSI/RM 的应用层+表示层+会话层 + 传输层(Transport Layer)：等价于 OSI/RM 的传输层 + 互连网层(Internet Layer)：也称为网际层、网际互连层，等价于OSI/RM的网络层 + 主机-网络层(Host-to-Network Layer)：也称为“网络接入层”、“网络接口层”，等价于OSI/RM的 “数据链路层 + 物理层”</p>
<img src="/2019/12/01/网原-2-3-TCP-IP-参考模型/网原-2-3-tcp-ip-参考模型/v2-96ddf8b3126009a764d3428a77ec4802_r.jpg">
<h5 id="tcpip协议簇逐层讲解">TCP/IP协议簇逐层讲解</h5>
<p>TCP/IP协议，不仅包括了 TCP协议 / IP协议，还包括了大量其他协议，统称为TCP/IP协议簇。</p>
<img src="/2019/12/01/网原-2-3-TCP-IP-参考模型/网原-2-3-tcp-ip-参考模型/20190605165441021_25092.png">
<h6 id="主机-网络层网络接口层网络接入层">主机-网络层（网络接口层、网络接入层）</h6>
<p>包括了：</p>
<ul>
<li>各种接口：连接了，各种通信网，与，“网络接口层的上层”</li>
<li>各种物理网络的网络协议</li>
</ul>
<p>通信网包括：</p>
<ul>
<li>多种广域网：ARPANET、MILNET、X.25公用数据网</li>
<li>多种局域网：如 IEEE 802.3的 CSMA/CD，IEEE802.4的Token Bus，IEEE 802.5的Token Ring等。</li>
</ul>
<h5 id="网际互连层">网际互连层</h5>
<p>网际互连层的功能包括：</p>
<ul>
<li>提供端-端的分组分发功能（由IP协议提供）</li>
<li>在互相独立的局域网上建立互连，组成互连网。一个局域网发往另一个局域网的报文分组，会根据它的目的IP地址被路由器跨网送达目的地。（含有目的IP地址的分组，应该属于数据报分组交换）</li>
<li>其他扩充功能，比如：为克服数据链路层（在TCP/IP中属于网络接口层的子层）对帧大小的限制，网际互连层可以进行数据分块、重组，使得很大的IP数据报能以较小的分组在网上传输。（这里也应该属于数据报分组交换）</li>
</ul>
<p>注意：<br>
TCP/IP的网际互连层只有数据报分组交换方式，只能进行无连接服务。<br>
而OSI/RM的网络层则提供了：面向连接服务、无连接服务两种通信服务方式。</p>
<p>网际互连层包括了以下协议：</p>
<ul>
<li>IP，Internet Protocol，互连网协议</li>
<li>ICMP，Internet Control Message Protocol，互连网控制报文协议</li>
<li>ARP，Address Resolution Protocol，地址解析协议</li>
<li>RARP，Reverse Address Resolution Protocol，反向地址解析协议 ##### 传输层 负责进程间的通信。</li>
</ul>
<p>注意：<br>
OSI/RM参考模型中，传输层提供的是主机-主机的通信，会话层才提供进程-进程的通信。</p>
<p>包含的协议：</p>
<ul>
<li>TCP，Transmission Control Protocol，传输控制协议：提供可靠的字节流信道，面向连接服务</li>
<li>UDP，User Datagram Protocol，用户数据报协议：提供不可靠的数据报传送通道，无连接服务</li>
</ul>
<h5 id="应用层">应用层</h5>
<ul>
<li>SMTP，Simple Mail Transfer Protocol，简单邮件传输协议</li>
<li>DNS，Domain Name Service，域名服务</li>
<li>FTP，File Transfer Protocol，文件传输协议</li>
<li>Telnet，远程终端访问协议</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第二章 计算机网络体系结构</category>
      </categories>
  </entry>
  <entry>
    <title>网原 2.2 OSI/RM 开放系统互连参考模型</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-2-2-OSI-RM-%E5%BC%80%E6%94%BE%E7%B3%BB%E7%BB%9F%E4%BA%92%E8%BF%9E%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/%E7%BD%91%E5%8E%9F-2-2-osi-rm-%E5%BC%80%E6%94%BE%E7%B3%BB%E7%BB%9F%E4%BA%92%E8%BF%9E%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="osirm-简介">2.2.1 OSI/RM 简介</h4>
<p>上一节讲到，网络体系结构（分层模型+协议）是一种网络类别。<br>
各公司都研发了自己的网络体系结构，不同体系结构的网络互连很困难。</p>
<p>因此，国际标准化组织 ISO 制定了标准化、开放式的计算机网络层次结构模型 OSI/RM，所有遵循了该模型的计算机网络就可以互连。</p>
<p>OSI/RM：<br>
Open System Interconnection Reference Model，“开放系统互连参考模型”。</p>
<p>OSI/RM 包括了三级抽象：</p>
<ol type="1">
<li>体系结构：定义了七层模型，是OSIRM的基础框架。</li>
<li>服务定义：描述了各层向上提供的服务，以及层与层之间的抽象接口，层间交互的服务原语。</li>
<li>协议规范：定义了发送方发送控制信息，接收方解读控制信息的各种细节。</li>
</ol>
<p>OSI/RM 不是一个标准，只是一个概念性框架，无法被实现，用途是在制定标准时便于参考、使用。</p>
<p>在三级抽象中，只有协议是可以实现的，</p>
<h4 id="osi-rm-的结构">2.2.2 OSI / RM 的结构</h4>
<p>OSI/RM系统有7层组成：</p>
<ul>
<li>物理层：定义了物理传输链路的机械的、电气的、功能的和规程的特性。其作用是使数据比特流能在物理介质上以电信号方式进行实通信。</li>
<li>数据链路层：以帧为单位进行虚通信。把“不可靠的物理链路”改造成“对网络层来说是无差错的数据链路”，同时还要进行收发双方的流量控制。</li>
<li>网络层：以分组为单位进行虚通信。网络层主要负责分组的路由选择，并对流入网络的分组数量进行控制以防止网络阻塞，另外，当分组要跨越多个通信子网时，网络层还负责解决网际互连的问题。</li>
<li>传输层：是第一个端-端（即主机）的层次。它提供了端-端的透明数据传输服务，使更高层无需关心通信子网的运作，另外它还负责端-端的差错控制和流量控制。</li>
<li>会话层：进程-进程的层级。负责在不同主机的两个进程间，建立和拆除会话，管理他们的通信。</li>
<li>表示层：用统一的数据结构、编码表示，去翻译异构互连主机的数据，使得异构主机也能互相理解。因为符合OSIRM的不同主机，即使对同一数据，也可能采用了不同的数据结构描述和编码表示，而表示层就可以在发送方将其转换为统一的数据结构、编码表示，再在通信子网中传输，接收方再其转换为目标主机能够接受的形式。</li>
<li>应用层：具体的应用软件。</li>
</ul>
<p>开放系统互连参考模型的网络，由两部分通过物理介质连接构成： + 作为信源和信宿的<strong>端开放系统</strong>：即资源子网中的主机，通常包含了7层功能。 + 若干<strong>中继开放系统</strong>：通信子网中的接口信息处理机(IMP)，通常只包含了3层，甚至只有2层。</p>
<img src="/2019/12/01/网原-2-2-OSI-RM-开放系统互连参考模型/网原-2-2-osi-rm-开放系统互连参考模型/网络分层体系结构.png">
<h6 id="osirm-层次结构模型网络的数据传输过程">OSI/RM 层次结构模型网络的数据传输过程</h6>
<p>发送进程发给接收进程的数据，会经过发送方各层从上到下抵达物理介质，通过物理介质传输到接收方后，再经过从下到上的传递，最终到达接收进程。</p>
<img src="/2019/12/01/网原-2-2-OSI-RM-开放系统互连参考模型/网原-2-2-osi-rm-开放系统互连参考模型/网络各层的PDU.jpg">
<p>发送方：<br>
每当数据要传给下层时，本层就会对数据加上控制信息，称为报头。<br>
逐层向下传递，数据最终在物理层成为“数据比特流”，之后在物理介质上转换为电信号，通过物理介质发送给接收方。</p>
<p>接收方：<br>
收到电信号后，在物理层转换为数据比特流，然后逐层向上传递。<br>
每一层在收到下一层发来的数据后，首先会剥去本层的报头，得到数据，再向上传送，数据最终会送到接受进程。</p>
<p>接收方的任意一层都不会收到下层的报头（下层报头早已剥离），而高层的控制信息无法识别（对本层来说仅仅是数据而已），因此它只能阅读和去除本层的报头。这样一来，就好像数据在发送方和接受方的虚通信中直接传输一样。</p>
<h4 id="面向连接服务与无连接服务">2.2.3 面向连接服务与无连接服务</h4>
<h5 id="通信服务类型">1.通信服务类型</h5>
<h6 id="面向连接服务">1)面向连接服务</h6>
<p>Connection Oriented Service</p>
<ul>
<li>必须事先建立一条通信线路（虚电路）才能传输数据。通信过程必须有3个阶段：建立、使用、释放。</li>
<li>各分组不需要携带目的节点地址。</li>
<li>通信链路相当于一个管道，发送方放入数据，接收方取出数据，收发数据的顺序不变，可靠性好。</li>
<li>通信开销大，协议复杂，通信效率低</li>
</ul>
<p>面向连接服务，在节点数据交换方式上包括：</p>
<ul>
<li>电路交换（物理信道）</li>
<li>虚电路分组交换（逻辑信道）</li>
</ul>
<h6 id="无连接服务">2)无连接服务</h6>
<p>Connectionless Service</p>
<ul>
<li>通信过程不需要建立、使用、释放3个步骤</li>
<li>每个分组携带目的节点地址</li>
<li>各分组在通信子网中独立传送。具有相同源和目的地址的分组，可能走不同的网络路径，到达目的节点的先后顺序与发送顺序无关。</li>
<li>目的节点收到的分组可能出现乱序、重复、丢失等情况，可靠性差。</li>
<li>通信开销小，协议简单、效率高。</li>
</ul>
<p>无连接服务，在节点数据交换方式上包括：</p>
<ul>
<li>报文交换</li>
<li>数据报分组交换</li>
</ul>
<h5 id="确认和重传机制">2.确认和重传机制</h5>
<p>面向连接服务、无连接服务，在可靠性上已有区别（面向连接&gt;无连接服务)。</p>
<p>但还不够，为了进一步确保可靠性，还可以使用“确认和重传机制”。</p>
<p>确认：<br>
数据分组接收节点（中继节点，或目的节点）收到分组后，应向发送节点（上家节点，可能是源节点，也可能是中继节点）回送确认信息。</p>
<p>重传：<br>
发送分组的节点，在规定时间内，没有收到接收节点回送的确认信息，则认为分组发送失败，会重发该数据分组。</p>
<p>注意：<br>
这里仅谈到分组，实际上确认重传机制也适用于报文交换。</p>
<h5 id="服务类型服务质量可以自由组合">服务类型、服务质量可以自由组合</h5>
<p>面向连接服务、无连接服务属于服务类型，确认重传机制属于服务质量。</p>
<p>两者可以自由搭配组合。</p>
<p>比如 + 面向连接服务，可以使用确认重传机制，也可以不使用。 + 无连接服务，也可以使用确认重传机制，或者不使用。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第二章 计算机网络体系结构</category>
      </categories>
  </entry>
  <entry>
    <title>网原 2.1 网络的分层体系结构</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-2-1-%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%BD%91%E5%8E%9F-2-1-%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h4 id="协议的要素">2.1.1 协议的要素</h4>
<p>网络协议：网络中为数据交换而建立的规则、标准、约定的集合。</p>
<p>网络协议具有以下三要素：</p>
<ol type="1">
<li>语义：控制信息的含义（这些控制信息类似于伪代码，并非已经确定的命令）。<br>
控制信息描述了通信双方应当如何进行通信，用于：协调双方的通信动作，以及对通信中出现的差错进行处理。</li>
<li>语法：数据和控制信号的格式、编码、信号电平等。</li>
<li>定时（时序、定时）：定义了速度匹配、排序。先讲什么、后讲什么，讲话的速度等，以及传输方式：同步传输、异步传输。</li>
</ol>
<p>网络协议具体表现为一个软件，可以安装不同的网络协议，使计算机网络运行在不同的协议下（前提是当前硬件支持该协议，否则需要专门购置）。</p>
<h4 id="分层体系结构">2.1.2 分层体系结构</h4>
<h6 id="结构化设计方法">结构化设计方法</h6>
<p>结构化设计方法：将一个复杂的系统分解为若干个容易处理的子系统，然后分别加以解决。</p>
<p>分层：结构化设计方法中，系统分解的方法之一。</p>
<p>分层的工作原理：<br>
n 层是 n-1 层的用户，又是 n+1 层的服务提供者。<br>
n+1 层直接使用了 n 层提供的服务，也间接的使用了 n-1 层及其下各层提供的服务。</p>
<p>层次结构的优点：</p>
<ul>
<li>每层相对独立：在设计、实现每层时，不必知道下一层的实现细节，只需知道下一层提供哪些服务，以及自身应该向上一层提供哪些服务。</li>
<li>要改动某一层时，只要不改动它与上下层的服务关系，则其他层不受影响。</li>
<li>每层的功能相对简单，易于实现和维护。</li>
<li>分层结构有利于交流、理解、标准化。</li>
</ul>
<h6 id="网络体系结构">网络体系结构</h6>
<p>网络体系结构是一个抽象概念， 它定义了网络层次的组成、以及各层的功能。</p>
<p>具体内容包括：</p>
<ul>
<li>计算机网络层次结构模型</li>
<li>各层协议</li>
</ul>
<p>因为网络体系结构是一个抽象概念，所以它仅仅描述了一种网络类型，可以采用不同的硬件、软件来实现它。</p>
<p>计算机网络的体系结构，都属于层次化体系结构，其特点包括：</p>
<ul>
<li>物理介质是实通信，其余各对等层之间是虚通信。</li>
<li>对等层间的虚通信，必须遵守该层的协议。</li>
<li>n 层的虚通信，是通过 { (n-1) 层向n层提供的服务 + (n-1) 层间的虚通信 }来实现的。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第二章 计算机网络体系结构</category>
      </categories>
  </entry>
  <entry>
    <title>网原 1.4 计算机网络的标准化</title>
    <url>/2019/12/01/%E7%BD%91%E5%8E%9F-1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96/%E7%BD%91%E5%8E%9F-1-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96/</url>
    <content><![CDATA[<p>todo: 待整理。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第一章 计算机网络概述</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo Next主题渲染 Latex 公式的配置方法</title>
    <url>/2019/12/01/hexo-Next%E4%B8%BB%E9%A2%98%E6%B8%B2%E6%9F%93-latex-%E5%85%AC%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/hexo-next%E4%B8%BB%E9%A2%98%E6%B8%B2%E6%9F%93-latex-%E5%85%AC%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Next 主题可以使用 mathjax 和 katex 两种渲染 latex 的方式。</p>
<ul>
<li>katex 渲染速度更快，但仅支持 latex 的子集。<br>
</li>
<li>mathjax 渲染速度稍慢，但对 latex 的支持较好。</li>
</ul>
<p>Next 主题的配置文件 _config.yml 中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line"><span class="attr">  mathjax:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line"><span class="attr">    mhchem:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) required for full Katex support.</span></span><br><span class="line"><span class="attr">  katex:</span></span><br><span class="line"><span class="attr">    enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line"><span class="attr">    copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>mathjax 和 katex 是互斥的两个选项，enable 不能同时 true或 false。</p>
<p>如果设置 <code>mathjax : true</code> ，就需要更换渲染引擎， <code>hexo-renderer-pandoc</code> 或 <code>hexo-renderer-kramed</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">uninstall</span> hexo-renderer-marked <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-pandoc <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>katex : true</code> ，则需要更换 hexo-renderer-markdown-it ，或者在原来的 hexo-renderer-marked 引擎下使用 markdown-it-katex plugin。</p>
<p>另外需要注意，如果置 <code>mathjax: true</code>，且使用了 <code>hexo-renderer-kramed</code>渲染引擎，会遇到一行只能使用一个行内公式的情况。<br>
解决方法是直接修改<code>hexo-renderer-kramed</code>相关源码，把文件 node_modules/kramed/lib/rules/inline.js 做如下修改：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">var inline = &#123;</span><br><span class="line">  escape: /^<span class="symbol">\\</span>([<span class="symbol">\\</span>`*&#123;&#125;<span class="symbol">\[</span><span class="symbol">\]</span>()#$+<span class="symbol">\-</span>.!_&gt;])/,</span><br><span class="line">  // ...</span><br><span class="line">  em: /^<span class="symbol">\b</span>_((?:__|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)_<span class="symbol">\b</span>|^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>修改为:<br>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">var inline = &#123;</span><br><span class="line">  escape: /^\\([<span class="string">`*\[\</span>](<span class="link"></span>)#$+\-.!_&gt;])/,</span><br><span class="line">  // ...</span><br><span class="line">  em: /^\<span class="emphasis">*((?:\*</span>\<span class="emphasis">*|[\s\S])+?)\*</span>(?!\*)/,</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>笔者有一些高数笔记，因此使用了 pandoc。 per_page 取值的差异在注释中已经说得很清楚了：</p>
<ul>
<li>true: 仅当 front-matter 中存在 <code>mathjax: true</code> 时，该页面才会被渲染。因为渲染会影响速度，推荐用“此选项 + front-matter”进行控制。</li>
<li>false: 每篇文章都会进行渲染，不论其中有无公式。</li>
</ul>
<hr>
<p>相关知识:</p>
<h2 id="latex-行内公式行间公式">LaTex 行内公式、行间公式</h2>
<p>行内公式：包含在行内的公式。</p>
<p>行内公式统一使用 <code>$...$</code> 来表达，<code>$</code> 前后一般要有空格， 除非公式后面有标点符号。</p>
<p>行间公式：独立成行的公式。</p>
<h2 id="mhchem">mhchem</h2>
<p><a href="https://mhchem.github.io/MathJax-mhchem/" target="_blank" rel="noopener">mhchem for MathJax</a></p>
<p>显示化学公式的 JS库。</p>
<h2 id="katex">Katex</h2>
<p><a href="https://zh.wikipedia.org/wiki/KaTeX" target="_blank" rel="noopener">KaTex wiki</a></p>
<p>katex 是一个JS库，可以在多种浏览器上显示数学公式。相对 Latex 更加轻量，但支持更少的数学符号。特点是轻量、快速、易于使用。</p>
]]></content>
      <categories>
        <category>应用软件</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>NotePad2打开文件乱码的原因和解决</title>
    <url>/2019/11/29/NotePad2%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3/notepad2%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>TotalCommander 的插件 Universal Viewer Pro 自带的F4编辑器 Notepad2 ，在打开某些中文文档时会出现类似韩文的乱码。</p>
<p>原因在于：<br>
notepad2自动检测文本编码格式时有问题，如果中文文档不包含任何单字节的英文字符或数字，自动检测时就会出错。</p>
<p>解决办法： 按 F8，尝试各种编码。</p>
<p>也可以关闭 Notepad2 的自动检测功能，固定为预设的编码：<br>
选择菜单“文件”-“编码”-“默认”，会弹出“选择编码”对话框，选择“跳过Unicode自动检测”和“不解释编码标识”，最后按F7保存设置。</p>
]]></content>
      <categories>
        <category>应用软件</category>
      </categories>
  </entry>
  <entry>
    <title>数原 4.4 数据更新</title>
    <url>/2019/11/29/%E6%95%B0%E5%8E%9F-4-4-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/%E6%95%B0%E5%8E%9F-4-4-%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h2 id="插入数据">插入数据</h2>
<h3 id="insert-into-tbname-valuesval1val2...val21val22......">insert into tbname values(val1,val2,...),(val21,val22,...),...</h3>
<p>可以插入多条记录</p>
<h3 id="insert-...-set">insert ... set</h3>
<p>只能插入一条记录</p>
<h3 id="insert-...-select">insert ... select</h3>
<p>把子查询的结果集插入表中。</p>
<h2 id="删除数据">删除数据</h2>
<p>delete from tbname where</p>
<h2 id="更新数据">更新数据</h2>
<p>update tbname set col1=val1,col2=val2,... where</p>
<p>select case when condition1 then expr1 when condition2 then expr2 else expr3 end as colalias</p>
<p>聚合函数：</p>
<p>如果使用了group by ,结果是多条记录，即多个分组，每个分组的聚合。</p>
<p>如果没有group by ，结果是一条记录，是对所有记录的聚合。</p>
<h2 id="四where-子句和条件查询">四、Where 子句和条件查询</h2>
<h3 id="比较运算">1. 比较运算</h3>
<ul>
<li>两个值都不为NULL：结果为 TRUE /FALSE</li>
<li>其中一个值为NULL或都为NULL：比较结果为 UNKNOWN</li>
<li>&lt;=&gt;：两个值相等，或，都为NULL，结果为 TRUE，否则 FALSE ### 2. 范围</li>
<li>between ... and ：闭区间 , [ ]</li>
<li>in (枚举)</li>
</ul>
<h3 id="判断是不是空值">3. 判断是不是空值</h3>
<ul>
<li>colname IS [NOT] NULL</li>
</ul>
<h3 id="子查询">4. 子查询</h3>
<p>select * from tb_student where studentno in (select studentno from tbscore where score&gt;=80)</p>
<p>select * from tb_student stu inner join tb_score sco on stu.studentno = sco.studentno where sco.score&gt;80</p>
<p>expression <比较运算符> all | any | some (subquery)</比较运算符></p>
<ul>
<li>all : expr 需要与子查询的每个结果进行比较</li>
<li>some/any: 只要子查询有值满足比较，即可。</li>
</ul>
<p>exist (subquery): 判断 subquery 的结果集是否为空。</p>
<h2 id="五group-by-子句分组数据">五、group by 子句，分组数据</h2>
<p>select * from customers group by</p>
<p>group by 是对 select 选择的列组成的结果集，再做分组。</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第四章 SQL与关系数据库基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>数原 4.3 数据定义</title>
    <url>/2019/11/29/%E6%95%B0%E5%8E%9F-4-3-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/%E6%95%B0%E5%8E%9F-4-3-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<p>RDMBS支持的三级模式结构(模式、外模式、内模式）包含的数据库对象有： 数据库模式(schema)、表、索引、视图等，相应的，SQL就应当提供这些基本对象的定义功能。</p>
<p>标准SQL提供的功能有限，更多的是具体的RDBMS扩展的功能。</p>
<p><a href="https://blog.csdn.net/aa8568849/article/details/62043039" target="_blank" rel="noopener">MYSQL数据库命令行分号不能结束语句的问题解决办法</a></p>
<h2 id="一数据库模式定义创建数据库模式">一、数据库模式定义（创建数据库/模式）</h2>
<p>数据库模式的定义包括：</p>
<p>create database | schema if not exists db_name character set = charset_name colloate = collation_name;</p>
<p>选择数据库:<br>
use database;</p>
<p>修改数据库：<br>
alter database|schema db_name alter_specification ...</p>
<p>drop database|schema if exists db_name;</p>
<p>列出mysql中的数据库 show databases|schemas;</p>
<h2 id="二表定义">二、表定义</h2>
<p>临时表：创建表时，可以使用 temporary 关键字。</p>
<p>临时表与用户会话有关，会话完成后，临时表会被MYSQL删除。<br>
而且临时表只对会话用户可见，因此不同用户可以使用同名的临时表。<br>
临时表甚至可以和持久表同名。</p>
<ul>
<li>数值型：int, double, bool(tinyint 的同义词,mysql没有内置的布尔类型，只能用整型来代替)</li>
<li>日期和时间型：date, time, timestamp</li>
<li>字符串型: char , varchar</li>
<li>空间数据类型：</li>
</ul>
<p>自增列：auto_increment。<br>
每个表只能有一个自增列，且必须被索引。<br>
插入数据时，该列可以用 NULL 或 0 来占位，系统会自动纠正该值，也可以指定一个未使用的值，以后在该基础上自增。</p>
<p>default 默认值：插入数据时，如果未指定该列的值，则DBMS自动赋予的一个值。<br>
如果没有为列指定DEFAULT约束，插入数据时，如果该列不允许为NULL，则DBMS会自动取该类型的0值，否则就填入NULL。</p>
<h3 id="更新表">更新表</h3>
<ul>
<li>add [column] 添加列。</li>
</ul>
<p>alter table tb_name add column cust_city char(50) not null default 'wuhan' [after cust_sex]|[first];</p>
<p>还可以用 add primary key , add foreign key , add index 等子句。</p>
<ul>
<li>change [column]，<strong>修改列的所有属性</strong>，包括列名、数据类型、列约束。</li>
</ul>
<p>alter table change [column] cust_sex sex char(1) null default 'M';</p>
<p>从一种数据类型A改为另一种数据类型B，如果AB不兼容，会失败。类型兼容时，可能数据被截断。</p>
<ul>
<li>alter [column]，<strong>修改列的默认值</strong>。</li>
</ul>
<p><code>alter table alter column colName set default newDefaultValue;</code><br>
注意关键字是 alter column ... set default ...</p>
<ul>
<li>modify [column]，<strong>修改列的数据类型</strong>，以及通过 first /after 修改列的位置。</li>
</ul>
<p>alter table modify column cust_name char(20) frist;</p>
<p>drop [column], 删除列，该列数据也被删除。<br>
类似的，drop primary key , drop foreign key , drop index</p>
<p>修改表名的2种方法：</p>
<ul>
<li>alter table tbname rename [to] newname, 修改表名</li>
<li>rename table oldname TO newname;</li>
</ul>
<p>列出数据库中的表，<br>
<code>show tables [from| in dbname];</code></p>
<p>列出指定表的结构， <code>show columns from|in tbname</code></p>
<p><code>describe|desc tbname [colname|wild]</code></p>
<h2 id="三索引">三、索引</h2>
<p>索引：建立了行号和记录值之间的对应关系。</p>
<p>查询数据时，根据输入的记录值，可以在索引中直接定位记录，实现快速查询。<br>
否则，没有索引的情况下，需要逐行读取记录值进行对比，明显慢得多。</p>
<p>索引虽然可以提供查询速度，但也存在一些弊端：</p>
<ul>
<li>空间问题，索引文件的增长速度可能比表快，从而更快的达到最大文件限制：一个表的所有索引都存放在一个索引文件中。</li>
<li>速度问题，索引会降低更新表的速度：对表执行写入操作时，DBMS需要同步更新索引，以保持索引和数据的一致性。索引越多，更新速度越慢。</li>
</ul>
<p>索引的分类：</p>
<ul>
<li>普通索引：index</li>
<li>唯一索引：unique index, 被索引的列具有唯一值，但允许至多有一个NULL值。</li>
<li>主键：主键也是一种唯一索引，不允许有NULL值。一个表只能有一个主键。可以在创建表时建立主键，也可以在之后添加 alter table add primary key...</li>
</ul>
<p>索引还可以分为：</p>
<ul>
<li>单列索引: 只包含一个数据列。</li>
<li>多列索引（复合索引/组合索引）：包括多个数据列</li>
</ul>
<p>多列索引实际上可以按照最左前缀法则拆分为多个，比如 (col1,col2,col3) 实际上包含了 (col1) ,(col1,col2), (col1,col2,col3) 3个索引。</p>
<h3 id="创建索引">创建索引</h3>
<h4 id="单独创建索引">1. 单独创建索引</h4>
<p><code>create [unique] index idxname on tbname(colname(length) asc|desc,...)</code></p>
<p>[unique] 用于创建唯一索引。<br>
colname是建立索引的列，通常使用<em>查询语句中where子句 或 join子句中的列</em> 。 length 指定使用列的前 length 个字符来创建索引，即使用列的一部分创建索引，从而缩小索引文件的体积。</p>
<h4 id="create-table的同时创建索引">2.create table的同时，创建索引</h4>
<p>可以在 create table 语句中使用以下一项或几项，以创建索引：</p>
<ul>
<li>主键<code>[constraint [symbol]] PRIMARY KEY (col1,col2,...)</code>: 主键是不允许NULL值的唯一索引。</li>
<li>外键<code>[constraint [symbol]] Foreign key [index_name] (col1,col2,...)</code>：外键也是一种索引。</li>
<li>普通索引 <code>{index|key} [index_name] (col1,col2,...)</code>：</li>
<li>唯一索引 <code>[constraint [symbol]] UNIQUE [INDEX|KEY] [index_name] (col1,col2,...)</code></li>
</ul>
<p>说明：<br>
{}表示必须出现的内容。<br>
KEY 和 INDEX是等价的。(因而，Primary key 和 foreign key 都是索引)</p>
<p>create table时，有几种指定主键的方法：</p>
<ul>
<li>在列约束后，使用 primary key 关键字指定它为主键：当主键由多列组成时，不能使用。</li>
<li>列定义的最后，添加一个 [constrain [symbol]] primary key(col1,cols2) ：即上面介绍的方法。</li>
</ul>
<h4 id="使用-alter-table-创建索引">3. 使用 alter table 创建索引</h4>
<p>语法和 create table 时完全一样，仅仅多了 add 。</p>
<ul>
<li><code>add primary key(col1,col2,...)</code></li>
<li><code>add foreign key [index_name] (col1,col2,...)</code></li>
<li><code>add {index|key} [index_name] (col1,col2,...)</code></li>
<li><code>add unique [index|key] [index_name] (col1,col2,...)</code></li>
</ul>
<h3 id="查看索引">查看索引</h3>
<p><code>show index |indexs | keys from|in tbname [from dbname]</code></p>
<h3 id="删除索引">删除索引</h3>
<p>有两种方法删除索引：</p>
<ul>
<li><code>drop index index_name on tbname</code></li>
<li>在 alter table中使用下列子句，来删除主键、外键、索引
<ul>
<li>drop primary key</li>
<li>drop foreign key</li>
<li>drop index</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第四章 SQL与关系数据库基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>数原 4.2 Mysql基础</title>
    <url>/2019/11/29/%E6%95%B0%E5%8E%9F-4-2-Mysql%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%8E%9F-4-2-mysql%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="二mysql中的sql">二、MYSQL中的SQL</h2>
<p>MYSQL支持关系数据库的三级模式结构：</p>
<ul>
<li>外模式：视图、部分基本表</li>
<li>模式：基本表，一个表可以有多个索引，索引也在存储文件中。</li>
<li>内模式：若干存储文件，存储文件的逻辑结构组成了内模式，存储文件的物理结构对用户透明。</li>
</ul>
<p>一个关系对应一个基本表，一个或多个基本表对应一个存储文件。<br>
视图是从一个或多个基本表导出的虚表，数据库只存储视图的定义，不需要存储其数据。<br>
视图上可以再定义视图。</p>
<p>MYSQL还在SQL标准的基础上增加了一些语言要素：</p>
<h3 id="常量">(1)常量</h3>
<ul>
<li>字符串常量：使用单引号或双引号括起来的字符序列。(建议一直使用单引号, <a href="https://stackoverflow.com/questions/11321491/when-to-use-single-quotes-double-quotes-and-backticks-in-mysql" target="_blank" rel="noopener">When to use single quotes, double quotes, and backticks in MySQL</a>)
<ul>
<li>Ascii字符串常量: 'ABCD'</li>
<li>Unicode字符串常量: N'ABCD'</li>
</ul></li>
<li>数值常量：
<ul>
<li>整型常量: 34, 89</li>
<li>浮点型常量: 1.45 6.37</li>
</ul></li>
<li>十六进制常量：默认类型是字符串！！可以使用函数转为数字处理 cast(... as unsigned)。字符串或数值也可以用 hex()转为16进制常量。通常以字符串常量的形式书写，0x'4D7953514C'，每2个十六进制数字可以被转换为一个Ascii字符(4D-&gt;M, 79-&gt;y)，其最前面有大写字母"X"或小写的"x"，也可以用0x4D7953...的形式书写，此时不需要单引号。</li>
<li>日期时间常量：单引号括起来的字符串。'2019-10-10'</li>
<li>位字段值(BIT列的值)：b'value'的形式书写，value是二进制序列。</li>
<li>布尔值：TRUE = 1 / FALSE =0</li>
<li>NULL值</li>
</ul>
<h3 id="变量">(2)变量</h3>
<ul>
<li>用户变量: <span class="citation" data-cites="UserVar">@UserVar</span></li>
<li>系统变量: @<span class="citation" data-cites="systemVar">@systemVar</span></li>
</ul>
<h3 id="运算符">(3)运算符</h3>
<ul>
<li>算数运算符: + - * / %</li>
<li>位运算符: &amp;, | ,^ ,~ ,&gt;&gt; ,&lt;&lt;</li>
<li>比较运算符：=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, !=, &lt;=&gt;(当两个值都为NULL时，结果为1，否则为0)</li>
<li>逻辑运算符：NOT/! , OR/||, AND/&amp;&amp;, XOR</li>
</ul>
<h3 id="表达式">(4)表达式</h3>
<h3 id="内置函数">(5)内置函数</h3>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第四章 SQL与关系数据库基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>数原 4.1 SQL概述</title>
    <url>/2019/11/29/%E6%95%B0%E5%8E%9F-4-1-SQL%E6%A6%82%E8%BF%B0/%E6%95%B0%E5%8E%9F-4-1-sql%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="三sql的组成">三、SQL的组成</h2>
<p>1.数据定义语言 DDL：创建、修改、删除各种数据库对象。</p>
<ul>
<li>create</li>
<li>Alter</li>
<li>Drop</li>
</ul>
<p>数据库的对象有：</p>
<ul>
<li>表</li>
<li>视图</li>
<li>触发器</li>
<li>存储过程</li>
<li>默认约束</li>
<li>规则</li>
</ul>
<p>2.数据操纵语言 DML：操纵各种数据库对象</p>
<ul>
<li>select</li>
<li>insert</li>
<li>update</li>
<li>delete</li>
</ul>
<p>3.数据控制语言 DCL：用于安全管理</p>
<ul>
<li>revoke：收回用户或角色的权限，但用户仍然可以从其所属角色中继承权限。</li>
<li>grant：把执行语句的权限、数据对象的可操作权限，赋予用户或角色。</li>
</ul>
<p>4.嵌入式SQL、动态SQL（不做介绍）</p>
<ul>
<li>在高级语言中使用SQL的方法</li>
</ul>
<p>5.SQL 调用规则，SQL会话规则（本书不做介绍）</p>
<ul>
<li>SQL调用：一个SQL源文件，调用另一个SQL源文件</li>
<li>SQL会话：应用程序连接到多个SQL服务器中的某一个，并与之交互。</li>
</ul>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第四章 SQL与关系数据库基本操作</category>
      </categories>
  </entry>
  <entry>
    <title>数原 3.3 关系数据库设计方法</title>
    <url>/2019/11/29/%E6%95%B0%E5%8E%9F-3-3-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/%E6%95%B0%E5%8E%9F-3-3-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一关系数据库设计过程与各级模式">一、关系数据库设计过程与各级模式</h2>
<p>关系数据库设计的各阶段，会形成数据库的各级模式。</p>
<h2 id="二概念结构设计方法">二、概念结构设计方法</h2>
<p>关系数据库的概念模型设计，采用自顶向下法，具有2个步骤：</p>
<ol type="1">
<li>建立局部信息结构</li>
<li>将局部信息结构，合并为全局信息结构，并优化</li>
</ol>
<h3 id="er图的表示方法">1.ER图的表示方法</h3>
<p>略</p>
<h4 id="两个实体型之间的联系">(1)两个实体型之间的联系</h4>
<p>设有实体集A B，它们所属的两个实体型之间的联系有 ##### 1对1联系(1:1) 如果实体集A中的每 1 个实体，在实体集B中至多有 1 个实体与之联系。<br>
反过来，实体集B中的每 1 个实体，在实体集A中至多有 1 个实体与之联系。</p>
<h5 id="对多联系1n">1对多联系(1:N)</h5>
<p>如果实体集A中的每 1 个实体，在实体集B中有 N 个实体与之联系。<br>
实体集B中的每 1 个实体，在实体集A中至多有 1 个与之联系。</p>
<h5 id="多对多联系mn">多对多联系(M:N)</h5>
<p>如果实体集A中的每 1 个实体，在实体集B中有 N 个实体与之联系。<br>
实体集B中的每 1 个实体，在实体集A中有 M 个实体与之联系。</p>
<h4 id="两个以上实体型之间的联系">(2)两个以上实体型之间的联系</h4>
<p>也存在 1：1， 1：N， M：N 的联系。</p>
<h4 id="单个实体型内的联系">(3)单个实体型内的联系</h4>
<p>同一个实体型内的各实体之间也可以存在上诉3种关系。</p>
<p>比如：职工实体型内部，一个职工可以”领导“多名职工，任意一名职工至多只能被一名职工直接领导。因此属于 1：N 联系。</p>
<h3 id="局部信息结构设计">2.局部信息结构设计</h3>
<p>局部信息结构：不同的用户视图范围内的信息结构。</p>
<p>局部信息结构的设计步骤：</p>
<ol type="1">
<li>确定局部范围：根据需求分析报告中标明的用户视图范围来确定，用户视图范围=子模式（外模式）</li>
<li>选择实体：在局部范围内选择合适的信息单位，作为局部信息结构的基本实体。</li>
<li>选择实体的标识属性（主码）：实体依赖于主码的存在，确定了主码就确定了实体。</li>
<li>确定实体间的联系：试行匹配法可以分析实体间是否存在联系——在视图范围内，逐一取出实体与其他实体逐个匹配，探讨两者间是否存在联系（比如某任务同时使用了它们）。</li>
<li>确定实体的说明属性（非主属性）：说明属性描述了实体的一般特征。属性分配到某个实体是否合理，取决于该属性是否可通过该实体的主码找到，并且它们之间在应用中具有某种联系。有可能多个实体的主码都能联系到同一说明属性，此时可将该属性分配到使用频率最高的实体中去。</li>
</ol>
<h3 id="全局信息结构设计">3.全局信息结构设计</h3>
<p>全局信息结构设计：将所有的局部信息结构，合并成一个全局信息结构。</p>
<p>合并，是一个不断发现和解决冲突的过程。</p>
<p>冲突包含了：属性冲突、命名冲突、结构冲突。</p>
<h4 id="属性冲突">1.属性冲突</h4>
<ul>
<li>属性域的冲突：年龄，有的局部信息结构用出生日期，有的用多少岁表示。</li>
<li>属性单位的冲突：身高，有的局部信息结构用cm，有的用 m。</li>
</ul>
<h4 id="命名冲突">2.命名冲突</h4>
<ul>
<li>同名异议：不同意义的实体型、联系型，在不同的局部信息结构中使用了相同的名字。</li>
<li>异名同义：相同意义的实体型、联系型，在不同的局部应用中使用了不同的名字。</li>
</ul>
<h4 id="结构冲突">3.结构冲突</h4>
<ul>
<li>同一对象，在一个局部ER图中是实体，在另一个局部ER图中是属性</li>
<li>同一实体，在不同的局部ER图中的属性个数和类型不同。</li>
<li>相同两个实体之间的联系，在不同的局部ER图中是不同的类型。</li>
</ul>
<p>解决办法：<br>
属性冲突、命令冲突，通过协商、讨论来解决。<br>
结构冲突，通过技术手段解决。<br>
比如：把实体转为属性，或者属性转为实体，使同一对象具有统一的抽象。<br>
比如：取不同局部ER图中属性的并集，做为全局信息结构中同一实体的属性集，并统一属性的数据类型。</p>
<p>全局ER图的三个目标：</p>
<ol type="1">
<li>实体型尽可能少</li>
<li>属性尽可能少</li>
<li>实体型之间的联系无冗余</li>
</ol>
<h2 id="三逻辑结构设计方法">三、逻辑结构设计方法</h2>
<p>逻辑结构设计的任务：把概念模型，转换为，具体的DBMS所支持的逻辑数据模型（模式和外模式）。</p>
<p>在关系数据库中，逻辑结构设计的任务：把概念设计阶段得到的ER图，转换为，关系DBMS支持的关系模型，通常包括3项工作：</p>
<ol type="1">
<li>将ER图转为关系数据模型</li>
<li>优化关系数据模型</li>
<li>设计各用户的外模式</li>
</ol>
<h3 id="er图转换为关系模型">1. ER图转换为关系模型</h3>
<p>ER图转换为关系模型的原则：</p>
<ul>
<li>一个实体转换为一个关系模式：实体的属性 --&gt; 关系的属性，实体的主码 --&gt; 关系的主码。</li>
<li>1:1联系：
<ul>
<li>转换为独立的关系模式：”相连实体的主码 + 联系本身的属性“ --&gt; 独立关系的属性，每个实体的主码 --&gt; 独立关系的候选码，独立关系自行决定哪个候选码作为主码。</li>
<li>与任意一端实体对应的关系模式合并：在选做合并端实体的关系中，加入”另一个实体的主码 + 联系自身的属性“。</li>
</ul></li>
<li>1:N联系：
<ul>
<li>转换为独立的关系模式：”相连实体的主码 + 联系自身的属性“--&gt; 独立关系的属性，N端实体的主码 --&gt; 独立关系的主码。</li>
<li>与N端对应的关系模式合并：在N端实体对应的关系中，加入联系自身的属性。</li>
</ul></li>
<li>M:N联系：只能转为独立关系，”相连实体的主码 + 联系自身的属性“ --&gt; 关系的属性，相连实体主码的组合 --&gt; 关系的主码</li>
<li>二个以上实体型的联系：同 M:N 联系</li>
<li>具有相同主码的关系模式可以合并。</li>
</ul>
<p>注意：ER图转换时，不仅要考虑主码、属性，还应该考虑外键，从而实现参照完整性。</p>
<h3 id="数据模型的优化">2.数据模型的优化</h3>
<p>逻辑设计的结果不是唯一的，因此可以通过修改、调整逻辑模型，进一步提高性能或满足实际需要，这就是逻辑模型的优化。</p>
<p>关系数据模型的优化理论基础是：关系规范化理论，方法如下：</p>
<ul>
<li>消除各关系模式之间的冗余联系</li>
<li>确定关系模式内，各属性间的函数依赖关系</li>
<li>判断每个关系模式的范式，根据实际需要确定合适的范式</li>
<li>通过模式分解，提高数据操作的效率、存储空间的利用率</li>
</ul>
<h3 id="设计用户子模式">3.设计用户子模式</h3>
<p>利用视图，设计用户子模式。</p>
<p>数据库全局逻辑模式是从系统的时间效率、空间效率、易维护等角度出发的，而用户的外模式更注重用户的习惯和方便。</p>
<p>定义外模式：</p>
<ul>
<li>利用视图机制，重新定义某些属性的别名，使其符合用户的习惯。</li>
<li>不同级别的用户，定义不同的视图，保证系统的安全性</li>
<li>简化用户对系统的使用：将复杂的查询事先定义为视图，用户选择不同的视图进行查询，从而简化用户操作。</li>
</ul>
<h2 id="四物理设计方法">四、物理设计方法</h2>
<p>关系数据库的存取路径对用户透明，好处是用户无需关心存储结构和存取方法，缺点是缺乏控制存取效率的手段。而物理设计就提供了改善存取效率的方法：索引和聚集。</p>
<p>物理设计的任务：通过对关系建立索引和聚集，来实现与应用相关数据的逻辑连接和物理聚集。</p>
<h3 id="建立索引">1.建立索引</h3>
<p>索引会增加DBMS对索引的维护开销（保持索引与关系的一致性）。 因此，建立索引的数据对象，只能有低频率的插入、修改、删除操作。<br>
而建立索引的属性，应该是所在关系中高频使用的属性。</p>
<p>建立索引的方式分为：</p>
<ul>
<li>静态建立索引：预先在数据库中建立的索引，之后，应用程序都可以直接使用，适合于用户较多、使用周期较长的数据。</li>
<li>动态建立索引：临时由应用程序或在数据库建立的索引，适合于满足单个用户需要、临时使用。</li>
</ul>
<h3 id="建立聚集">2.建立聚集</h3>
<p>将相关数据<strong>集中存放</strong>，从而提高相关数据的IO数据命中率，改善存取速度的物理存储技术，称为聚集。</p>
<p>相关数据：在一个或多个关系中，在垂直（属性组）或水平（元组集合）上，把经常一起使用的数据分为一组。</p>
<p>集中存放：把相关数据放在一个物理块、磁道、柱面中，或相邻的物理区域中。</p>
<p>只有数据使用频率高、数据量大、更新操作较少的数据，才有必要建立聚集。</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第三章 数据库设计</category>
      </categories>
  </entry>
  <entry>
    <title>数原 3.2 数据库设计的基本步骤</title>
    <url>/2019/11/29/%E6%95%B0%E5%8E%9F-3-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/%E6%95%B0%E5%8E%9F-3-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>本节主要讨论数据库结构设计所涉及的几个基本步骤（需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库的运行和维护），而不讨论数据库的行为设计，因为行为设计和程序设计的区别不大。</p>
<h2 id="一需求分析">一、需求分析</h2>
<p>需求分析分为4个步骤：</p>
<ul>
<li>确定数据库范围</li>
<li>分析数据应用过程</li>
<li>收集与分析数据</li>
<li>编写需求分析报告</li>
</ul>
<h3 id="确定数据库范围">1.确定数据库范围</h3>
<p>理想情况：数据库范围尽可能覆盖现在和将来的、组织中所有的应用领域。</p>
<p>现实情况：首先考虑当前组织所必须的应用要求。</p>
<p>借助 “机构与职能关系图” 来确定数据库应该支持的哪些功能，及功能的主次序列。</p>
<p>机构与职能关系图，还可以帮助概念设计的局部化处理和子模式处理。</p>
<h3 id="应用过程分析">2.应用过程分析</h3>
<p>数据应用过程分析：分析数据与数据处理间的关系。</p>
<p>分析每个部门或功能要用到哪些数据、数据使用的顺序、对数据作何处理、处理的结果等。</p>
<p>应用过程分析的结果是数据库结构设计的重要依据，从中可以初步得出：</p>
<ul>
<li>哪些数据要存入数据库中</li>
<li>哪些数据仅作为报告输出，不需存入数据库</li>
<li>看出数据的增删查改权限和共享范围</li>
<li>作为应用程序编写的依据</li>
</ul>
<p>应用过程分析的产物是数据流程图，有多种形式。<br>
数据流程图应以局部部门或相对独立的功能为单位，从而将问题局部化，利于分块设计。</p>
<h3 id="收集与分析数据">3.收集与分析数据</h3>
<p>了解并分析数据的组成格式和操作特征、数据内部的数据元素的语义及相互关系，收集整理归档。</p>
<p>收集与分析的对象：数据流程图所涉及的数据，包括报表、文件、单据、各种原始资料，可以从三个方面开展工作：静态结构、动态结构、数据约束，设计人员可以按部门或职能划分去收集数据。</p>
<h4 id="静态结构">(1)静态结构</h4>
<p>不施加应用操作时，数据的状态。</p>
<h5 id="i.数据分类表">i.数据分类表</h5>
<p>描述了客观存在的、具有独立意义的一类数据（一种报表、一种文件、一种票据）的总体情况。</p>
<h5 id="ii.数据元素表">ii.数据元素表</h5>
<p>即某类数据的属性，或叫数据项、数据元素。</p>
<h4 id="动态结构">(2)动态结构</h4>
<p>应用操作施加之后，数据的状态。</p>
<h5 id="i.任务分类表">i.任务分类表</h5>
<p>根据数据流程图，可以把业务处理流程划分成不同的任务。</p>
<p>任务：为完成某个处理功能的、相对独立的操作序列。如处理某项业务、查询业务数据、统计报表等。</p>
<h5 id="ii.数据操作特征表">ii.数据操作特征表</h5>
<p>描述了任务和数据之间的关系。<br>
任务分类表中的每个任务，和，数据分类表中的与该任务有关的每类数据，都应该在操作特征表中有一条记录来反映其关系。</p>
<p>数据操作特征表，为分析数据的共享性、时间响应要求、数据的操作权限提供了重要依据。</p>
<h4 id="数据约束">(3)数据约束</h4>
<p>使用数据时的要求，包括：</p>
<ul>
<li>安全保密性：权限</li>
<li>完整性：正确性、相容性、一致性</li>
<li>响应时间：读写的时间限制</li>
<li>数据恢复：</li>
</ul>
<h3 id="编写需求分析报告">4.编写需求分析报告</h3>
<p>需求分析报告，是在需求分析过程中逐渐形成的，是对需求分析的总结。也是业务人员和设计人员的共同语言。</p>
<p>需求分析报告应该包括：</p>
<ul>
<li>数据库的应用功能目标：数据库的应用范围，和，应覆盖的功能。</li>
<li>明确不同用户的视图范围：根据机构职能图、数据流程图、任务分类表，明确不同部门或不同功能的视图范围。</li>
<li>应用处理过程说明：包括数据流程图、任务分类表、数据操作特征表，以及操作过程说明书（说明各任务的逻辑执行步骤）</li>
<li>数据字典：用于存储和检索各种数据描述，即元数据。通常包括：数据分类表、数据元素表、各类原始资料。</li>
<li>数据量：根据数据分类表中的静态数据量，和，操作特征表中的动态数据量，进行统计计算，求出数据总量。</li>
<li>数据约束：同前述。</li>
</ul>
<h2 id="二概念结构设计">二、概念结构设计</h2>
<p>在需求分析报告的基础上，按照某种方法，建立与软硬件无关的、理想的信息结构——概念模型。</p>
<p>概念结构设计的方法有：自顶向下（ER图），自底向上（不需要学习）。</p>
<h2 id="三逻辑结构设计">三、逻辑结构设计</h2>
<p>目标：将概念层数据模型，转换为，特定DBMS的逻辑层数据模型（层状、网状、关系，对象）。</p>
<p>这里的”特定“并不是指具体的、实际的DBMS，而是按支持的逻辑层数据模型分类的一大类DBMS，比如层状模型DBMS、网状模型DBMS、关系模型DBMS、对象模型DBMS。</p>
<h3 id="逻辑结构设计的输入与输出信息">逻辑结构设计的输入与输出信息</h3>
<p>逻辑结构设计的输入信息：</p>
<ul>
<li>概念设计阶段得到的概念模型，独立于特定DBMS</li>
<li>数据约束：响应时间、权限、完整性、数据恢复的要求</li>
<li>数据量和使用频率</li>
<li>特定DBMS的特性：DBMS支持的数据模型、数据定义语言等</li>
</ul>
<p>逻辑结构设计的输出信息：</p>
<ul>
<li>特定DBMS的逻辑层数据模型（</li>
<li>不同用户的外部视图（外模式），或称子模式</li>
<li>物理设计说明：包括存入数据库的数据量、使用频率、时间响应要求</li>
<li>程序设计说明：各程序名、执行步骤、存取数据的名称顺序操作特征（增删查改）</li>
</ul>
<h3 id="逻辑结构设计的步骤">逻辑结构设计的步骤</h3>
<ul>
<li>模型转换：将概念层数据模型，转换为，特定DBMS的逻辑数据模型（层状、网状、关系、对象）</li>
<li>子模式设计：抽取不同用户看到的子模式（外模式）</li>
<li>编制应用程序设计说明：为应用程序设计提供依据和指导</li>
<li>设计评价：通过程序设计说明中的程序执行步骤，在子模式中模拟执行，来考察模式和子模式是否满足需求，有无遗漏，进一步评估数据容量、存取效率，为物理设计提供参考</li>
</ul>
<h2 id="四物理设计">四、物理设计</h2>
<p>根据特定数据库的逻辑数据模型，构造物理层数据模型。</p>
<p>需要确定：<br>
存储结构、存取方法、建立索引和聚集、物理块的大小、缓冲区数量和大小、是否压缩数据等。</p>
<h2 id="五数据库实施">五、数据库实施</h2>
<p>在实际的DBMS中建立数据库并运行。</p>
<p>实施工作包括：</p>
<ul>
<li>加载数据：由人工完成数据的收集、分类、整理，由输入程序完成数据的校验和输入。</li>
<li>应用程序设计：应用程序的设计，是跟随数据库结构设计的进展而并行前进的。
<ul>
<li>需求分析阶段，了解了任务的分类、功能、处理流程及与数据的联系。</li>
<li>逻辑设计阶段，根据模型和子模型，具体划分应用程序的功能模块，进一步明确了各模块的名称、执行逻辑及与数据的联系，从而基本确定了应用程序的框架。</li>
<li>物理设计阶段，根据物理模型，进一步修改和完善应用程序设计说明。</li>
</ul></li>
<li>数据库试运行：可以模拟生产环境，进行试运行。</li>
</ul>
<h2 id="六数据库运行和维护">六、数据库运行和维护</h2>
<p>经过试运行，确认系统无故障或暂未发现故障后，系统即可投入实际运行。</p>
<p>重组：当空间利用率和存取效率下降时，调整数据的存储位置，整理了碎片，从而提高空间利用率和存取效率。</p>
<p>重构：因为应用需求的变化、拓展，或当初的设计考虑不周，部分修改数据库的逻辑结构、物理结构。</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第三章 数据库设计</category>
      </categories>
  </entry>
  <entry>
    <title>数原 3.1 数据库设计概述</title>
    <url>/2019/11/29/%E6%95%B0%E5%8E%9F-3-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/%E6%95%B0%E5%8E%9F-3-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="一数据库的生命周期">一、数据库的生命周期</h2>
<ul>
<li>数据库分析和设计阶段
<ul>
<li>需求分析</li>
<li>概念设计</li>
<li>逻辑设计</li>
<li>物理设计</li>
</ul></li>
<li>数据库实现和操作阶段
<ul>
<li>数据库的实现</li>
<li>操作与监督</li>
<li>修改与调整</li>
</ul></li>
</ul>
<h2 id="二数据库设计的目标">二、数据库设计的目标</h2>
<ul>
<li>满足应用功能需求</li>
<li>良好的数据库性能</li>
</ul>
<h2 id="三数据库设计的内容">三、数据库设计的内容</h2>
<ul>
<li>数据库结构设计：静态的，根据应用环境设计数据库的模式结构。
<ul>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理结构设计</li>
</ul></li>
<li>数据库行为设计：动态的，确定数据库用户的行为和动作。</li>
</ul>
<h2 id="四数据库设计的方法">四、数据库设计的方法</h2>
<p>数据库设计方法，是设计数据库的指导原则。</p>
<ul>
<li>直观设计法：没有理论基础，依靠经验和技巧，已被淘汰。</li>
<li>规范设计法：
<ul>
<li>新奥尔良设计法：较为完整和权威的方法，4个阶段：需求分析、概念结构设计、逻辑结构设计、物理结构设计。注重结构设计，不考虑行为设计。</li>
<li>基于ER模型的设计法：在需求分析的基础上画出ER图，建立模式，再将模式转换为特定DBMS的概念模式。</li>
<li>基于3NF的设计法：需求分析的基础上，确定数据库的模式、属性、依赖关系，然后用模式分解，规范化成多个3NF的关系模式。</li>
</ul></li>
<li>计算机辅助设计法：CASE工具。</li>
</ul>
<h2 id="五数据库设计的过程">五、数据库设计的过程</h2>
<p>数据库从设计到运行的阶段分为：</p>
<ul>
<li>需求分析阶段</li>
<li>结构设计阶段
<ul>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理结构设计</li>
</ul></li>
<li>行为设计阶段
<ul>
<li>功能设计</li>
<li>事务设计</li>
<li>程序设计</li>
</ul></li>
<li>数据库实施阶段
<ul>
<li>加载数据库数据</li>
<li>调试运行应用阶段</li>
</ul></li>
<li>数据库运行和维护阶段</li>
</ul>
<p>数据库设计过程，是一个反复修改、反复设计的迭代过程。</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第三章 数据库设计</category>
      </categories>
  </entry>
  <entry>
    <title>数原 2.3 关系数据库的规范化理论</title>
    <url>/2019/11/29/%E6%95%B0%E5%8E%9F-2-3-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA/%E6%95%B0%E5%8E%9F-2-3-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p>规范化理论研究的是：</p>
<ul>
<li>关系模式中属性间的依赖关系，</li>
<li>属性间的依赖关系对关系模式的性能的影响。</li>
<li>好的关系模式应该具备的哪些性质</li>
<li>好的关系模式的设计算法</li>
</ul>
<p>关系数据库的规范化理论，是设计数据库的理论基础，是鉴别关系模式好坏的理论标准，能够帮助数据库设计人员预测可能出现的问题。</p>
<p>P.S. 关系模式：关系数据库中，对关系的结构和属性的描述，即表结构。</p>
<h2 id="一关系模式中可能存在的冗余和异常问题">一、关系模式中可能存在的冗余和异常问题</h2>
<ul>
<li>数据冗余：由完全依赖导致的非主属性的重复存储。</li>
<li>更新异常：由数据冗余导致的潜在的不一致性</li>
<li>插入异常：主码有多个属性，而插入行的主码中部分属性有空值，不允许插入</li>
<li>删除异常：示例中用一个表来记录供应商基本信息和供货信息，所以会出现这种情况。</li>
</ul>
<p>这些问题都与数据依赖有关。</p>
<p>数据依赖：是关系中的属性，在现实世界中的语义之间的约束关系。<br>
比如：假设每个供应商只有一个地址，给定了供应商名字后，就可以确定其地址。</p>
<p>数据依赖有很多种，最重要的是函数依赖(FD, Functional Dependancy)和多值依赖(MVD, Multi-Valued Dependancy)。</p>
<h2 id="二函数依赖与关键字">二、函数依赖与关键字</h2>
<p>函数依赖：在关系R中，对属性X的每个值，属性Y都只有唯一值与之对应，称“X函数决定Y”、“Y函数依赖X”，记作 <span class="math inline">\(X \rightarrow Y\)</span>。</p>
<p>换句话说，确定了属性X的某个值，就确定了属性Y的值（1对1），就称为Y函数依赖于X。</p>
<p>属性X称为决定因素。</p>
<p>如果X不能函数决定Y，或叫，Y不能函数依赖X，记作 <span class="math inline">\(X \nrightarrow Y\)</span></p>
<h3 id="完全函数依赖">（1）完全函数依赖</h3>
<p>任意关系R，X,Y是属性集，X' 是 X 的任意真子集，<span class="math inline">\(X \rightarrow Y\)</span>，但 <span class="math inline">\(X&#39; \nrightarrow Y\)</span>），此时称：X 完全函数决定 Y，或称：Y 完全函数依赖于 X。</p>
<p>注意：X 不一定就是候选码，函数依赖是属性间的关系，不是属性集和元组的关系。 ### （2）部分函数依赖 任意关系R，X,Y是属性集，X' 是 X 的某个真子集，<span class="math inline">\(X \rightarrow Y\)</span>，且 <span class="math inline">\(X&#39; \rightarrow Y\)</span>），此时称：X 部分函数决定 Y，或称：Y 部分函数依赖于 X。</p>
<p>注意：X 不一定就是超码，函数依赖是属性间的关系，不是属性集和元组的关系。 ### （3）传递函数依赖 任意关系R，X,Y,Z是不同的属性集，<span class="math inline">\(X \rightarrow Y\)</span>，<span class="math inline">\(Y \nrightarrow X\)</span>，而 <span class="math inline">\(Y \rightarrow Z\)</span>，那么 <span class="math inline">\(X \rightarrow Z\)</span>，此时称：X 传递函数决定 Z，或称：Z 传递函数依赖于 X。</p>
<p>比如：有关系模式 书基本信息（书的ISBN，出版社名称，出版社地址），书ISBN可以决定出版社名称，但出版社名称无法决定书ISBN（因为一个出版社不止出一本书），出版社名称可以决定出版社地址，因此知道了书ISBN，就知道了出版社地址，称：出版社地址传递函数依赖于书ISBN。</p>
<h6 id="更严格的候选码的定义">更严格的候选码的定义</h6>
<p>可以根据函数依赖的定义，推导出更严格的关键字的定义：<br>
任意关系R，全部属性集合为U，X是U的子集，若 <span class="math inline">\(X \rightarrow U\)</span>，则 X 是关系R的一个候选码。</p>
<h2 id="三范式与关系规范化过程">三、范式与关系规范化过程</h2>
<p>范式：规范形式，Normal Form，规范性要求。</p>
<p>根据要求的不同，范式包括：第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、BC范式(BCNF)等等。</p>
<p>关系数据库中存储的各种关系，它们的关系模式必须在不同程度满足范式。<br>
比如某些关系模式满足1NF，某些满足2NF。</p>
<p>规范化(Normalization)：满足较低层次范式的关系模式，可以通过模式分解，分解出：几个满足高一级范式的关系模式。</p>
<p>现实生活中的很多数据，是不符合任何范式的。<br>
而关系数据库通常要求关系模式必须符合1NF。<br>
因此，必须通过规范化过程，才能将现实世界的数据存储到关系数据库中，同时，也消除了数据冗余、更新异常、插入异常、删除异常。</p>
<h3 id="第一范式">（1）第一范式</h3>
<p>关系数据库中的关系模式，至少应满足1NF。</p>
<p>1NF：关系R的每一列具有原子性，不可再分。</p>
<p>教材上讲：列和元组都不可再分，实际上不严谨。包括举的例子也不好。</p>
<p>满足了1NF，可能存在非主属性部分函数依赖候选码的情况，由此可能导致数据冗余、插入异常、删除异常等问题。</p>
<p>解决办法：消除非主属性对候选码的部分函数依赖——将部分函数依赖的属性分离出去组成新关系，原关系中仅保留完全函数依赖的非主属性。</p>
<h3 id="第二范式">（2）第二范式</h3>
<p>2NF：关系R为1NF，且其所有的非主属性都完全函数依赖于候选码。</p>
<p>满足2NF的关系模式，可能存在非主属性传递函数依赖于候选码的问题，仍然可能产生插入异常、删除异常等问题。</p>
<p>解决办法：消除非主属性对候选码的传递函数依赖。</p>
<h3 id="第三范式">（3）第三范式</h3>
<p>3NF：关系R为2NF，且其所有非主属性都不传递函数依赖于候选码。</p>
<p>但满足3NF的关系，有时仍然存在插入异常、删除异常等问题。比如：当主属性间存在函数依赖时。</p>
<p>解决办法：在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。</p>
<h3 id="bc范式">（4）BC范式</h3>
<p>BCNF：关系R是3NF，其所有的决定因素都包含一个候选码。</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第二章 关系数据库</category>
      </categories>
  </entry>
  <entry>
    <title>数原 2.1 关系数据库概述</title>
    <url>/2019/11/29/%E6%95%B0%E5%8E%9F-2-1-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/%E6%95%B0%E5%8E%9F-2-1-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>略</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第二章 关系数据库</category>
      </categories>
  </entry>
  <entry>
    <title>数原 2.2 关系数据模型</title>
    <url>/2019/11/29/%E6%95%B0%E5%8E%9F-2-2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/%E6%95%B0%E5%8E%9F-2-2-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>数据模型必须具有数据结构、数据操作、数据约束三要素。<br>
逻辑层模型的关系模型也同样具有三要素：</p>
<ul>
<li>关系数据结构</li>
<li>关系数据操作集合</li>
<li>关系完整性约束</li>
</ul>
<h2 id="一关系数据结构">一、关系数据结构</h2>
<p>关系模型只有一种数据结构：关系（二维表），因此 关系模型用关系来表示实体、实体间联系。</p>
<p>基于关系模型的关系数据库就是关系的集合，并以二维表的形式组织数据。</p>
<h3 id="关系数据库的基本术语">关系数据库的基本术语</h3>
<p>1.表(Table)<br>
表也称为”关系“，是一个二维的数据结构。由表名 + 列 + 数据行组成。</p>
<p>2.关系（Relation)<br>
一个关系逻辑上对应一张二维表。</p>
<p>可以给每个关系取一个名字进行标识（即表名）。</p>
<p>关系有三种类型：</p>
<ul>
<li>基本关系：基本表，是实际存在的表，存储了数据。</li>
<li>查询表：查询结果对应的表</li>
<li>视图表：由基表或其他视图生成的表，是虚表，视图中不存储数据。</li>
</ul>
<p>3.列(Column)<br>
列，也称为字段(Field)或属性(Attribute)。</p>
<p>列是实体的属性，具有确定的数据类型。</p>
<p>列必须有一个名称，称为字段名/属性名。</p>
<p>4.属性(Attribute)<br>
列即属性。</p>
<p><em>属性的个数</em>称为关系的<strong>元</strong>或<strong>度</strong>。<br>
具有X个属性的关系是 X元关系/X度关系。</p>
<p>属性的取值范围称为”值域“。</p>
<p>5.行(Row)<br>
行，称为元组(Tuple)或记录(Record)。</p>
<blockquote>
<p>元组：因为属性称为元，一条记录就是元的组合，因此叫元组。</p>
</blockquote>
<p>一行数据就是一个元组/一条记录，由若干个字段值/属性值组成。</p>
<p>6.元组(Tuple)<br>
略</p>
<p>7.分量(Component)<br>
某元组的每个属性值，都是该元组的分量。</p>
<p>如：学习基本信息登记表中，元组(201311103,王一鸣,女,1996-03-25,河北,汉,AC1301,XXX2)，它的每一个属性值 201311103、王一鸣、女、1996-03-25、河北,汉、AC1301、XXX2 都是该元组的分量。</p>
<p>8.码或键(Key)<br>
能唯一标识元组的属性(属性组)，称为该关系的码或键。</p>
<p>9.超码/超键(Super Key)<br>
如果一个码，即使移除某个属性，它仍然是这个关系的码，那么它就是这个关系的超码/超键。</p>
<p>每个关系有一个默认的超码/超键：所有属性的集合，也是该关系的最大超码/超键。</p>
<p>比如：（学号、姓名）（学号、性别、姓名）（学号+属性1+属性2+...）都是超码/超键。</p>
<p>注意：<br>
码/键和超码/超键是一样的，它们都允许多余属性的存在。</p>
<p>10.候选码/候选键(Cadidate Key)<br>
移除了任何属性都不能作为码/键的码/键，称为候选码/候选键。</p>
<p>换句话说，候选码/候选键是不具有多余属性的超码/超键。</p>
<p>候选码/候选键是关系的最小超码/超键。</p>
<p>注意：<br>
一个关系，可以有多个候选码/候选键，比如学生基本信息表，可以有学号、身份证两个候选码/候选键。</p>
<p>11.主码/主键(Primary Key)<br>
如果某关系具有一个或多个候选码/候选键，从中选定一个作为元组的唯一标识，这样的候选码/候选键就称为主码/主键。</p>
<p>12.全码/全键(All-Key)<br>
如果某关系的所有属性构成了该关系的主码/主键，这样的主码/主键就称为全码/全键。</p>
<p>13.主属性(Primary Attribute)，非主属性(Nonprimary Attribute)<br>
候选码中的属性是主属性，非候选码中的属性是非主属性。</p>
<p>如：学生基本信息表，学号、身份证号是主属性，其他属性是非主属性。</p>
<p>14.外码/外键(Foreign Key)<br>
某关系中的某些属性（属性组）不是该关系的候选码，但却是另一个关系的主码，则该属性（属性组）是该关系的外码/外键。</p>
<p>如：班号不是学生基本信息表的候选码，却是班级表的主码，因此班号是学生基本信息表的外码。</p>
<p>15.参照关系(Referencing Relation)，被参照关系(Referenced Relation)<br>
<em>这里的关系是关系代数的用语，就是指二维表。</em></p>
<p>参照关系和被参照关系，是通过外码相关联的两个关系。</p>
<p>外码作为主码的关系，是被参照关系。也叫主关系。<br>
外码所在的关系，是参照关系，也叫从关系。</p>
<p>被参照关系和参照关系，通常是一对多的联系。<br>
即，一个关系将外码作为主码，而有多个关系将外码作为非主属性。</p>
<p>如：班级表是被参照关系，学生基本信息表是参照关系，两者通过”班号“这个外码相关联。</p>
<p>16.域(Domain)<br>
属性的取值范围。</p>
<p>17.数据类型(Data Type)<br>
每个属性都有确定的数据类型。</p>
<p>18.关系模式(Relation Schema)<br>
特别注意：<br>
关系模型（一种数据模型）有”型“和”值“的区别（见第一章第四节 数据模型）。<br>
而这里讲的叫“关系模式”，不是“关系模型”，一字之差。</p>
<p>关系数据库也有型和值之分。</p>
<ul>
<li>关系模式是对关系的结构和属性的描述（即表结构），是”型“。<br>
</li>
<li>关系则是具体的元组的集合，是关系模式在某一时刻的内容，是”值“。</li>
</ul>
<p>关系模式静态的、稳定的。<br>
关系是动态的、随时间不断变化的。</p>
<p>实际工作中，会把关系模式和关系都笼统的称为关系，需要从上下文来区分。</p>
<p>19.关系数据库(Relation Database)<br>
关系数据库：以关系模型作为数据的逻辑模型，并以关系来组织数据的一类数据库，其数据操作以关系代数为基础。</p>
<p>关系数据库对关系的限定：</p>
<ol type="1">
<li>每个属性都不可分解：不允许表中有表。</li>
<li>每个关系只有一种关系模式：该关系的关系模式中，属性的数据类型、属性个数是固定不变的。</li>
<li>关系模式中的属性必须有名字，且在同一个关系模式中，属性名唯一，不允许同名属性。</li>
<li>一个关系中，各元组的候选码的属性值必须不同：否则就不叫候选码</li>
<li>元组的行序不关紧要</li>
<li>关系中，属性的顺序无关紧要</li>
</ol>
<h2 id="二关系数据操作集合">二、关系数据操作集合</h2>
<h3 id="基本的关系操作">1.基本的关系操作</h3>
<p>关系模型的常用操作分为”查询“和”更新“两大类：</p>
<ul>
<li>查询（Query）：标注 * 的是基本操作，其他查询操作可由基本操作定义和导出。
<ul>
<li>选择 *</li>
<li>投影 *</li>
<li>并 *</li>
<li>差 *</li>
<li>笛卡尔 *</li>
<li>连接</li>
<li>交：可用差来完成</li>
<li>除</li>
</ul></li>
<li>更新
<ul>
<li>插入(Insert)</li>
<li>删除(Delete)</li>
<li>修改(Update)</li>
</ul></li>
</ul>
<p>关系操作的特点：操作对象和操作结果都是集合。<br>
这种操作方式也称为”一次一集合方式(set-at-a-time)“。</p>
<h3 id="关系数据语言的分类">2.关系数据语言的分类</h3>
<p>关系操作依靠关系语言来实现。</p>
<p>关系语言的优点：高度的非过程化。<br>
即用户不需要关心存取路径，不必使用循环、递归来完成数据的重复操作等。</p>
<p>关系操作有2种抽象的查询语言和1种应用于关系数据库的实际语言：</p>
<ol type="1">
<li>代数方式（关系代数）：通过”关系代数表达式“来表达查询要求的方式。</li>
<li>逻辑方式（关系演算）：用谓词来表达查询要求的方式。又可分为
<ul>
<li>元组关系演算：谓词为元组</li>
<li>域关系演算：谓词为域（属性）</li>
</ul></li>
<li>SQL语言：结构化查询语言，介于关系代数和关系演算之间的数据语言。SQL 是集 DDL, DML,DCL(数据控制语言）于一体的关系数据语言，也是关系数据库的标准语言。</li>
</ol>
<blockquote>
<p>数据控制语言 DCL：控制数据访问权的指令，用于控制特定用户对数据表、视图、存储程序、用户自定义函数等数据库对象的控制权。由 GRANT 和 REVOKE 两个指令组成。</p>
</blockquote>
<blockquote>
<p>谓词：动词和形容词的统称，主要充当谓语使用。</p>
</blockquote>
<p>关系代数、元组关系演算、域关系演算在表达能力上是等价的。（关系演算暂时不需要了解）</p>
<h3 id="关系代数">3.关系代数</h3>
<p>关系代数操作的三要素：</p>
<ul>
<li>操作对象：操作对象是关系（二维表）</li>
<li>操作符：关系代数运算符包括 ”集合运算符”和“专门的关系运算符“，而比较运算符和逻辑运算符是辅助关系运算符的。</li>
<li>操作结果：操作结果是关系（二维表）</li>
</ul>
<h4 id="a.-传统的集合运算">A. 传统的集合运算</h4>
<p>传统的集合运算以元组为操作对象。</p>
<h6 id="并union">(1)并(Union)</h6>
<p>假设有关系 R1 和 R2，它们的属性个数相同，且属性的数据类型相同，那么R1R2的并运算将得到关系R3。 <span class="math inline">\(R3 =R1 \cup R2\)</span></p>
<p>R3由属于R1或属于R2的所有”不同“元组组成。</p>
<p>不同元组，即R3会消除重复元组。</p>
<h6 id="差differenc">(2)差(Differenc)</h6>
<p>条件同上，R3由属于R1但不属于R2的元组构成。</p>
<p><span class="math inline">\(R3 = R1 - R2\)</span></p>
<p>差集不是普通的减法！</p>
<h6 id="交intersection">(3)交(Intersection)</h6>
<p>条件同上，R3是由同时属于R1和R2的元组构成。</p>
<p><span class="math inline">\(R3 = R1 \cap R2\)</span></p>
<p>交运算也可以用差运算来完成。</p>
<p><span class="math inline">\(R3 = R1- (R1-R2)\)</span> // 需要对差集有理解</p>
<h6 id="笛卡尔积catesian-product">(4)笛卡尔积(Catesian product)</h6>
<p>假设有关系R1,R2，R1是m元关系，R2是n元关系。</p>
<p><span class="math inline">\(R3 = R1 \times R2\)</span></p>
<p>笛卡尔积R3是：由R1和R2的所有元组，重新组合成的一个(m+n)元关系。</p>
<p>前m个分量是R1所有可能的元组的一个成员，后n个分量是R2所有可能的元组的一个成员。</p>
<p>假设R1有r1个元组，R2有r2个元组，那么R3就有r1xr2 个元组。</p>
<h4 id="b.-专门的关系运算">B. 专门的关系运算</h4>
<p>专门的关系运算以”行“和”列“为操作对象。</p>
<p>分为：</p>
<ul>
<li>一元专门关系操作：对单个关系：垂直分解的投影运算，和，水平分解的选择运算</li>
<li>二元专门关系操作：对两个关系：连接运算，和，除运算</li>
</ul>
<h6 id="选择select">(1)选择(select)</h6>
<p>选择运算的关系代数表达式为：<span class="math inline">\(\sigma_{F}(R)\)</span></p>
<p>SQL语句为：<code>select R where F</code></p>
<p>F是常数、属性名、比较运算符、逻辑运算符组成的条件表达式。</p>
<h6 id="投影projection">(2)投影(projection)</h6>
<p>关系代数表达式：<span class="math inline">\(\pi_{A}(R)\)</span></p>
<p>SQL语句： <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">projection <span class="constructor">R(<span class="params">field1</span>,<span class="params">field2</span>,<span class="operator">...</span>,<span class="params">fieldN</span>)</span></span><br><span class="line"><span class="comment">// mysql和sqlserver没有projection,只有 select f1,f2,...,fn from R。因此这里的 projection相当于伪代码</span></span><br></pre></td></tr></table></figure></p>
<p>R是关系名，A是属性序列。</p>
<p>注意：和真实的RDBMS不同，关系代数中的投影运算，会在结果集中消除重复元组！</p>
<h6 id="连接">(3)连接</h6>
<p>假设有关系R和S，</p>
<p>关系代数表达式：这个比较难写，以后来攻克。 <span class="math inline">\(R_i\)</span> 表示 R 的第 i 列属性，<span class="math inline">\(S_j\)</span> 表示 S 的第 j 列属性，<span class="math inline">\(\theta\)</span> 是比较运算符。</p>
<p>连接运算：<br>
从 <span class="math inline">\(R \times S\)</span> 的笛卡尔积结果中，选取满足条件： <span class="math inline">\(R_i \theta S_j\)</span> 的那些元组，构成新的关系。</p>
<p>连接操作，根据比较运算符和比较规则的不同，分为：</p>
<ul>
<li>等值连接：<span class="math inline">\(\theta\)</span>为=的连接操作。</li>
<li>自然连接（特殊的等值连接）：要求R和J中进行等值运算的分量，必须是属性名相同的属性组（允许多个属性组比较），并要在结果中去掉重复的分量（消除重复属性）。</li>
<li>不等连接：<span class="math inline">\(\theta\)</span> 不是=的连接操作。</li>
</ul>
<p>自然连接可用于构造新关系，通常用于具有公共属性的两个关系上，如果两个关系没有公共属性，那么结果会变为笛卡尔积（仅仅得到关系模型而已，并没有满足条件的元组） ###### (4)除(Division) 关系R和关系S拥有共同的属性B、C 。</p>
<p>R÷S得到的属性值就是：在关系R中，但不在关系S中的属性，即A属性</p>
<img src="/2019/11/29/数原-2-2-关系数据模型/数原-2-2-关系数据模型/mupdf_2019-12-01_16-43-52.png">
<p>在R关系中A属性的值可以取{ a1，a2，a3，a4 }</p>
<p>a1值对应的象集为 { (b1,c2) , (b2,c1) , (b2,c3) }</p>
<p>a2值对应的象集为 { (b3,c7) , (b2,c3) }</p>
<p>a3值对应的象集为 { (b4,c6) }</p>
<p>a4值对应的象集为 { (b6,c6) }</p>
<p>关系S在B、C上的投影为 { (b1,c2) , (b2,c1) , (b2,c3) }</p>
<p>只有a1值对应的象集包含关系S的投影集，所以只有a1应该包含在A属性中</p>
<p>所以R÷S =</p>
<table>
<thead>
<tr class="header">
<th>A</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a1</td>
</tr>
</tbody>
</table>
<p>除运算是自然连接的逆运算。</p>
<h2 id="三关系完整性约束">三、关系完整性约束</h2>
<p>数据完整性是指：正确性、相容性、一致性。</p>
<p>数据库的数据完整性是一种语义，涉及2个方面：</p>
<ol type="1">
<li>与现实世界中数据的正确性、相容性、一致性。</li>
<li>数据库内，数据之间的正确性、相容性、一致性</li>
</ol>
<p>数据库是否具备数据完整性，关系到数据库系统能否真实的反映现实世界。</p>
<p>用户对数据库执行插入、删除、更新操作时，必须经受完整性规则的检查，从而保证数据库数据的完整性。</p>
<p>完整性规则：对关系的约束，也称为完整性约束。</p>
<p>完整性约束有3类：</p>
<ol type="1">
<li>实体完整性约束</li>
<li>参照完整性约束</li>
<li>用户定义完整性约束（可选）：分为：
<ol start="4" type="1">
<li>域完整性约束：对属性的值域约束</li>
<li>其他约束：具体的业务规则</li>
</ol></li>
</ol>
<p>1.2 被称为”关系的不变性“，是关系模型必须遵循的完整性约束，由DBMS自动执行检查。</p>
<h3 id="实体完整性约束">1.实体完整性约束</h3>
<p>主码不能取空值NULL。</p>
<h3 id="参照完整性约束">2.参照完整性约束</h3>
<p>关系R的外码F，与关系S的主码K对应，那么字段F的取值：</p>
<ul>
<li>要么取S的某个元组的主码值。</li>
<li>要么取空值NULL</li>
</ul>
<p>注意：R和S通常是不同的关系，但也可以是同一关系——即同一关系的非主码参照了主码。</p>
<p>比如：职工表中存在一个“上级”字段，上级就必然要参照职工编号字段。</p>
<h3 id="用户完整性约束">3.用户完整性约束</h3>
<p>针对某一具体应用业务的完整性约束条件。</p>
<p>关系数据库提供了定义机制，从而让DBMS来执行完整性约束检查，当然，也可以由应用程序来检查。</p>
<h3 id="关系模型完整性约束的检验">关系模型完整性约束的检验</h3>
<p>在执行插入、删除、更新操作时，需要检验完整性约束。</p>
<h6 id="插入">(1)插入</h6>
<p>首先检查实体完整性约束。<br>
检查插入行的主码值是否已经在表中存在：</p>
<ul>
<li>如果存在：拒绝插入</li>
<li>如果不存在：允许插入</li>
</ul>
<p>还应该检查插入行在主码的各属性（主码有多个属性）是否为空</p>
<ul>
<li>如果主码的某个属性=NULL，拒绝插入。</li>
<li>如果主码的所有属性≠NULL，允许插入</li>
</ul>
<p>然后检查参照完整性约束。<br>
如果是向参照关系中插入，需要检查插入行在外码属性上的值，是否在被参照关系的主码属性值中存在：</p>
<ul>
<li>如果参照关系的外码取值 in 被参照关系的主码取值：允许插入</li>
<li>否则：不允许插入，或将外码属性置为NULL后插入。</li>
</ul>
<p>最后，检查用户定义完整性约束，包括值域和业务规则。 ###### (2)删除 只需要检查参照完整性约束。<br>
如果是删除被参照关系的元组，那么需要检查：被删除的元组的主码值，是否被其他参照关系的外码引用：</p>
<ul>
<li>如果没有引用：可以删除</li>
<li>如果有引用：
<ul>
<li>不允许删除</li>
<li>把参照关系的外码修改为NULL（空值删除）</li>
<li>把有引用的参照关系中的元组一起删除（级联删除）</li>
</ul></li>
</ul>
<h6 id="更新">(3)更新</h6>
<p>更新 = 删除 + 插入。</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第二章 关系数据库</category>
      </categories>
  </entry>
  <entry>
    <title>用 Hexo-Console-Rename 修改文件名</title>
    <url>/2019/11/28/%E7%94%A8-hexo-console-rename-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D/%E7%94%A8-hexo-console-rename-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D/</url>
    <content><![CDATA[<p>我们通常使用<code>hexo new [layout] "title"</code> 来新建博文，但常常会在创建博文后对又对原标题 <code>title</code> 不满意，如果仅仅修改内文标题，就会造成 <code>source/_post</code>(假设layout= post) 下的文件名 <code>oldFileName.md</code> 和内文标题 <code>title</code>不一致的情况。</p>
<p>手工的方法是将<code>oldFilename</code> 修改为和 front-matter 中的 <code>title</code> 一致。</p>
<p>如果站点配置文件 _config.yml 中<code>post_asset_folder: true</code>，则需要修改 oldFileName.md 对应的 source/oldFileName 文件夹的名称。</p>
<p>如果 <code>new_post_name: :year_:month_:date_:title.md</code> ，那么修改时更容易出错。</p>
<p>当然，另一个解决办法是：新建新标题博文，将老博文内容复制过来，删除老博文。</p>
<p>但总之而言，hexo 改名都不容易。</p>
<p>好在有插件可以解决这个问题, <a href="https://github.com/timnew/hexo-console-rename" target="_blank" rel="noopener">hexo-console-rename</a> ，它可以根据 md 文件的 front-matter 中的 <code>title</code> 修改文件名，支持单个文件改名、批量文件改名等操作，我们仅需要修改 <code>title</code> 属性为我们想要的标题，再执行 hexo rename source/_post/oldFileName.md。</p>
<p>具体用法参见 github 即可，不多废话。</p>
<p>这里要说下几个遇到的问题。</p>
<p>1.npm 安装后无法使用。<br>
原因是 npm 安装时没有把 lib 放入 node_module/hexo-console-rename 文件夹，解决办法是新建 lib 文件夹,从 github 下载 lib 中的所有 .js 文件，手工拷入即可。</p>
<p>2.利用 <code>hexo rename source/**/*.md</code> 对所有源文件批量改名后，会导致 <code>source/categories/index.md</code> , <code>source/tags/index.md</code>, <code>source/404/index.md</code> 这些 page layout 的 md 文件名被修改,造成这些页面无法访问，这是个 bug 。 解决办法：运行批量改名后，将这些 md 文件的名称改回来。</p>
]]></content>
      <categories>
        <category>应用软件</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 插入图片的多种方法</title>
    <url>/2019/11/28/hexo-%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/hexo-%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在Hexo 中插入图片，可以使用传统 Markdown 语法 ### 传统的Markdown 语法 <code>![text](imgpath)</code></p>
<p>但为了按文章管理资源，可以启用“文章资源管理模式”，通过将站点配置文件 config.yml 中的 post_asset_folder 选项设为 true 即可启用。</p>
<h3 id="hexo-资源文件夹中的本地图片不能设定显示尺寸">hexo 资源文件夹中的本地图片（不能设定显示尺寸）</h3>
<p><code></code></p>
<p>但在实践中，仍然有一些需要注意的地方。</p>
<ol type="1">
<li>图片应放入文章对应的资源文件夹中</li>
<li>严格按照  进行书写</li>
<li>图片的文件名大小写敏感！</li>
<li>不需要另起一行（markdown 代码语法 <code></code> 则需要另起一行）</li>
</ol>
<h3 id="网络图片可以设定显示尺寸">网络图片（可以设定显示尺寸）</h3>
<p><code><img src="http://www.viemu.com/vi-vim-cheat-sheet.gif" width="200" height="400" title="vi-vim-cheat-sheet"></code></p>
<h3 id="使用-html-语法">使用 HTML 语法</h3>
<p><img src="SpellCheck.png" width="50%" height="50%" title="拼写检查工具Grammarly." alt="拼写检查工具Grammarly."></p>
]]></content>
      <categories>
        <category>应用软件</category>
      </categories>
  </entry>
  <entry>
    <title>利用Chrome同时登录网站的多个账号</title>
    <url>/2019/11/28/%E5%88%A9%E7%94%A8Chrome%E5%90%8C%E6%97%B6%E7%99%BB%E5%BD%95%E7%BD%91%E7%AB%99%E7%9A%84%E5%A4%9A%E4%B8%AA%E8%B4%A6%E5%8F%B7/%E5%88%A9%E7%94%A8chrome%E5%90%8C%E6%97%B6%E7%99%BB%E5%BD%95%E7%BD%91%E7%AB%99%E7%9A%84%E5%A4%9A%E4%B8%AA%E8%B4%A6%E5%8F%B7/</url>
    <content><![CDATA[<p>有时，我们会在同一个网站注册多个账号，即所谓的小号。</p>
<p>对一个网站来说，同一时刻同一浏览器只能登录一个账号，要登录另一个账号必须退出当前在线的账号。</p>
<p>但在chrome中，可以利用<strong>用户管理</strong>实现同时登录多个账号。</p>
<p>其原理是通过在 chrome 中建立多个<strong>用户</strong>，每个用户的数据、设置都是完全独立的，包括书签、历史、设置、插件、网页应用、Cookie等。每个用户可以独占一个Chrome窗口，这样就可以在不同的窗口（用户）中，用不同的账号同时登陆同一个网站。</p>
<p>具体操作很简单：</p>
<p>1.点击右上角的头像图标<br>
<img src="/2019/11/28/利用Chrome同时登录网站的多个账号/利用chrome同时登录网站的多个账号/usrBtn.png"></p>
<p>2.在下拉菜单中选择“管理用户”，<br>
<img src="/2019/11/28/利用Chrome同时登录网站的多个账号/利用chrome同时登录网站的多个账号/usrMenu.png"></p>
<p>弹出“添加用户”、“以访客身份浏览”的界面。 <img src="/2019/11/28/利用Chrome同时登录网站的多个账号/利用chrome同时登录网站的多个账号/usrWind.bmp"></p>
<p>在这里可以添加新用户，或切换到访客身份。</p>
<p>新用户可以是本地账户(不关联google账户，数据和设置仅存储在本地)，也可以是google账户(通过gmail关联，允许将设置和数据同步到google服务器，当然也可以不同步)。</p>
]]></content>
      <categories>
        <category>应用软件</category>
      </categories>
  </entry>
  <entry>
    <title>数原 1.3 数据系统的结构</title>
    <url>/2019/11/18/%E6%95%B0%E5%8E%9F-1-3-%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84/%E6%95%B0%E5%8E%9F-1-3-%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>在一个数据库系统中，不同的用户从不同的角度看待数据库，会形成不同的视图结构。</p>
<ul>
<li>从DBA的角度来看， 数据库系统分为：
<ul>
<li>内部系统结构：
<ul>
<li>模式</li>
<li>外模式</li>
<li>内模式</li>
</ul></li>
<li>外部系统结构：
<ul>
<li>集中式结构</li>
<li>分布式结构</li>
<li>并行结构</li>
</ul></li>
</ul></li>
<li>从数据库系统的用户（如应用程序开发人员）来看——数据系统的运行和应用结构
<ul>
<li>客户/服务器结构，CS</li>
<li>浏览器/服务器结构，BS</li>
</ul></li>
</ul>
<h2 id="一数据库系统的三级模式结构">一、数据库系统的三级模式结构</h2>
<p>所有的DBMS都遵循美国 ANSI/SPARC 数据库管理研究组提出的三级模式结构：外模式（用户级）、模式（概念级）、内模式（物理级）。</p>
<h3 id="模式概念模式逻辑模式schema">1.模式，概念模式，逻辑模式，Schema</h3>
<p>模式：是数据库中全体数据的逻辑结构和特征的描述，是数据库的全局概念视图。</p>
<p>模式定义了数据的逻辑结构、数据之间的联系，以及数据的安全性、完整性要求。</p>
<p>模式与数据的物理存储细节、硬件环境无关，也与具体的应用程序、开发工具、开发语言无关。</p>
<p>一个数据库只能有一个模式。</p>
<p>P.S. 模式可以简单的理解为 表、主键、外键、视图、约束等，并且属于所有用户（不属于特定用户）。</p>
<h3 id="外模式子模式用户模式subschema">2.外模式，子模式，用户模式，subSchema</h3>
<p>外模式：是数据库用户（包括程序员和终端用户）能够看见和使用的，局部数据的逻辑结构和特征的描述。</p>
<p>外模式是用户视图，是模式的子集，它和某个应用所需的数据紧密联系。</p>
<p>外模式还能够对模式的局部数据重构。<br>
模式中同样的数据，在外模式中其结构、类型、长度、权限都可以不同。</p>
<p>外模式可以保证数据库安全，还可以简化数据库系统的用户接口，并支持了数据的独立性和共享性。</p>
<h3 id="内模式存储模式storage-schema">3.内模式，存储模式，storage schema</h3>
<p>内模式：是对数据库中数据的物理结构和存储方式的描述，是数据在数据库内部的表示形式。</p>
<p>内模式是数据库的最底层，但并非物理层！它仍然属于逻辑描述，比如：<br>
记录、索引、文件的组织方式，存储数据时采用顺序结构存储还是B树结构存储，数据是否压缩是否加密等。<br>
而非具体的物理方法：柱面、磁道的大小等，那些属于文件系统的范畴。</p>
<h3 id="三级模式结构的两层映像与数据独立性">4. 三级模式结构的两层映像，与数据独立性</h3>
<p>三级模式是对数据的三级抽象，三级抽象具有如下的特点：</p>
<ul>
<li>概念模式独立于内模式和外模式（它只和业务相关），是数据库的核心，也是数据库设计的关键</li>
<li>内模式<strong>依赖</strong>于概念模式，但独立于外模式和存储设备。</li>
<li>外模式依赖于模式和具体的应用程序，独立于内模式和存储设备。</li>
<li>应用程序依赖于外模式，独立于模式和内模式</li>
</ul>
<p>为了有效支撑三级抽象，DBMS提供了两层映像（映像就是对应规则，指出双方如何转换的）</p>
<ul>
<li>外模式/模式映像：定义了各个外模式和模式之间的映像关系，这些映像存在于外模式中。每一个外模式都有一个外模式/模式映像。如果模式发生变化，DBA会对各个外模式/模式映像进行更新，以尽量保持外模式不变，实现数据与程序的逻辑独立性。</li>
<li>模式/内模式映像：定义了概念模式和内模式之间的对应关系，通常存在于概念模式中。模式/内模式映像只有一个。当内模式发生改变时，DBA会修改模式/内模式映像，使模式保持不变，实现了数据与程序的物理独立性。</li>
</ul>
<h2 id="二数据库系统的运行与应用结构">二、数据库系统的运行与应用结构</h2>
<h3 id="客户服务器结构cs">1. 客户/服务器结构，CS</h3>
<ul>
<li>客户端/前台/表示层：命令行客户端、GUI管理工具、应用程序<br>
</li>
<li>服务器/后台/数据层：DBMS</li>
</ul>
<h3 id="浏览器服务器结构bs">2. 浏览器/服务器结构，BS</h3>
<p>BS结构：基于WEB应用的客户/服务器结构，也称为”三层结构“。</p>
<ul>
<li>表示层：数据库使用者的操作和展示界面，通常指浏览器。</li>
<li>处理层：也称为中间层，负责处理具体的应用逻辑。</li>
<li>数据层：DBMS。</li>
</ul>
<p>处理层+ 数据层，称为”胖服务器“。</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第一章 数据系统概述</category>
      </categories>
  </entry>
  <entry>
    <title>数原 1.4 数据模型</title>
    <url>/2019/11/18/%E6%95%B0%E5%8E%9F-1-4-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/%E6%95%B0%E5%8E%9F-1-4-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>模型(model)，通过对”现实世界事物的特征“进行抽象，实现模拟。</p>
<p>数据模型(Data Model)，也是对”现实世界中数据的特征“进行了抽象，从而模拟了现实世界的数据。</p>
<h2 id="一数据特征与数据模型组成要素">一、数据特征与数据模型组成要素</h2>
<p>现实世界中的数据具有两种特征：</p>
<ol type="1">
<li>静态特征：数据的基本结构、数据间的联系、对数据的约束（比如取值范围）</li>
<li>动态特征：对数据可以进行的、符合一定规则的操作。</li>
</ol>
<p>对数据进行抽象的数据模型，自然就需要描述数据的静态特征和动态行为，并为数据的表示和操作提供框架。</p>
<p>数据模型的定义：<br>
描述数据的静态结构，定义可对数据执行的操作和数据间约束的一组概念。</p>
<h3 id="数据模型的三要素">数据模型的三要素：</h3>
<h6 id="数据结构">1.数据结构</h6>
<p>描述数据的静态特性，如：数据类型、内容、属性、数据之间的联系。</p>
<p>常常用”数据结构的类型“来命名数据模型，比如： 层次结构（树）--层次模型，网状结构（有向图）--网状模型，关系结构（二维表）--关系模型。</p>
<h6 id="数据操作">2. 数据操作</h6>
<p>数据操作描述了数据的动态特性，包括：允许对数据执行的操作和操作规则。</p>
<p>操作分为更新和检索两大类，更新包括：插入、删除、修改。</p>
<p>操作规则包括：各操作的优先级等。</p>
<h5 id="数据约束">3. 数据约束</h5>
<p>数据约束描述了：数据结构中，数据间的语法和语义关联，包括（相互制约关系）、（相互依存关系）、（数据的动态变化规则），从而保证数据的完整性（正确性、有效性、相容性）。</p>
<p>数据约束又分为：</p>
<ol type="1">
<li>数据完整性约束：</li>
<li>数据安全性约束：</li>
<li>并发控制约束：</li>
</ol>
<h2 id="二数据模型的分类">二、数据模型的分类</h2>
<p>理想的数据模型，应该满足三方面的要求：</p>
<ul>
<li>比较真实的模拟现实世界</li>
<li>容易被人们理解</li>
<li>便于在计算机上实现</li>
</ul>
<p>但几乎没有这样的数据模型。<br>
因此，只能采用逐步抽象的方法：在不同的层面使用不同的数据模型。</p>
<p>首先将现实世界抽象为信息世界中的某种信息结构（数据模型），它不依赖于具体的计算机系统，不依赖于具体的DBMS，只是一种概念。<br>
然后，将概念级的信息模型抽象为某一具体的DBMS支持的数据模型。</p>
<p>因此，数据模型是数据库系统DBS的核心和基础。</p>
<p>数据模型从分层角度，可分为：</p>
<ol type="1">
<li>概念层数据模型</li>
<li>逻辑层数据模型，</li>
<li>物理层数据模型</li>
</ol>
<p>数据模型有”型“和”值“的之分。</p>
<ul>
<li>型：描述了实体型的结构和属性。（实体型概念见后文）<br>
</li>
<li>值：某个具体实体的值。</li>
</ul>
<h3 id="概念层数据模型也称为数据的概念模型信息模型conceptual-model">1.概念层数据模型，也称为数据的概念模型，信息模型，Conceptual Model</h3>
<p>抽象的表示了现实世界的各种事物及其联系，与计算机系统和DBMS无关。</p>
<p>概念模型有几个优点：</p>
<ul>
<li>是设计数据库的有力工具</li>
<li>数据库设计人员和用户之间的交流语言</li>
</ul>
<h4 id="信息世界中的基本概念">（1）信息世界中的基本概念</h4>
<p>①实体(Entity)：客观存在并可以相互区别的事物。实体可以是抽象的概念或联系。</p>
<p>②属性(attribute)：实体的某种特性。一个实体可以有多个属性。</p>
<p>③码或键(key):可<strong>唯一标识实体</strong>的”属性集合“，称为码或键。</p>
<p>④域(domain):属性的取值范围。每个属性都有自己的域。</p>
<p>⑤实体型(Entity Type)：属性完全相同的实体构成一个类型，称为”实体型“。用”实体名+属性集合“来表达实体型。比如：<em>学生（学号、姓名、性别、出生日期）</em> 就是一个实体型。</p>
<p>⑥实体集(Entity Set)：实体型中实体的集合，称为实体集。</p>
<p>⑦关系、联系(Relationship)：实体（型）内部的联系（即属性之间的联系），和实体（型）之间的联系。联系也可以有属性！</p>
<h4 id="概念模型的表示方法">（2）概念模型的表示方法</h4>
<p>概念模型的表示方法很多，最常用的是实体-联系方法（Entity-Relationship approch)，简称ER方法。</p>
<p>ER方法（也称为ER模型）：采用ER图来表示概念模型。</p>
<p>ER图的表示方法：</p>
<ul>
<li>实体型：用矩形表示，内部写明实体的名称。</li>
<li>属性：用椭圆形表示，并用无向边连接到实体。</li>
<li>联系：用菱形表示，内部写明联系的名称，用无向边连接相关的实体，并在无向边旁标注联系的类型（1：1，1：N；M：N）。如果联系具有属性，则这些属性也有用无向边与联系相连接。</li>
</ul>
<h3 id="逻辑层数据模型数据的逻辑模型logic-model">2.逻辑层数据模型，数据的逻辑模型（Logic Model)</h3>
<p>逻辑层模型描述了：某业务/某组织涉及的数据的整体逻辑结构。</p>
<p>逻辑模型是以计算机系统看待世界的观点来完成数据建模的。</p>
<p>所有的DBMS都必须基于某种逻辑模型。</p>
<p>逻辑模型分为：</p>
<ul>
<li>层次模型（树）：DBMS最早使用的数据模型。其数据结构是一棵”有向树“。每个节点对用了一个记录集（即现实世界的实体集）。缺点：层次模型难以表达实体之间比较复杂的联系。</li>
<li>网状模型（有向图）：优点是可以表示实体间各种联系，缺点是过于复杂，实现的算法难以规范化。</li>
<li>关系模型（二维表）：以二维表来表示实体和联系，并以二维表来组织数据。关系模型的优点：
<ul>
<li>具有严格的数学基础：以集合论中的关系数学理论为基础。</li>
<li>数据结构简单清晰，用户易懂易用：统一用关系（即表）来表示实体和联系，检索和更新结果也用关系来表示。</li>
<li>存取路径透明，具有更高的数据独立性、更好的保密性：关系模型把存取路径向用户隐蔽起来，用户只需要指出”干什么“或”找什么“，不必详细说明”怎么干“或”怎么找“（层次模型就需要说明）。</li>
</ul></li>
<li>面向对象模型(对象）：用面向对象的观点来描述实体、联系的数据模型。比关系模型的表达能力更强，且对象可复用，维护方便。面向对象模型既是概念模型，又是逻辑模型。</li>
</ul>
<h3 id="物理层数据模型数据的物理模型physical-model">3.物理层数据模型，数据的物理模型，Physical Model</h3>
<p>描述了数据在存储介质上的组织结构，是逻辑模型的物理实现。</p>
<p>物理模型确定了：数据的物理存储结构、数据存取路径、优化数据库的性能。</p>
<p>物理模型的抽象由DBMS负责完成。</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第一章 数据系统概述</category>
      </categories>
  </entry>
  <entry>
    <title>数原 1.2 数据管理技术的发展</title>
    <url>/2019/11/18/%E6%95%B0%E5%8E%9F-1-2-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95/%E6%95%B0%E5%8E%9F-1-2-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<h6 id="数据管理">数据管理</h6>
<p>数据管理包括2个方面：</p>
<ol type="1">
<li>针对组织的业务数据的管理：制定并执行“组织中关于数据的定义、组织、保护与使用的”的策略、过程和计划；（这是与数据管理技术无关的活动）</li>
<li>依靠数据管理技术，集中控制管理数据。（本节的主要内容）</li>
</ol>
<p>与计算机技术结合的数据管理包括：</p>
<ul>
<li>收集：收集数据，将存储在其他介质的数据转换成计算机可处理的形式；</li>
<li>组织：将收集来的数据进行适当的构造
<ul>
<li>逻辑组织：用户或应用程序所见到的数据结构形式</li>
<li>物理组织：数据在物理存储设备上的结构形式</li>
</ul></li>
<li>归类存储：正在使用的数据，和作为备份的数据。</li>
<li>提供检索方法：便于用户快速获取信息</li>
<li>存取：建立规则和执行规则的过程，控制数据的存取，从而保护数据的正确性和安全性</li>
<li>维护：数据的规模和结构可能发生变化，需要维护。</li>
</ul>
<p>数据管理的任务（目的）：通过数据的收集、组织、控制、存储、选取、维护，实现在适当的时刻、以适当的形式、向适当的人提供适当的数据。</p>
<h6 id="数据处理">数据处理</h6>
<p>数据管理是数据处理的中心问题，数据处理比数据管理的概念更宽泛。</p>
<p>数据处理：对各种数据进行收集、存储、加工、传播的活动。</p>
<h2 id="数据管理技术">数据管理技术</h2>
<h3 id="人工管理阶段">1.人工管理阶段</h3>
<p>特点：</p>
<ul>
<li>数据无法保存在计算机中：没有磁盘等存储设备，输入数据和输出只能放在纸带上，程序执行完毕后，数据空间随程序空间一起被释放。</li>
<li>应用程序管理数据：没有操作系统也没有数据管理软件，数据由应用程序执行负责，数据的逻辑结构、物理结构（读写纸带）、存取方法都由应用程序编写人员来完成。数据和应用程序高度依赖。</li>
<li>数据面向应用：一组数据只能用于一个程序，多个程序要无法使用同一组数据，只能分别定义，数据冗余度非常高，数据独立性差。</li>
</ul>
<h3 id="文件系统阶段">2.文件系统阶段</h3>
<p>数据的物理独立性：文件系统分离了数据的逻辑结构（文件的内容，即数据）和物理结构（文件在文件系统中如何存放），应用程序读写数据的逻辑结构，文件系统管理文件的物理结构。<br>
即使物理结构发生了改变，比如：把磁盘从一种文件系统转换为另一种文件系统，或者将文件从一台机器拷入另一台具有不同文件系统的机器，就不需要修改应用程序——因为文件的内容，即逻辑结构没有改变。</p>
<p>特点：</p>
<ul>
<li>数据可以长期保存在计算机中：有了磁盘、磁鼓等直接存取设备。</li>
<li>数据以文件的形式由文件系统管理：有了操作系统，以及专门的数据管理软件——文件系统</li>
<li>实现了数据的物理独立性：使数据的逻辑结构和物理结构分离开来。</li>
<li>实现了文件级的数据共享：一个文件可以为多个应用程序服务。也可以抽取多个文件的内容，组织成新的文件，形成新的数据。</li>
</ul>
<p>缺点：<br>
只实现了文件级的共享，没有实现记录级的共享。应用程序和数据之间仍然存在依赖关系，仍然可能需要构建新的文件来满足应用程序的需要，从而导致数据冗余。</p>
<h3 id="数据库系统阶段">3.数据库系统阶段</h3>
<ul>
<li>数据集成：数据被集成到DBMS中，得到最大程度的共享，冗余最小。</li>
<li>数据共享度高：多个用户可以共同使用相同的数据，而且可以同时并发存取同一数据。</li>
<li>数据冗余小：冗余不应该完全消除，为了合法性检验、数据存取效率等原因，受控的冗余是应该的。</li>
<li>数据一致性：冗余的多个副本没有同时得到更新，导致失去一致性。维持一致性是数据库系统的任务。</li>
<li>数据独立性高：数据和应用程序分离。在文件系统中，修改数据的定义、存取数据的逻辑，都需要修改应用程序(修改数据的定义后，文件的读取会受到影响，应用程序就需要修改）。
<ul>
<li>数据的逻辑独立：如果应用程序只修改视图，就不会影响数据；在一定范围内修改数据的定义，也可能不需要修改应用程序（修改部分可能不涉及应用程序读取的部分）。</li>
<li>数据的物理独立：改变数据的存储结构、存取方法，无需修改应用程序。（应用程序关心的是数据的逻辑结构）</li>
</ul></li>
<li>实施统一管理和控制：DBMS 可以实现对数据的统一管理和控制，包括：
<ul>
<li>安全性：每个用户只能按照规定的方式访问数据，比如权限管理，防止了泄密和破坏。</li>
<li>完整性：保证输入到数据库的数据满足约束，数据之间满足一定的关系，数据只在一定范围内有效（比如性别只能男和女）。</li>
<li>并发控制：DBMS需要对并发访问进行控制、协调，避免得到错误结果，或破坏数据库的完整性。</li>
<li>故障恢复：将数据库恢复到某个已知的正确状态。</li>
</ul></li>
<li>减少应用程序开发和维护的工作量：数据的共享性和独立性促成。</li>
</ul>
<h6 id="补充资料">补充资料</h6>
<p>数据的完整性：是对数据的正确性、有效性、和相容性的要求。</p>
<p>有效性：对数据是否正确的测试标准。</p>
<p>相容性：描述同一事实的两个数据应相同，称为两个数据相容，否则两个数据不相容。比如一个人不能有2个性别。</p>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第一章 数据系统概述</category>
      </categories>
  </entry>
  <entry>
    <title>数原 1.1 数据库基本概念</title>
    <url>/2019/11/18/%E6%95%B0%E5%8E%9F-1-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E6%95%B0%E5%8E%9F-1-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="数据">1.数据</h3>
<p>数据是描述事物的符号记录，是用物理符号记录下来的、可以鉴别的信息。</p>
<p>人们通常抽取事物的某些特征或属性来描述事物。<br>
此时仅有数据，没有对数据的解释就无法理解数据的意义。</p>
<p>语义：数据所蕴含的信息，是对数据的解释。</p>
<p>数据和语义密不可分。</p>
<p>没有语义的数据是无意义的，不完整的。</p>
<h3 id="数据库">2.数据库</h3>
<p>数据库(DataBase,DB)：长期存储在计算机中的，有组织、可共享的数据集合。</p>
<p>数据库中的数据具有下列特点：</p>
<ul>
<li>按一定的数据模型组织、描述、存储</li>
<li>具有较小的冗余度</li>
<li>较高的数据独立性</li>
<li>可以被多个用户共享</li>
</ul>
<h3 id="数据库管理系统">3. 数据库管理系统</h3>
<p>数据库管理系统(DataBase Management System,DBMS)：创建和管理数据库的一套软件。</p>
<p>DBMS 介于应用程序和操作系统之间，负责： 组织和存储数据，使数据库使用者（应用程序、人）能够快速获取所需数据，通过统一的控制机制提供必要的安全性和完整性，管理和维护数据。</p>
<p>DBMS的主要功能：</p>
<ul>
<li>数据定义功能：通过DDL定义DB中的数据对象——表、视图、存储过程、触发器等。</li>
<li>数据操纵功能：通过DML操纵数据，实现增删查改等。</li>
<li>数据库的运行、管理功能：DBMS的控制和管理机制，使多个用户可以安全、可靠的同时使用数据，并能够恢复出现故障的数据库。</li>
<li>数据库的建立和维护功能：创建数据库、维护数据库空间、备份与恢复数据库、数据库的性能监视与分析。这些功能是通过DBMS提供的一些实用工具来实现的。</li>
<li>数据组织、存储、管理功能：为了提高对数据库中数据的存取效率，DBMS需要对数据库中的数据在物理层面上分类存储和管理。DBMS还提供了多种数据的存取方法，比如索引查找、顺序查找等。（这个功能，可能涉及了数据的物理存储层面的东西）</li>
<li>其他功能：与其他软件的网络通信功能，不同DBMS之间传输数据、访问对方数据库，通过DBMS提供的API，使用编程语言与数据库交互等。</li>
</ul>
<h3 id="数据库系统">4. 数据库系统</h3>
<p>数据库系统(Database System,DBS)：在计算机中引入数据库技术之后的系统。</p>
<p>一个完整的DBS包括：</p>
<ul>
<li>DBMS及实用工具</li>
<li>DB</li>
<li>应用程序</li>
<li>DBA</li>
<li>用户（程序员+数据库终端用户）：DBS的服务对象。终端用户以交互方式向DBS提供操作请求，DBMS响应请求访问DB中的数据，返回给终端用户。终端用户不是应用程序的使用者。</li>
</ul>
]]></content>
      <categories>
        <category>数据库系统原理</category>
        <category>第一章 数据系统概述</category>
      </categories>
  </entry>
  <entry>
    <title>网原 1.3 计算机网络的分类</title>
    <url>/2019/11/17/%E7%BD%91%E5%8E%9F-1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E7%B1%BB/%E7%BD%91%E5%8E%9F-1-3-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="按拓扑类型">1.3.1 按拓扑类型</h2>
<p>网络拓扑： 指网络的形状，或者说网络在物理上的连通性。</p>
<p>网络拓扑包括：</p>
<ul>
<li>星型<br>
</li>
<li>总线型</li>
<li>环形</li>
<li>树形</li>
<li>混合型</li>
<li>网型 <a id="more"></a></li>
</ul>
<p>选择哪一种拓扑类型，与传输介质、介质访问控制方法有关。<br>
选择网络拓扑类型时，应考虑以下因素：</p>
<ul>
<li>可靠性：保证所有的数据能够准确送达目的节点。</li>
<li>可维护性：便于故障检测、故障隔离</li>
<li>费用：信道费用、安装费用</li>
<li>灵活性：便于添加、删除节点，易于配置拓扑结构</li>
<li>响应时间：尽可能短</li>
<li>吞吐量：尽可能大</li>
</ul>
<p>网络拓扑根据通信子网中的信道类型可分为：</p>
<ul>
<li>点对点信道：每条信道连接一对节点。包括：
<ul>
<li>星型</li>
<li>环形</li>
<li>树形</li>
<li>网型</li>
</ul></li>
<li>广播信道：多个网络节点共享一个公共信道。
<ul>
<li>总线型</li>
<li>环形</li>
<li>树形</li>
<li>无线通信</li>
<li>卫星通信</li>
</ul></li>
</ul>
<h4 id="星型拓扑">1.星型拓扑</h4>
<p>星型拓扑，是由<strong>中央节点</strong>，和通过“点对点通信链路”连接到中央节点的<strong>周边节点</strong>，组成。</p>
<p>中央节点往往是一个集线器(hub)。</p>
<p>集中式通信控制策略：<br>
中央节点执行集中式通信控制策略，因此中央节点的负担较重，而周边节点处理通信的负担很轻。</p>
<p>优点：</p>
<ul>
<li>控制简单：任一周边节点只与中央节点相连，因此介质访问控制方法简单，访问协议简单，网络监控简单。</li>
<li>故障检测、隔离简单：单个周边连接点的隔离很容易，便于检测故障，即使发生故障，也可以直接隔离，不会影响其他节点。</li>
<li>方便服务：中央节点可以方便的对周边节点提供服务，以及重新配置网络。</li>
</ul>
<p>缺点：</p>
<ul>
<li>电缆长度、安装量客观：</li>
<li>中央节点负担太重，形成瓶颈：一旦中央节点故障，则全网瘫痪。</li>
<li>周边节点的分布处理能力低下</li>
</ul>
<h4 id="总线拓扑">总线拓扑</h4>
<p>总线拓扑：所有节点都接入一条传输介质上，该传输介质作为共享的公共信道——称为总线。</p>
<p>分布式通信控制策略：<br>
任何一个节点发送的数据都会沿着总线传输，其他节点都可以接受该数据。<br>
为了防止多个站点同时发送数据造成信道拥堵，总线拓扑采用分布式通信控制策略：一个时点只允许一个节点发送数据。</p>
<p>优点：</p>
<ul>
<li>需要的电缆数量少：</li>
<li>结构简单，又是无源工作，可靠性较高：</li>
<li>增加、删除节点比较方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>总线的传输距离有限，网络规模受限</li>
<li>故障诊断、隔离较困难</li>
<li>分布式通信控制协议不能保证数据的及时传输，不具有实时功能，业务量越大网络速度就越慢。</li>
<li>节点必须是智能的，要有介质访问控制功能，增加了站点的硬件和软件开销。</li>
</ul>
<h4 id="环形拓扑">环形拓扑</h4>
<p>环形拓扑：由节点和节点间的链路构成的一个闭合环。</p>
<p>工作方式：<br>
每个节点可以接受来自于链路的数据，并可以将数据通过链路发送到下一个节点。<br>
链路可以是单向的（数据总是沿着固定方向传输），也可以是双向的（数据传输方向不固定）。<br>
数据是以分组的形式发送的，每个分组除了数据，还有一些控制信息，包括源和目的地址。</p>
<p>环形拓扑采用分布式通信控制策略。</p>
<p>优点：</p>
<ul>
<li>电缆长度短：其长度与总线型拓扑一样</li>
<li>可使用光纤：</li>
<li>所有节点都公平的访问网络的其他部分（通信子网、资源子网），网络性能稳定。</li>
</ul>
<p>缺点：</p>
<ul>
<li>任一节点故障会引起全网故障：</li>
<li>增加、删除节点较复杂</li>
<li>介质访问控制协议采用令牌传递，在负载很低时，信道利用率就很低。</li>
</ul>
<h4 id="树形拓扑">树形拓扑</h4>
<p>树形拓扑：可以看做是总线型和星型的结合，根节点的分叉，就像星型拓扑，每条分支上有多个节点共享该信道。</p>
<p>工作方式：<br>
某一个结点发出数据后，会发给根节点，根节点收到数据后在全网广播。目的节点收到广播数据后，复制一份给自己处理。</p>
<p>优点：</p>
<ul>
<li>易于扩展：增加新分支、新节点都比较容易。</li>
<li>易于隔离故障：隔离某分支、某个结点都比较容易。</li>
</ul>
<p>缺点：<br>
可靠性比较差：各节点对树根的依赖太大，如果树根发生故障，则全网瘫痪。其可靠性类似于星型拓扑。</p>
<h4 id="混合型拓扑">混合型拓扑</h4>
<p>将前述的几种拓扑结构混合在一起组网，形成混合型拓扑结构。</p>
<p>比如：</p>
<ul>
<li>星型拓扑+ 总线型拓扑 = 星总拓扑</li>
<li>星型拓扑+ 环形拓扑 = 星环拓扑</li>
</ul>
<p>混合型拓扑的总线、环形上的节点往往是集中器，连接了若干主机。</p>
<p>优点：</p>
<ul>
<li>故障诊断、隔离较方便：通过诊断、隔离某个集中器，即可隔离该集中器子网</li>
<li>易于扩展：要增加主机时，一种办法是在总线、环形上增加集中器，另一种办法是扩展集中器的接入口</li>
<li>安装方便：总线、环形只要连通这些集中器即可，和安装电话系统相似。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要智能集中器：方便网络故障自动诊断、故障节点的隔离</li>
<li>集中器到各节点的电缆长度较长、安装量较大</li>
</ul>
<h4 id="网形拓扑">网形拓扑</h4>
<p>网形拓扑：广泛的应用于广域网，而非局域网。</p>
<p>优点：没有瓶颈，网络冗余度高，可靠性高，失效可能小。</p>
<p>缺点：结构复杂，成本高，网络协议较复杂。</p>
<h2 id="按网络交换分式">1.3.2 按网络交换分式</h2>
<ul>
<li>电路交换(Circuit Switching)：通信前，必须建立一条从发送端到目的端的物理信道，且通信期间双方始终占用该信道。类似于传统电话。</li>
<li>报文交换(Message Switching)：信道中传输的是发送方的完整报文，无长度限制，中间节点存储-转发该报文，接收方接受完整报文。类似于送信。</li>
<li>分组交换(Packet Switching)：也称为“包交换方式”，发送端先将报文分割为一个个等长的分组，各中间节点采用存储-转发方式传输分组到目的端，目的端再整合分组为一个完整的报文。<br>
因为每个分组都很小，所以中间节点可以在内存中存储-转发分组，从而大大提高了传输速度。</li>
</ul>
<h2 id="按覆盖范围">1.3.3 按覆盖范围</h2>
<p>按地理的覆盖范围分类：</p>
<ul>
<li>广域网（WAN,Wide Area Network，也称远程网)：分布范围几百~几千KM，可覆盖国家、洲，形成国际性的远程网络。通信子网通常是：卫星通信网、无线分组交换网、公用分组交换网。</li>
<li>城域网(MAN, Metropolitan Area Network）：将几十公里范围内的企业、机关、公司的局域网互连在一起。</li>
<li>局域网(LAN, Local Area Network)：覆盖极小的区域，提供高速、低误码率的高质量数据传输。</li>
</ul>
<h2 id="按网络传输技术">1.3.4 按网络传输技术</h2>
<ul>
<li>广播式：所有节点共享一个信道，所有节点都能“听到”分组，各节点根据分组的目的地址来决定是接受还是丢弃。 在广播式网络中，分组的目的地址有3种：单播、多播、广播。</li>
<li>点对点式：每条物理线路连接了一对节点。如果源节点和目的节点没有直接的链路，就需要中间节点对分组存储-转发，并且可能存在多条通信线路，需要节点进行路由选择计算。</li>
</ul>
<p>广播式和点对点式的区别：点对点式需要“存储转发”和“路由选择”。</p>
<p>资源子网负责信息处理，通信子网负责信息传递。</p>
<p>PSE : packet switching exchanger，分组交换设备 pad: packet assembler dissassebler, 分组组装/拆卸设备 NCC: network control center C：concentrator，集中器 G: gateway</p>
<p>imp : interface message processor , 接口信息处理机，是对PSE , PAD NCC C G 的统称。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
        <category>第一章 计算机网络概述</category>
      </categories>
      <tags>
        <tag>网络拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title>网原 计算机网络中容易搞混的知识点</title>
    <url>/2019/11/17/%E7%BD%91%E5%8E%9F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%AE%B9%E6%98%93%E6%90%9E%E6%B7%B7%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%BD%91%E5%8E%9F-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%AE%B9%E6%98%93%E6%90%9E%E6%B7%B7%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>可以从不同的角度对网络进行区分(不同角度得到的分类可能出现重叠)。</p>
<h4 id="按通信服务类型">按通信服务类型</h4>
<ul>
<li>面向连接服务： 从数据交换方式来看，包括：电路交换、虚电路分组交换</li>
<li>无连接服务 从数据交换方式来看，包括：报文交换、数据报分组交换 <a id="more"></a></li>
</ul>
<h4 id="按通信子网中信道类型或者叫拓扑类型">按通信子网中信道类型（或者叫拓扑类型）</h4>
<ul>
<li>广播信道：多个网络节点共享公共信道</li>
<li>点对点信道：每条物理线路连接一对节点</li>
</ul>
<h4 id="按通信子网的传输方式">按通信子网的传输方式</h4>
<p>数据传输方式：从整个通信子网看数据流。</p>
<p>数据在通信子网内是广播传输，还是存储转发+路由选择传输。 + 广播式传输： + 点对点式传输：</p>
<p>注意：<br>
1. 电路交换是接受后立即发送到下一个节点，网络节点无法存储数据，因此不属于点对点传输，而且电路交换占据专用物理通道，无法实现广播、多播，也不属于广播式传输。<br>
2. 报文交换，可以实现多播、广播，也一定会采用存储转发+路由选择，因此报文传输既可能是广播式传输，也可能是点对点式传输。 3. 分组交换，既可能是广播式传输，也可能是点对点式传输。</p>
<p>结论：通信子网的传输方式与中间节点的交换技术并无关联。</p>
<h4 id="按中间节点的交换技术">按中间节点的交换技术</h4>
<p>就单个中间节点来看。</p>
<p>中间节点并不关心数据内容，只是提供一种交换能力：将数据从一个节点传到另一个节点。</p>
<ul>
<li>电路交换：</li>
<li>报文交换：</li>
<li>分组交换
<ul>
<li>虚电路分组交换</li>
<li>数据报分组交换</li>
</ul></li>
</ul>
<h6 id="端到端">端到端</h6>
<p>端到端，有2种理解：</p>
<ol type="1">
<li>源端-目的端：比如上文中“网络层提供了端到端的数据传输服务”。</li>
<li>源主机的某端口-目的主机的某端口：专用于传输层。</li>
</ol>
<h6 id="数据包数据报">数据包，数据报</h6>
<p>数据包：packet，即分组。</p>
<p>数据报：datagram ,即无连接服务中的分组。</p>
<p>一个数据报，包含了一个TCP段，它可能只有一个分组，也可能被分片成多个分组。</p>
<p>换句话说，MSS数据部分，可能被分片成多个分组。</p>
<h6 id="ovehead-额外开销虚耗">ovehead ，额外开销，虚耗</h6>
<h6 id="拥塞控制和流量控制的差异">拥塞控制和流量控制的差异</h6>
<p>拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</p>
<p>流量控制：指点对点通信量的控制，是端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
]]></content>
      <categories>
        <category>计算机网络原理</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo + gitHub 搭建成功</title>
    <url>/2019/09/08/Hexo-gitHub-%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F/hexo-github-%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F/</url>
    <content><![CDATA[<p>用 hexo+github 写博客，是一直欠下的债。从年初拖到现在9月，才终于完成这个配置。</p>
<p>折腾了一天，终于能 deploy 到 github 并显示出来了。具体搭建过程不再复述。 <a id="more"></a></p>
<p>本次搭建，参考了 <a href="https://segmentfault.com/a/1190000017986794" target="_blank" rel="noopener">超详细Hexo+Github Page搭建技术博客教程</a>，以及 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo的帮助文档</a>。</p>
<p>其中遇到很多障碍：</p>
<ol type="1">
<li><p>Github 原来用的私人邮箱注册，现在不想用该邮箱发布博文，于是重新注册了新邮箱。期间尝试了 github 的选项: keep my email address private。<br>
结果这个选项对后面的 deploy 造成障碍，于是关闭了该选项。</p></li>
<li><p>nodej.js 和 git 是年初安装的，现在想看看 npm 已经安装过哪些东西，于是查阅了 ”如何查看 npm全局安装过的包”，指令如下：<br>
<code>npm list -g --depth 0</code></p></li>
<li><p>安装 hexo-deployer-git 时报错： <code>npm install hexo-deployer-git --save</code></p></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">WARN</span> <span class="string">deprecated</span> <span class="string">swig@1.4.2:</span> <span class="string">This</span> <span class="string">package</span> <span class="string">is</span> <span class="literal">no</span> <span class="string">longer</span> <span class="string">maintained</span></span><br><span class="line"><span class="string">npm</span> <span class="string">WARN</span> <span class="string">saveError</span> <span class="attr">ENOENT:</span> <span class="literal">no</span> <span class="string">such</span> <span class="string">file</span> <span class="string">or</span> <span class="string">directory,</span> <span class="string">open</span> <span class="string">'/Users/irene.liu/package.json'</span></span><br><span class="line"><span class="string">npm</span> <span class="string">WARN</span> <span class="string">enoent</span> <span class="attr">ENOENT:</span> <span class="literal">no</span> <span class="string">such</span> <span class="string">file</span> <span class="string">or</span> <span class="string">directory,</span> <span class="string">open</span> <span class="string">'/Users/irene.liu/package.json'</span></span><br><span class="line"><span class="string">npm</span> <span class="string">WARN</span> <span class="string">irene.liu</span> <span class="literal">No</span> <span class="string">description</span></span><br><span class="line"><span class="string">npm</span> <span class="string">WARN</span> <span class="string">irene.liu</span> <span class="literal">No</span> <span class="string">repository</span> <span class="string">field.</span></span><br><span class="line"><span class="string">npm</span> <span class="string">WARN</span> <span class="string">irene.liu</span> <span class="literal">No</span> <span class="string">README</span> <span class="string">data</span></span><br><span class="line"><span class="string">npm</span> <span class="string">WARN</span> <span class="string">irene.liu</span> <span class="literal">No</span> <span class="string">license</span> <span class="string">field.</span></span><br></pre></td></tr></table></figure>
<p>原因：必须在hexo初始化的那个目录下执行安装！</p>
<ol start="4" type="1">
<li>hexo g 命令后出错： <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">FATAL can not read a block mapping <span class="built_in">entry</span>; a multiline key may not be an <span class="keyword">implicit</span> key at line <span class="number">8</span>, column <span class="number">12</span>:</span><br><span class="line">description:</span><br><span class="line">^</span><br><span class="line">YAMLException: can not read a block mapping <span class="built_in">entry</span>; a multiline key may not be an <span class="keyword">implicit</span> key at line <span class="number">8</span>, column <span class="number">12</span>:</span><br><span class="line">description:</span><br></pre></td></tr></table></figure></li>
</ol>
<p>原因：yml 配置文件中，键值对的冒号后少了空格</p>
<ol start="5" type="1">
<li>hexo g -d 后，网页显示404</li>
</ol>
<p>原因: github 库中缺少 index .html</p>
<p>解决办法：</p>
<ul>
<li>按照 <a href="https://segmentfault.com/a/1190000017986794" target="_blank" rel="noopener">超详细Hexo+Github Page搭建技术博客教程</a> 的步骤，手工在 github 的库中创建 index.html<br>
</li>
<li><code>npm install hexo-generator-index --save</code>，也会生成 index.html 文件。</li>
</ul>
<ol start="6" type="1">
<li>在 <code>_config.yml</code> 中用中文书写 title 和 subtitle ，显示为乱码。</li>
</ol>
<p>解决办法： _config.yml 使用 utf-8 编码保存即可。</p>
<p>最后还有一些疑惑，比如：<br>
今天花了很大功夫配置SSH key 来访问 github，但后续 hexo g -d 时弹出账号密码框。</p>
]]></content>
      <categories>
        <category>应用软件</category>
      </categories>
  </entry>
</search>
